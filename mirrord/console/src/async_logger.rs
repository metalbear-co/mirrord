use drain::Watch;
use log::LevelFilter;
use mirrord_intproxy_protocol::codec::AsyncEncoder;
use tokio::{
    io::BufWriter,
    net::TcpStream,
    sync::mpsc::{self, Receiver, Sender},
};
use tokio_util::sync::CancellationToken;

use crate::{
    error::Result,
    protocol::{Hello, Record},
};

/// Background task for [`AsyncConsoleLogger`].
struct LoggerTask {
    encoder: AsyncEncoder<Record, BufWriter<TcpStream>>,
    rx: Receiver<Record>,
    cancellation_token: CancellationToken,
}

impl LoggerTask {
    fn new(rx: Receiver<Record>, cancellation_token: CancellationToken, stream: TcpStream) -> Self {
        Self {
            encoder: AsyncEncoder::new(BufWriter::new(stream)),
            rx,
            cancellation_token,
        }
    }

    async fn run(mut self) {
        loop {
            tokio::select! {
                _ = self.cancellation_token.cancelled() => break,

                msg = self.rx.recv() => match msg {
                    None => break,
                    Some(record) => {
                        if let Err(e) = self.encoder.send(&record).await {
                            eprintln!("Error sending log message: {e:?}");
                            break;
                        }
                        // Crucial for getting as many of the most interesting logs as possible right before
                        // the process exits.
                        let _ = self.encoder.flush().await;
                    }
                }
            }
        }
    }
}

/// Console logger that sends log messages to the console app using
/// [`codec`](mirrord_intproxy_protocol::codec). It uses a background [`tokio::task`] to send
/// messages with an [`AsyncEncoder`].
pub struct AsyncConsoleLogger {
    tx: Sender<Record>,
}

impl log::Log for AsyncConsoleLogger {
    /// Returns true if the log is generated by mirrord code.
    /// We can have this more fine-grained and also inclusive but
    /// be aware that you might get into a recursive scenario if you let
    /// other module logs slide in.
    fn enabled(&self, metadata: &log::Metadata) -> bool {
        metadata.target().contains("mirrord")
    }

    fn flush(&self) {}

    fn log(&self, record: &log::Record) {
        let msg = Record::from(record);
        if let Err(e) = self.tx.try_send(msg) {
            eprintln!("Error sending log message: {e}");
        }
    }
}

/// Send hello message, containing information about the connected process.
async fn send_hello(stream: &mut TcpStream) -> Result<()> {
    let hello = Hello::from_env();

    let mut encoder: AsyncEncoder<Hello, &mut TcpStream> = AsyncEncoder::new(stream);
    encoder.send(&hello).await?;

    Ok(())
}

/// Initializes the [`AsyncConsoleLogger`] and sets the global logger to use it.
pub async fn init_async_logger(address: &str, watch: Watch, channel_size: usize) -> Result<()> {
    let mut stream = TcpStream::connect(address).await?;
    stream.set_nodelay(true)?;
    send_hello(&mut stream).await?;

    let (tx, rx) = mpsc::channel(channel_size);

    let logger = AsyncConsoleLogger { tx };
    log::set_boxed_logger(Box::new(logger)).map(|()| log::set_max_level(LevelFilter::Trace))?;

    let cancellation_token = CancellationToken::new();
    let task = LoggerTask::new(rx, cancellation_token.clone(), stream);
    tokio::spawn(watch.watch(Box::pin(task.run()), move |_| cancellation_token.cancel()));

    Ok(())
}
