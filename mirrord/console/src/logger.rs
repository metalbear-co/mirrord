use std::{io::BufWriter, net::TcpStream, sync::Mutex};

use log::LevelFilter;
use mirrord_intproxy_protocol::codec::SyncEncoder;

use crate::{
    error::Result,
    protocol::{Hello, Record},
};

/// Console logger that sends log messages to the console app using
/// [`codec`](mirrord_intproxy_protocol::codec). It does not use any additional threads, but simply
/// sends the log records through a [`SyncEncoder`].
pub struct ConsoleLogger {
    encoder: Mutex<SyncEncoder<Record, BufWriter<TcpStream>>>,
}

impl log::Log for ConsoleLogger {
    /// Returns true if the log is generated by mirrord code.
    /// We can have this more fine-grained and also inclusive but
    /// be aware that you might get into a recursive scenario if you let
    /// other module logs slide in.
    fn enabled(&self, metadata: &log::Metadata) -> bool {
        metadata.target().contains("mirrord")
    }

    /// Serialize the logs into our protocol then send it over the wire.
    fn log(&self, record: &log::Record) {
        if self.enabled(record.metadata()) {
            let msg = Record::from(record);

            let mut guard = match self.encoder.lock() {
                Ok(guard) => guard,
                Err(e) => {
                    eprintln!("Error sending log message: {e:?}");
                    return;
                }
            };

            if let Err(e) = guard.send(&msg) {
                eprintln!("Error sending log message: {e:?}");
            }
            // Crucial for getting as many of the most interesting logs as possible right before
            // the process exits.
            let _ = guard.flush();
        }
    }

    fn flush(&self) {
        let mut guard = match self.encoder.lock() {
            Ok(guard) => guard,
            Err(e) => {
                eprintln!("Error sending log message: {e:?}");
                return;
            }
        };

        if let Err(e) = guard.flush() {
            eprintln!("Error flushing log messages: {e:?}");
        }
    }
}

/// Send hello message, containing information about the connected process.
fn send_hello(stream: &mut TcpStream) -> Result<()> {
    let hello = Hello::from_env();

    let mut encoder: SyncEncoder<Hello, &mut TcpStream> = SyncEncoder::new(stream);
    encoder.send(&hello)?;

    Ok(())
}

/// Initializes the [`ConsoleLogger`] and sets the global logger to use it.
pub fn init_logger(address: &str) -> Result<()> {
    let mut stream = TcpStream::connect(address)?;
    stream.set_nodelay(true)?;

    send_hello(&mut stream)?;

    let writer = BufWriter::new(stream);
    let logger = ConsoleLogger {
        encoder: Mutex::new(SyncEncoder::new(writer)),
    };

    log::set_boxed_logger(Box::new(logger)).map(|()| log::set_max_level(LevelFilter::Trace))?;

    Ok(())
}
