use std::{fmt, fs, io, net::IpAddr, path::PathBuf, process::Command, sync::LazyLock};

use ipnet::IpNet;
use mirrord_protocol::vpn::NetworkConfiguration;

use crate::{config::VpnConfig, error::VpnError};

static BASE_RESOLVE_PATH: LazyLock<PathBuf> = LazyLock::new(|| PathBuf::from("/etc/resolver"));

#[derive(Debug, Default)]
pub struct ResolveFile {
    port: u16,
    domain: String,
    nameservers: Vec<String>,
    search: Vec<String>,
    options: Vec<String>,
}

impl ResolveFile {
    pub fn inject(&self) -> io::Result<ResolveFileGuard> {
        if !BASE_RESOLVE_PATH.exists() {
            fs::create_dir_all(&*BASE_RESOLVE_PATH)?;
        }

        let path = BASE_RESOLVE_PATH.join(&self.domain);
        fs::write(&path, self.to_string())?;

        Ok(ResolveFileGuard { path })
    }
}

impl fmt::Display for ResolveFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let ResolveFile {
            port,
            domain,
            nameservers,
            search,
            options,
        } = self;

        writeln!(f, "# Generated by mirrord")?;

        if *port > 0 {
            writeln!(f, "port {port}")?;
        }

        if !domain.is_empty() {
            writeln!(f, "domain {domain}")?;
        }

        for nameserver in nameservers {
            writeln!(f, "nameserver {nameserver}")?;
        }

        if !search.is_empty() {
            writeln!(f, "search {}", search.join(" "))?;
        }

        if !options.is_empty() {
            writeln!(f, "options {}", options.join(" "))?;
        }

        Ok(())
    }
}

pub struct ResolveFileGuard {
    path: PathBuf,
}

impl Drop for ResolveFileGuard {
    fn drop(&mut self) {
        let ResolveFileGuard { path } = self;

        if let Err(error) = fs::remove_file(&path) {
            tracing::warn!(path = %path.display(), %error, "unable to remove ResolveFileGuard")
        };
    }
}

pub fn create_subnet_route<'a>(
    subnet: &'a IpNet,
    gateway: &'a IpAddr,
) -> io::Result<RouteCommandGuard<'a>> {
    let output = Command::new("route")
        .args([
            "-n",
            "add",
            "-net",
            &subnet.to_string(),
            &gateway.to_string(),
        ])
        .output()?;

    tracing::debug!(?output, "route mounted");

    Ok(RouteCommandGuard { subnet, gateway })
}

pub struct RouteCommandGuard<'a> {
    subnet: &'a IpNet,
    gateway: &'a IpAddr,
}

impl Drop for RouteCommandGuard<'_> {
    fn drop(&mut self) {
        let result = Command::new("route")
            .args([
                "-n",
                "delete",
                "-net",
                &self.subnet.to_string(),
                &self.gateway.to_string(),
            ])
            .output();

        match result {
            Ok(output) => tracing::debug!(?output, "route unmounted"),
            Err(error) => tracing::error!(?error, "unable to unmount"),
        }
    }
}

pub fn mount_macos<'a>(
    vpn_config: &'a VpnConfig,
    network: &'a NetworkConfiguration,
) -> Result<(RouteCommandGuard<'a>, ResolveFileGuard), VpnError> {
    let subnet_guard = create_subnet_route(&vpn_config.service_subnet, &network.gateway)
        .map_err(VpnError::SetupIO)?;

    let resolve_guard = ResolveFile {
        port: 53,
        domain: vpn_config.dns_domain.clone(),
        nameservers: vpn_config.dns_nameservers.clone(),
        ..Default::default()
    }
    .inject()
    .map_err(VpnError::SetupIO)?;

    Ok((subnet_guard, resolve_guard))
}
