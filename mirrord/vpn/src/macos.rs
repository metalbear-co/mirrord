use std::{fmt, path::PathBuf, sync::LazyLock};

use tokio::{fs, io};

static BASE_RESOLVE_PATH: LazyLock<PathBuf> = LazyLock::new(|| PathBuf::from("/etc/resolver"));

#[derive(Debug, Default)]
pub struct ResolveFile {
    pub port: u16,
    pub domain: String,
    pub nameservers: Vec<String>,
    pub search: Vec<String>,
    pub options: Vec<String>,
}

impl ResolveFile {
    pub async fn inject(&self) -> io::Result<ResolveFileGuard> {
        if !BASE_RESOLVE_PATH.exists() {
            fs::create_dir_all(&*BASE_RESOLVE_PATH).await?;
        }

        let path = BASE_RESOLVE_PATH.join(&self.domain);
        fs::write(&path, self.to_string()).await?;

        Ok(ResolveFileGuard { path })
    }
}

impl fmt::Display for ResolveFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let ResolveFile {
            port,
            domain,
            nameservers,
            search,
            options,
        } = self;

        writeln!(f, "# Generated by mirrord")?;

        if *port > 0 {
            writeln!(f, "port {port}")?;
        }

        if !domain.is_empty() {
            writeln!(f, "domain {domain}")?;
        }

        for nameserver in nameservers {
            writeln!(f, "nameserver {nameserver}")?;
        }

        if !search.is_empty() {
            writeln!(f, "search {}", search.join(" "))?;
        }

        if !options.is_empty() {
            writeln!(f, "options {}", options.join(" "))?;
        }

        Ok(())
    }
}

pub struct ResolveFileGuard {
    path: PathBuf,
}

impl ResolveFileGuard {
    pub async fn cleanup(&self) -> io::Result<()> {
        let ResolveFileGuard { path } = self;
        tokio::fs::remove_file(path).await?;

        Ok(())
    }
}

impl Drop for ResolveFileGuard {
    fn drop(&mut self) {
        let ResolveFileGuard { path } = self;

        if path.exists() {
            panic!(
                "ResolveFileGuard was dropped while path '{}' still exists",
                path.display()
            );
        }
    }
}
