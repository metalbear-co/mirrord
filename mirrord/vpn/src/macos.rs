use std::{fmt, net::IpAddr, path::PathBuf, sync::LazyLock};

use ipnet::IpNet;
use mirrord_protocol::vpn::NetworkConfiguration;
use tokio::{fs, io, process::Command};

use crate::{config::VpnConfig, error::VpnError};

static BASE_RESOLVE_PATH: LazyLock<PathBuf> = LazyLock::new(|| PathBuf::from("/etc/resolver"));

#[derive(Debug, Default)]
pub struct ResolveFile {
    port: u16,
    domain: String,
    nameservers: Vec<String>,
    search: Vec<String>,
    options: Vec<String>,
}

impl ResolveFile {
    pub async fn inject(&self) -> io::Result<ResolveFileGuard> {
        if !BASE_RESOLVE_PATH.exists() {
            fs::create_dir_all(&*BASE_RESOLVE_PATH).await?;
        }

        let path = BASE_RESOLVE_PATH.join(&self.domain);
        fs::write(&path, self.to_string()).await?;

        Ok(ResolveFileGuard { path })
    }
}

impl fmt::Display for ResolveFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let ResolveFile {
            port,
            domain,
            nameservers,
            search,
            options,
        } = self;

        writeln!(f, "# Generated by mirrord")?;

        if *port > 0 {
            writeln!(f, "port {port}")?;
        }

        if !domain.is_empty() {
            writeln!(f, "domain {domain}")?;
        }

        for nameserver in nameservers {
            writeln!(f, "nameserver {nameserver}")?;
        }

        if !search.is_empty() {
            writeln!(f, "search {}", search.join(" "))?;
        }

        if !options.is_empty() {
            writeln!(f, "options {}", options.join(" "))?;
        }

        Ok(())
    }
}

pub struct ResolveFileGuard {
    path: PathBuf,
}

impl ResolveFileGuard {
    pub async fn unmount(&self) -> io::Result<()> {
        let ResolveFileGuard { path } = self;
        tokio::fs::remove_file(path).await?;

        Ok(())
    }
}

impl Drop for ResolveFileGuard {
    fn drop(&mut self) {
        let ResolveFileGuard { path } = self;

        if path.exists() {
            panic!(
                "ResolveFileGuard was dropped while path '{}' still exists",
                path.display()
            );
        }
    }
}

pub async fn create_subnet_route<'a>(
    subnet: &'a IpNet,
    gateway: &'a IpAddr,
) -> io::Result<RouteCommandGuard<'a>> {
    let output = Command::new("route")
        .args([
            "-n",
            "add",
            "-net",
            &subnet.to_string(),
            &gateway.to_string(),
        ])
        .output()
        .await?;

    tracing::debug!(?output, "route mounted");

    Ok(RouteCommandGuard { subnet, gateway })
}

pub struct RouteCommandGuard<'a> {
    subnet: &'a IpNet,
    gateway: &'a IpAddr,
}

impl RouteCommandGuard<'_> {
    pub async fn unmount(&self) -> io::Result<()> {
        let output = Command::new("route")
            .args([
                "-n",
                "delete",
                "-net",
                &self.subnet.to_string(),
                &self.gateway.to_string(),
            ])
            .output()
            .await?;

        tracing::debug!(?output, "route unmounted");

        Ok(())
    }
}

pub async fn mount_macos<'a>(
    vpn_config: &'a VpnConfig,
    network: &'a NetworkConfiguration,
) -> Result<(RouteCommandGuard<'a>, ResolveFileGuard), VpnError> {
    let subnet_guard = create_subnet_route(&vpn_config.service_subnet, &network.gateway)
        .await
        .map_err(VpnError::SetupIO)?;

    let resolve_guard = ResolveFile {
        port: 53,
        domain: vpn_config.dns_domain.clone(),
        nameservers: vpn_config.dns_nameservers.clone(),
        ..Default::default()
    }
    .inject()
    .await
    .map_err(VpnError::SetupIO)?;

    Ok((subnet_guard, resolve_guard))
}
