#![feature(assert_matches)]
#![warn(clippy::indexing_slicing)]

use std::{collections::HashMap, path::PathBuf, time::Duration};

use rstest::rstest;

mod common;

pub use common::*;
use futures::SinkExt;
use mirrord_protocol::{
    tcp::{DaemonTcp, LayerTcpSteal, StealType},
    ClientMessage, DaemonMessage, FileRequest,
};
use tokio::{
    select,
    sync::{mpsc, oneshot, watch},
    time::sleep,
};
use tokio_stream::StreamExt;

/// Start an HTTP server injected with the layer, simulate the agent, verify expected messages from
/// the layer, send HTTP requests and verify in the server output that the application received
/// them. Tests the layer's communication with the agent, the bind hook, and the forwarding of
/// mirrored traffic to the application.
#[rstest]
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
#[timeout(Duration::from_secs(60))]
async fn mirroring_with_http(
    #[values(
        Application::PythonFlaskHTTP,
        Application::PythonFastApiHTTP,
        Application::NodeHTTP
    )]
    application: Application,
    dylib_path: &PathBuf,
    config_dir: &PathBuf,
) {
    let (mut test_process, mut layer_connection) = application
        .start_process_with_layer_and_port(
            dylib_path,
            vec![
                ("MIRRORD_FILE_MODE", "local"),
                ("MIRRORD_UDP_OUTGOING", "false"),
            ],
            Some(config_dir.join("port_mapping.json").to_str().unwrap()),
        )
        .await;

    println!("Application subscribed to port, sending HTTP requests.");

    layer_connection
        .send_connection_then_data::<false>(
            "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n",
            application.get_app_port(),
        )
        .await;
    layer_connection
        .send_connection_then_data::<false>(
            "POST / HTTP/1.1\r\nHost: localhost\r\n\r\npost-data",
            application.get_app_port(),
        )
        .await;
    layer_connection
        .send_connection_then_data::<false>(
            "PUT / HTTP/1.1\r\nHost: localhost\r\n\r\nput-data",
            application.get_app_port(),
        )
        .await;
    layer_connection
        .send_connection_then_data::<false>(
            "DELETE / HTTP/1.1\r\nHost: localhost\r\n\r\ndelete-data",
            application.get_app_port(),
        )
        .await;

    test_process.wait().await;
    test_process.assert_stdout_contains("GET: Request completed");
    test_process.assert_stdout_contains("POST: Request completed");
    test_process.assert_stdout_contains("PUT: Request completed");
    test_process.assert_stdout_contains("DELETE: Request completed");
    test_process.assert_no_error_in_stdout();
    test_process.assert_no_error_in_stderr();
}

/// Run the http mirroring test only on MacOS, because of a known crash on Linux.
#[cfg(target_os = "macos")]
#[rstest]
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
#[timeout(Duration::from_secs(60))]
async fn mirroring_with_http_go(
    dylib_path: &PathBuf,
    config_dir: &PathBuf,
    #[values(Application::Go19HTTP, Application::Go20HTTP)] application: Application,
) {
    mirroring_with_http(application, dylib_path, config_dir).await;
}

/// Notify on `app_ready_sender` when app is ready for HTTP.
/// Kill the process when told to over `test_done_receiver`.
/// Then notify to stop waiting for new layer connections.
async fn control_test_process(
    test_process: TestProcess,
    app_ready_sender: watch::Sender<bool>,
    mut test_done_receiver: mpsc::Receiver<()>,
    stop_accepting_layer_connections_sender: oneshot::Sender<()>,
) {
    // Wait for app to compile and listen.
    while !test_process.get_stdout().contains("On Your Network") {
        sleep(Duration::from_secs(1)).await;
    }
    app_ready_sender.send(true).unwrap();

    test_done_receiver.recv().await;
    test_process.child.unwrap().start_kill().unwrap();
    stop_accepting_layer_connections_sender.send(()).unwrap();
}

/// React apps from `create-react-app` listen on their port (3000 by default) a couple of times on
/// various IP addresses to make sure it is free before starting to listen for HTTP requests.
/// We had a bug where if an app listens on a port, then closes the socket, then listens again,
/// we would not update the local port (the port we make the user app listen on locally and then
/// connect to from the layer).
///
/// This test runs the app generated by `create-react-app` (with the layer injected to it), sends
/// daemon messages about stolen tcp, and verifies the app returns data back.
///
/// Before the bugfix, mirrord would crash on incoming requests, because it would try to create a
/// TCP stream with the local app, but would get a connection refused, because it would try to
/// connect to a port from a previous socket that was already closed.
///
/// FYI: when a browser is present, this test will open a browser, because `npm start` does that.
#[rstest]
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
#[timeout(Duration::from_secs(120))]
async fn listen_on_same_port_again(dylib_path: &PathBuf) {
    let application = Application::Relisten;
    let (test_process, listener) = application
        .get_test_process_and_listener(
            dylib_path,
            vec![
                // Disable fs and outgoing because they are not being tested here.
                ("MIRRORD_FILE_MODE", "local"),
                ("MIRRORD_UDP_OUTGOING", "false"),
                // Steal mode, so that we get an answer response data back from the layer.
                ("MIRRORD_AGENT_TCP_STEAL_TRAFFIC", "true"),
                // For some reason the app fails to resolve "localhost" when we don't resolve dns
                // remotely. Maybe this is a mirrord issue.
                ("MIRRORD_REMOTE_DNS", "true"),
                // prevent npm from opening a browser window.
                ("BROWSER", "none"),
            ],
            None,
        )
        .await;
    let app_port = application.get_app_port();

    // The React app does a lot of preparations before it compiles the final app and starts
    // listening as a server, so we want to wait for it to be ready and only then send stolen
    // TCP. Receivers of this channels are moved into all connection handling tasks, and if they
    // get a `PortSubscribe`, they wait for this channel to become true before sending Stolen TCP.
    let (app_ready_sender, app_ready_receiver) = watch::channel(false);

    // For layer connection handling tasks to notify the process controller that we verified what
    // we wanted to, so now please kill the
    let (test_done_sender, test_done_receiver) = mpsc::channel(1);

    // For breaking the LayerConnection accepting loop when we've got all we need.
    let (stop_accepting_layer_connections_sender, mut stop_accepting_layer_connections_receiver) =
        oneshot::channel::<()>();

    // Monitor the test_process's stdout and notify the connection handling tasks when it's ready
    // to accept HTTP requests.
    // Kill the process when app_ready_sender
    tokio::spawn(control_test_process(
        test_process,
        app_ready_sender,
        test_done_receiver,
        stop_accepting_layer_connections_sender,
    ));

    // Accept connections from layers, spawn tasks to handle those connections.
    loop {
        let mut layer_connection = select! {

            layer_connection = LayerConnection::get_initialized_connection(&listener) => layer_connection,

            // We already killed the application, no new connections are coming, and we also don't
            // care anymore.
            _ = &mut stop_accepting_layer_connections_receiver => {
                break;
            }
        };
        eprintln!("Got another layer connection!");

        let mut app_ready_receiver = app_ready_receiver.clone();
        let test_done_sender = test_done_sender.clone();
        tokio::spawn(async move {
            let next_message = layer_connection.codec.next().await;
            eprintln!("layer message: {next_message:?}");

            if let Some(result) = next_message {
                match result.unwrap() {
                    // Handle gethostname so that execution continues normally.
                    ClientMessage::FileRequest(FileRequest::Open(
                        mirrord_protocol::file::OpenFileRequest { path, .. },
                    )) if path.to_str().unwrap() == "/etc/hostname" => {
                        eprintln!("Got hostname req. Handling.");
                        layer_connection.handle_gethostname::<false>(None).await;
                        layer_connection
                            .print_all_subsequent_messages("After hostname: ")
                            .await;
                    }

                    // This is the part where we actually verify that sending tcp does not crash
                    // mirrord.
                    ClientMessage::TcpSteal(LayerTcpSteal::PortSubscribe(StealType::All(port)))
                        if port == app_port =>
                    {
                        eprintln!("Got port subscribe to {port}");
                        layer_connection
                            .codec
                            .send(DaemonMessage::TcpSteal(DaemonTcp::SubscribeResult(Ok(
                                port,
                            ))))
                            .await
                            .unwrap();

                        layer_connection
                            .expect_get_addr(HashMap::from([("localhost", "127.0.0.1")]))
                            .await;

                        eprintln!("Waiting for react app to compile and be ready.");
                        app_ready_receiver.wait_for(|ready| *ready).await.unwrap();
                        eprintln!("React app ready! sending TcpSteal messages.");

                        layer_connection
                            .send_connection_then_data::<true>(
                                "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n",
                                port,
                            )
                            .await;

                        eprintln!("Sent stolen tcp and got responses, notifying killer task.");

                        // Sent connection and data, got data back, everything's fine, let's wrap it
                        // up and go home.
                        test_done_sender.send(()).await.unwrap();

                        layer_connection
                            .print_all_subsequent_messages("After TCP: ")
                            .await;
                    }
                    other_message => {
                        eprintln!("not answering this message: {other_message:?}");
                        layer_connection
                            .print_all_subsequent_messages("After other message: ")
                            .await;
                    }
                }
            }
        });
    }
}
