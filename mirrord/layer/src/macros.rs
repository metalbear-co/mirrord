//! Macros used by mirrord-layer (mostly for hooking [`libc`] functions).
//!
//! ## Macros
//!
//! - [`replace!`]
//!
//! Replaces a [`libc`] function with a hook.
//!
//! - [`hook_symbol!`]
//!
//! Used to hook go symbols.
//!
//! - [`graceful_exit!`]
//!
//! Exits the process with a nice message.

/// Replaces the `$func` [`libc`] function, with the equivalent hook `$detour_function`, by calling
/// `HookManager::hook_export_or_any`.
///
/// ## Parameters
///
/// - `$hook_manager`: a valid [`HookManager`](crate::hooks::HookManager) instance that is used to
///   replace the [`libc`] function;
///
/// - `$func`: the function we want to replace;
///
/// - `$detour_function`: one of our detour functions;
///
/// - `$detour_type`: the type alias that was generated by `hook_fn` for this function type;
///
/// - `$hook_fn`: stores the original function pointer as a [`HookFn`](crate::detour::HookFn) that
///   is created by `hook_fn`.
///
/// ## Examples
///
/// - Replacing [`libc::close`] with [`close_detour`](crate::close_detour):
///
/// ```rust, no_run
/// unsafe {
///     replace!(&mut hook_manager, "close", close_detour, FnClose, FN_CLOSE);
/// }
/// ```
#[macro_export]
macro_rules! replace {
    ($hook_manager:expr, $func:expr, $detour_function:expr, $detour_type:ty, $hook_fn:expr) => {{
        let intercept = |hook_manager: &mut $crate::hooks::HookManager,
                         symbol_name,
                         detour: $detour_type|
         -> $crate::error::Result<$detour_type> {
            let replaced =
                hook_manager.hook_export_or_any(symbol_name, detour as *mut libc::c_void)?;
            let original_fn: $detour_type = std::mem::transmute(replaced);

            tracing::trace!("hooked {symbol_name:?}");
            Ok(original_fn)
        };

        let _ = intercept($hook_manager, $func, $detour_function)
            .and_then(|hooked| Ok($hook_fn.set(hooked).unwrap()));
    }};
}

/// Replaces the `$func` [`libc`] function, with the equivalent hook `$detour_function`, by calling
/// `HookManager::hook_export_or_any`. This variant accepts a fallback function to put in the
/// original function if the hook fails. This is useful in Go when we actually don't hook any libc
/// but still need to call it.
///
/// ## Parameters
///
/// - `$hook_manager`: a valid [`HookManager`](crate::hooks::HookManager) instance that is used to
///   replace the [`libc`] function;
///
/// - `$func`: the function we want to replace;
///
/// - `$detour_function`: one of our detour functions;
///
/// - `$detour_type`: the type alias that was generated by `hook_fn` for this function type;
///
/// - `$hook_fn`: stores the original function pointer as a [`HookFn`](crate::detour::HookFn) that
///   is created by `hook_fn`.
/// - `$fallback_fn`: stores the libc function to fallback to if the hook fails.
///
/// ## Examples
///
/// - Replacing [`libc::close`] with [`close_detour`](crate::close_detour):
///
/// ```rust, no_run
/// unsafe {
///     replace_with_fallback!(
///         hook_manager,
///         "close",
///         close_detour,
///         FnClose,
///         FN_CLOSE,
///         libc::close
///     );
/// }
/// ```
#[macro_export]
macro_rules! replace_with_fallback {
    ($hook_manager:expr, $func:expr, $detour_function:expr, $detour_type:ty, $hook_fn:expr, $fallback_fn:expr) => {{
        let intercept = |hook_manager: &mut $crate::hooks::HookManager,
                         symbol_name,
                         detour: $detour_type|
         -> $crate::error::Result<$detour_type> {
            let replaced =
                hook_manager.hook_export_or_any(symbol_name, detour as *mut libc::c_void)?;
            let original_fn: $detour_type = std::mem::transmute(replaced);

            tracing::trace!("hooked {symbol_name:?}");
            Ok(original_fn)
        };

        let _ = intercept($hook_manager, $func, $detour_function)
            .and_then(|hooked| Ok($hook_fn.set(hooked).unwrap()))
            .unwrap_or_else(|_| {
                $hook_fn.set($fallback_fn).unwrap();
            });
    }};
}

/// Used by [`go_hooks`](crate::go_hooks) to hook go syscalls with
/// `HookManager::hook_symbol_main_module`.
///
/// ## Parameters
///
/// - `$hook_manager`: a valid [`HookManager`](crate::hooks::HookManager) instance that is used to
///   hook the symbol `$func`;
///
/// - `$func`: the function we want to replace;
///
/// - `$detour_name`: detour we're replacing `$func` with.
///
/// ## Examples
///
/// - Hooking go's `syscall.RawSyscall.abi0`:
///
/// ```rust, no_run
/// hook_symbol!(
///     hook_manager,
///     "syscall.RawSyscall.abi0",
///     go_rawsyscall_detour
/// );
/// ```
#[cfg(all(
    target_os = "linux",
    any(target_arch = "x86_64", target_arch = "aarch64")
))]
macro_rules! hook_symbol {
    ($hook_manager:expr, $func:expr, $detour_name:expr) => {
        match $hook_manager.hook_symbol_main_module($func, $detour_name as *mut libc::c_void) {
            Ok(_) => {
                trace!("hooked {:?} in main module", $func);
            }
            Err(err) => {
                trace!("hook {:?} in main module failed with err {err:?}", $func);
            }
        }
    };
}

/// Kills the process and prints a helpful error message to the user.
///
/// ## Parameters
///
/// - `$arg`: messages to print, supports [`println!`] style arguments.
///
/// ## Examples
///
/// - Exiting on IO failure:
///
/// ```rust, no_run
/// if let Err(fail) = File::open("nothing.txt") {
///     graceful_exit!("mirrord failed to open file with {:#?}", fail);
/// }
/// ```
#[macro_export]
macro_rules! graceful_exit {
    ($($arg:tt)+) => {{
        eprintln!($($arg)+);
        graceful_exit!()
    }};
    () => {{
        nix::sys::signal::kill(
            nix::unistd::Pid::from_raw(std::process::id() as i32),
            nix::sys::signal::Signal::SIGKILL,
        )
        .expect("unable to graceful exit")
    }};
}

#[cfg(all(
    target_os = "linux",
    any(target_arch = "x86_64", target_arch = "aarch64")
))]
pub(crate) use hook_symbol;
