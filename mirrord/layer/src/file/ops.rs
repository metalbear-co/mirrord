// TODO(alex) [high] 2023-03-10: Tasks
// - fclose [p] (partial, missing `fflush`);
// - fdopen [x] (missing remote file constraint check);
// - fileno [x];
// - clearerr [x] (not hooked);
// - feof [x] (not hooked);
// - ferror [x] (use error from remote_file);
// - fread [x] (add error / eof to remote_file);
// - fgets [x] (add error / eof to remote_file);
// - fseek [] (not hooked);
use std::{ffi::CString, io::SeekFrom, num::NonZeroI64, os::unix::io::RawFd, path::PathBuf};

use libc::{c_int, c_uint, AT_FDCWD, FILE, O_CREAT, O_RDONLY, S_IRUSR, S_IWUSR, S_IXUSR};
use mirrord_protocol::file::{
    OpenFileResponse, OpenOptionsInternal, ReadFileResponse, SeekFileResponse, WriteFileResponse,
    XstatResponse,
};
use tokio::sync::oneshot;
use tracing::{error, trace};

use super::{filter::FILE_FILTER, *};
use crate::{
    common::blocking_send_hook_message,
    detour::{Bypass, Detour},
    error::{HookError, HookResult as Result},
    HookMessage,
};

/// 1 Megabyte. Large read requests can lead to timeouts.
const MAX_READ_SIZE: u64 = 1024 * 1024;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub(crate) struct RemoteFile {
    pub(crate) fd: u64,
    pub(crate) error: Option<NonZeroI64>,
    pub(crate) is_eof: bool,
    pub(crate) open_options: OpenOptionsInternal,
}

impl RemoteFile {
    pub(crate) fn new(fd: u64, open_options: OpenOptionsInternal) -> Self {
        Self {
            fd,
            open_options,
            error: Default::default(),
            is_eof: Default::default(),
        }
    }
}

impl Drop for RemoteFile {
    fn drop(&mut self) {
        // Warning: Don't log from here. This is called when self is removed from OPEN_FILES, so
        // during the whole execution of this function, OPEN_FILES is locked.
        // When emitting logs, sometimes a file `write` operation is required, in order for the
        // operation to complete. The write operation is hooked and at some point tries to lock
        // `OPEN_FILES`, which means the thread deadlocks with itself (we call
        // `OPEN_FILES.lock()?.remove()` and then while still locked, `OPEN_FILES.lock()` again)
        let closing_file = Close { fd: self.fd };

        blocking_send_file_message(FileOperation::Close(closing_file)).expect(
            "mirrord failed to send close file message to main layer thread. Error: {err:?}",
        );
    }
}

/// should_ignore(path: P, write: bool)
/// Checks if the file should be ignored, and returns a [`Bypass::IgnoredFile`] if it should.
macro_rules! should_ignore {
    ($path:expr, $write:expr) => {
        FILE_FILTER.get()?.continue_or_bypass_with(
            $path.to_str().unwrap_or_default(),
            $write,
            || Bypass::IgnoredFile($path.clone()),
        )?;
    };
}

/// Helper function that retrieves the `remote_fd` (which is generated by
/// `mirrord_agent::util::IndexAllocator`).
fn get_remote_fd(local_fd: RawFd) -> Detour<u64> {
    Detour::Success(
        OPEN_FILES
            .lock()?
            .get(&local_fd)
            // Bypass if we're not managing the relative part.
            .ok_or(Bypass::LocalFdNotFound(local_fd))
            .map(|remote_file| remote_file.read())??
            .fd,
    )
}

/// The pair [`libc::shm_open`], [`libc::shm_unlink`] are used to create a temporary file (in
/// `/dev/shm/`), and then remove it, as we only care about the `fd`. This is done to preserve
/// `open_flags`, as [`libc::memfd_create`] will always return a `File` with read and write
/// permissions (which is undesirable).
#[tracing::instrument(level = "trace")]
unsafe fn create_local_fake_file(fake_local_file_name: CString, remote_fd: u64) -> Detour<RawFd> {
    let local_file_fd = unsafe {
        // `mode` is access rights: user, root, ...
        let local_file_fd = libc::shm_open(
            fake_local_file_name.as_ptr(),
            O_RDONLY | O_CREAT,
            (S_IRUSR | S_IWUSR | S_IXUSR) as c_uint,
        );

        libc::shm_unlink(fake_local_file_name.as_ptr());

        local_file_fd
    };

    // Close the remote file if the call to `libc::shm_open` failed and we have an invalid local fd.
    if local_file_fd == -1 {
        close_remote_file_on_failure(remote_fd)?;
        Detour::Error(HookError::LocalFileCreation(remote_fd))
    } else {
        Detour::Success(local_file_fd)
    }
}

/// Close the remote file if the call to [`libc::shm_open`] failed and we have an invalid local fd.
#[tracing::instrument(level = "error")]
fn close_remote_file_on_failure(fd: u64) -> Result<()> {
    error!("Call to `libc::shm_open` resulted in an error, closing the file remotely!");

    blocking_send_file_message(FileOperation::Close(Close { fd }))?;
    Ok(())
}

fn blocking_send_file_message(message: FileOperation) -> Result<()> {
    blocking_send_hook_message(HookMessage::File(message))
}

/// Blocking wrapper around `libc::open` call.
///
/// **Bypassed** when trying to load system files, and files from the current working directory
/// (which is different anyways when running in `-agent` context).
///
/// When called for a valid file, it blocks and sends an open file request to be handled by
/// `mirrord-agent`, and waits until it receives an open file response.
///
/// [`open`] is also used by other _open-ish_ functions, and it takes care of **creating** the
/// _local_ and _remote_ file association, plus **inserting** it into the storage for
/// [`OPEN_FILES`].
#[tracing::instrument(level = "trace")]
pub(crate) fn open(path: Detour<PathBuf>, open_options: OpenOptionsInternal) -> Detour<RawFd> {
    let path = path?;

    if path.is_relative() {
        // Calls with non absolute paths are sent to libc::open.
        Detour::Bypass(Bypass::RelativePath(path.clone()))?
    };

    should_ignore!(path, open_options.is_write());

    let (file_channel_tx, file_channel_rx) = oneshot::channel();

    let requesting_file = Open {
        path,
        open_options,
        file_channel_tx,
    };

    blocking_send_file_message(FileOperation::Open(requesting_file))?;

    let OpenFileResponse { fd: remote_fd } = file_channel_rx.blocking_recv()??;

    // TODO: Need a way to say "open a directory", right now `is_dir` always returns false.
    // This requires having a fake directory name (`/fake`, for example), instead of just converting
    // the fd to a string.
    let fake_local_file_name = CString::new(remote_fd.to_string())?;
    let local_file_fd = unsafe { create_local_fake_file(fake_local_file_name, remote_fd) }?;

    OPEN_FILES.lock().unwrap().insert(
        local_file_fd,
        Arc::new(RwLock::new(RemoteFile::new(remote_fd, open_options))),
    );

    Detour::Success(local_file_fd)
}

/// Calls [`open`] and returns a [`FILE`] pointer based on the **local** `fd`.
#[tracing::instrument(level = "trace")]
pub(crate) fn fopen(path: Detour<PathBuf>, mode: Detour<OpenOptionsInternal>) -> Detour<*mut FILE> {
    let open_options = mode?;

    let local_file_fd = open(path, open_options)?;
    let result = OPEN_FILES
        .lock()?
        .get_key_value(&local_file_fd)
        .ok_or(Bypass::LocalFdNotFound(local_file_fd))
        // Convert the fd into a `*FILE`, this is be ok as long as `OPEN_FILES` holds the fd.
        .map(|(local_fd, _)| local_fd as *const _ as *mut _)?;

    Detour::Success(result)
}

/// Opens a file with `fd` that is being held in [`OPEN_FILES`], returning a _non-null_ file stream
/// (which is just a pointer to the `local_fd` we're holding).
///
/// The `mode` has to be compatible with the [`OpenOptionsInternal`] of the file with `fd`.
#[tracing::instrument(level = "trace")]
pub(crate) fn fdopen(fd: RawFd, mode: Detour<OpenOptionsInternal>) -> Detour<*mut FILE> {
    let open_options = mode?;

    trace!("fdopen -> open_options {open_options:#?}");

    let open_files = OPEN_FILES.lock()?;
    let (local_fd, remote_file) = open_files
        .get_key_value(&fd)
        .ok_or(Bypass::LocalFdNotFound(fd))?;

    // Only open if the file we hold has compatible permissions with what's being requested.
    if remote_file.read()?.open_options <= open_options {
        Detour::Success(local_fd as *const _ as *mut _)
    } else {
        Detour::Error(HookError::OpenOptionsDoesntMatch)
    }
}

/// creates a directory stream for the `remote_fd` in the agent
#[tracing::instrument(level = "trace")]
pub(crate) fn fdopendir(fd: RawFd) -> Detour<usize> {
    // usize == ptr size
    // we don't return a pointer to an address that contains DIR

    let remote_file_fd = get_remote_fd(fd)?;

    let (dir_channel_tx, dir_channel_rx) = oneshot::channel();

    let open_dir_request = FdOpenDir {
        remote_fd: remote_file_fd,
        dir_channel_tx,
    };

    blocking_send_file_message(FileOperation::FdOpenDir(open_dir_request))?;

    let OpenDirResponse { fd: remote_dir_fd } = dir_channel_rx.blocking_recv()??;

    let fake_local_dir_name = CString::new(fd.to_string())?;
    let local_dir_fd = unsafe { create_local_fake_file(fake_local_dir_name, remote_dir_fd) }?;
    OPEN_DIRS
        .lock()?
        .insert(local_dir_fd as usize, remote_dir_fd);

    // According to docs, when using fdopendir, the fd is now managed by OS - i.e closed
    OPEN_FILES.lock()?.remove(&fd);

    Detour::Success(local_dir_fd as usize)
}

/// Returns the `local_fd` back if this fd is being managed by us.
///
/// ## Details
///
/// Due to the way we handle opening file streams (see [`fopen`]), it is safe-ish to convert the
/// `*mut FILE` to a simple `RawFd`, and check if it's still in our [`OPEN_FILES`].
///
/// ## Safety
///
/// The assumption may break if the file stream pointer conversion to [`RawFd`] ends up being equal
/// to some fd that is being managed by us, for example:
///
/// 1. The user calls [`libc::fopen`] for a locally handled path;
/// 2. The call succeeds, and returns a `*mut FILE` _A_, which can be dereferenced to a value of
///    `3`;
/// 3. We're holding a previously opened file with `fd == 3`;
/// 4. User calls [`libc::fileno`] with the acquired file stream _A_;
/// 5. We convert the file stream _A_ to `3`, breaking our invariant.
///
/// We're assuming that most pointers won't have such small values, and that the user won't reach a
/// big enough list of fds to get close to normal pointer address' values.
#[tracing::instrument(level = "trace")]
pub(crate) fn fileno(local_fd: RawFd) -> Detour<RawFd> {
    Detour::Success(
        OPEN_FILES
            .lock()?
            .contains_key(&local_fd)
            .then_some(local_fd)?,
    )
}

#[tracing::instrument(level = "trace")]
pub(crate) fn ferror(local_fd: RawFd) -> Detour<i32> {
    let open_files = OPEN_FILES.lock()?;
    let remote_file = open_files.get(&local_fd)?.read()?;

    Detour::Success(remote_file.error.map(NonZeroI64::get).unwrap_or_default() as i32)
}

/// Returns `1` if `is_eof` is set, and `0` if it's not.
#[tracing::instrument(level = "trace")]
pub(crate) fn feof(local_fd: RawFd) -> Detour<i32> {
    let open_files = OPEN_FILES.lock()?;
    let remote_file = open_files.get(&local_fd)?.read()?;

    Detour::Success(remote_file.is_eof.into())
}

/// Clears the `is_eof` and `error` values from this [`RemoteFile`]
#[tracing::instrument(level = "trace")]
pub(crate) fn clearerr(local_fd: RawFd) -> Detour<()> {
    let open_files = OPEN_FILES.lock()?;
    let mut remote_file = open_files.get(&local_fd)?.write()?;

    remote_file.error = None;
    remote_file.is_eof = false;

    Detour::Success(())
}

#[tracing::instrument(level = "trace")]
pub(crate) fn fclose(local_fd: RawFd) -> Detour<i32> {
    Detour::Success(OPEN_FILES.lock()?.remove(&local_fd).map(|_| 0)?)
    // TODO(alex) [mid] 2023-03-07: Call `fflush` if this was being used as output (always safe to
    // call it? if so, then just always do it).
}

// fetches the current entry in the directory stream created by `fdopendir`
#[tracing::instrument(level = "trace")]
pub(crate) fn readdir_r(dir_stream: usize) -> Detour<Option<DirEntryInternal>> {
    let remote_fd = *OPEN_DIRS
        .lock()?
        .get(&dir_stream)
        .ok_or(Bypass::LocalDirStreamNotFound(dir_stream))?;

    let (dir_channel_tx, dir_channel_rx) = oneshot::channel();

    let requesting_dir = ReadDir {
        remote_fd,
        dir_channel_tx,
    };

    blocking_send_file_message(FileOperation::ReadDir(requesting_dir))?;

    let ReadDirResponse { direntry } = dir_channel_rx.blocking_recv()??;
    Detour::Success(direntry)
}

#[tracing::instrument(level = "trace")]
pub(crate) fn closedir(dir_stream: usize) -> Detour<c_int> {
    let remote_fd = *OPEN_DIRS
        .lock()?
        .get(&dir_stream)
        .ok_or(Bypass::LocalDirStreamNotFound(dir_stream))?;

    let requesting_dir = CloseDir { fd: remote_fd };

    blocking_send_file_message(FileOperation::CloseDir(requesting_dir))?;

    Detour::Success(0)
}

#[tracing::instrument(level = "trace")]
pub(crate) fn openat(
    fd: RawFd,
    path: Detour<PathBuf>,
    open_options: OpenOptionsInternal,
) -> Detour<RawFd> {
    let path = path?;

    // `openat` behaves the same as `open` when the path is absolute. When called with AT_FDCWD, the
    // call is propagated to `open`.
    if path.is_absolute() || fd == AT_FDCWD {
        open(Detour::Success(path), open_options)
    } else {
        // Relative path requires special handling, we must identify the relative part (relative to
        // what).
        let remote_fd = get_remote_fd(fd)?;

        let (file_channel_tx, file_channel_rx) = oneshot::channel();

        let requesting_file = OpenRelative {
            relative_fd: remote_fd,
            path,
            open_options,
            file_channel_tx,
        };

        blocking_send_file_message(FileOperation::OpenRelative(requesting_file))?;

        let OpenFileResponse { fd: remote_fd } = file_channel_rx.blocking_recv()??;
        let fake_local_file_name = CString::new(remote_fd.to_string())?;
        let local_file_fd = unsafe { create_local_fake_file(fake_local_file_name, remote_fd) }?;

        OPEN_FILES.lock()?.insert(
            local_file_fd,
            Arc::new(RwLock::new(RemoteFile::new(remote_fd, open_options))),
        );

        Detour::Success(local_file_fd)
    }
}

/// Blocking wrapper around [`libc::read`] call.
///
/// **Bypassed** when trying to load system files, and files from the current working directory, see
/// `open`.
pub(crate) fn read(local_fd: RawFd, read_amount: u64) -> Detour<ReadFileResponse> {
    get_remote_fd(local_fd).and_then(|remote_fd| remote_read(remote_fd, read_amount))
}

/// Blocking request and wait on already found remote_fd
#[tracing::instrument(level = "trace")]
fn remote_read(remote_fd: u64, read_amount: u64) -> Detour<ReadFileResponse> {
    let (file_channel_tx, file_channel_rx) = oneshot::channel();

    // Limit read size because if we read too much it can lead to a timeout
    // Seems also that bincode doesn't do well with large buffers
    let read_amount = std::cmp::min(read_amount, MAX_READ_SIZE);
    let reading_file = Read {
        remote_fd,
        buffer_size: read_amount,
        start_from: 0,
        file_channel_tx,
    };

    blocking_send_file_message(FileOperation::Read(reading_file))?;

    Detour::Success(file_channel_rx.blocking_recv()??)
}

#[tracing::instrument(level = "trace")]
pub(crate) fn fgets(local_fd: RawFd, buffer_size: usize) -> Detour<ReadFileResponse> {
    // We're only interested in files that are paired with mirrord-agent.
    let remote_fd = get_remote_fd(local_fd)?;

    let (file_channel_tx, file_channel_rx) = oneshot::channel();

    let reading_file = Read {
        remote_fd,
        buffer_size: buffer_size as u64,
        start_from: 0,
        file_channel_tx,
    };

    blocking_send_file_message(FileOperation::ReadLine(reading_file))?;

    Detour::Success(file_channel_rx.blocking_recv()??)
}

#[tracing::instrument(level = "trace")]
pub(crate) fn pread(local_fd: RawFd, buffer_size: u64, offset: u64) -> Detour<ReadFileResponse> {
    // We're only interested in files that are paired with mirrord-agent.
    let remote_fd = get_remote_fd(local_fd)?;

    let (file_channel_tx, file_channel_rx) = oneshot::channel();

    let reading_file = Read {
        remote_fd,
        buffer_size: buffer_size as _,
        start_from: offset,
        file_channel_tx,
    };

    blocking_send_file_message(FileOperation::ReadLimited(reading_file))?;

    Detour::Success(file_channel_rx.blocking_recv()??)
}

pub(crate) fn pwrite(local_fd: RawFd, buffer: &[u8], offset: u64) -> Detour<WriteFileResponse> {
    let remote_fd = get_remote_fd(local_fd)?;

    let (file_channel_tx, file_channel_rx) = oneshot::channel();

    let writing_file = Write {
        remote_fd,
        write_bytes: buffer.to_vec(),
        start_from: offset,
        file_channel_tx,
    };

    blocking_send_file_message(FileOperation::WriteLimited(writing_file))?;

    Detour::Success(file_channel_rx.blocking_recv()??)
}

#[tracing::instrument(level = "trace")]
pub(crate) fn lseek(local_fd: RawFd, offset: i64, whence: i32) -> Detour<u64> {
    let remote_fd = get_remote_fd(local_fd)?;

    let seek_from = match whence {
        libc::SEEK_SET => SeekFrom::Start(offset as u64),
        libc::SEEK_CUR => SeekFrom::Current(offset),
        libc::SEEK_END => SeekFrom::End(offset),
        invalid => {
            warn!(
                "lseek -> potential invalid value {:#?} for whence {:#?}",
                invalid, whence
            );
            return Detour::Bypass(Bypass::CStrConversion);
        }
    };

    let (file_channel_tx, file_channel_rx) = oneshot::channel();

    let seeking_file = Seek {
        remote_fd,
        seek_from,
        file_channel_tx,
    };

    blocking_send_file_message(FileOperation::Seek(seeking_file))?;

    let SeekFileResponse { result_offset } = file_channel_rx.blocking_recv()??;
    Detour::Success(result_offset)
}

pub(crate) fn write(local_fd: RawFd, write_bytes: Option<Vec<u8>>) -> Detour<isize> {
    let remote_fd = get_remote_fd(local_fd)?;

    let (file_channel_tx, file_channel_rx) = oneshot::channel();

    let writing_file = Write {
        remote_fd,
        write_bytes: write_bytes.ok_or(Bypass::EmptyBuffer)?,
        start_from: 0,
        file_channel_tx,
    };

    blocking_send_file_message(FileOperation::Write(writing_file))?;

    let WriteFileResponse { written_amount } = file_channel_rx.blocking_recv()??;
    Detour::Success(written_amount.try_into()?)
}

#[tracing::instrument(level = "trace")]
pub(crate) fn access(path: Detour<PathBuf>, mode: u8) -> Detour<c_int> {
    let path = path?;

    should_ignore!(path, false);

    if path.is_relative() {
        // Calls with non absolute paths are sent to libc::open.
        Detour::Bypass(Bypass::RelativePath(path.clone()))?
    };

    let (file_channel_tx, file_channel_rx) = oneshot::channel();

    let access = Access {
        path,
        mode,
        file_channel_tx,
    };

    blocking_send_file_message(FileOperation::Access(access))?;

    file_channel_rx.blocking_recv()??;

    Detour::Success(0)
}

/// General stat function that can be used for lstat, fstat, stat and fstatat.
/// Note: We treat cases of `AT_SYMLINK_NOFOLLOW_ANY` as `AT_SYMLINK_NOFOLLOW` because even Go does
/// that.
/// rawish_path is Option<Option<&CStr>> because we need to differentiate between null pointer
/// and non existing argument (For error handling)
#[tracing::instrument(level = "trace")]
pub(crate) fn xstat(
    path: Option<Detour<PathBuf>>,
    fd: Option<RawFd>,
    follow_symlink: bool,
) -> Detour<XstatResponse> {
    // Can't use map because we need to propagate captured error
    let (path, fd) = match (path, fd) {
        // fstatat
        (Some(path), Some(fd)) => {
            let path = path?;
            let fd = {
                if fd == AT_FDCWD {
                    if path.is_relative() {
                        // Calls with non absolute paths are sent to libc::fstatat.
                        return Detour::Bypass(Bypass::RelativePath(path));
                    } else {
                        should_ignore!(path, false);
                        None
                    }
                } else {
                    Some(get_remote_fd(fd)?)
                }
            };
            (Some(path), fd)
        }
        // lstat/stat
        (Some(path), None) => {
            let path = path?;
            if path.is_relative() {
                // Calls with non absolute paths are sent to libc::open.
                return Detour::Bypass(Bypass::RelativePath(path));
            }
            should_ignore!(path, false);
            (Some(path), None)
        }
        // fstat
        (None, Some(fd)) => (None, Some(get_remote_fd(fd)?)),
        // can't happen
        (None, None) => return Detour::Error(HookError::NullPointer),
    };

    let (file_channel_tx, file_channel_rx) = oneshot::channel();

    let lstat = Xstat {
        fd,
        path,
        follow_symlink,
        file_channel_tx,
    };

    blocking_send_file_message(FileOperation::Xstat(lstat))?;

    Detour::Success(file_channel_rx.blocking_recv()??)
}

#[cfg(target_os = "linux")]
#[tracing::instrument(level = "trace")]
pub(crate) fn getdents64(fd: RawFd, buffer_size: u64) -> Detour<GetDEnts64Response> {
    // We're only interested in files that are paired with mirrord-agent.
    let remote_fd = get_remote_fd(fd)?;

    let (dents_tx, dents_rx) = oneshot::channel();

    let getdents64_message = GetDEnts64 {
        remote_fd,
        buffer_size,
        dents_tx,
    };

    blocking_send_file_message(FileOperation::GetDEnts64(getdents64_message))?;

    Detour::Success(dents_rx.blocking_recv()??)
}
