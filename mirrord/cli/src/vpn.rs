use std::net::IpAddr;

use hickory_proto::rr::{rdata, Name, RData, Record};
use mirrord_analytics::{AnalyticsError, NullReporter, Reporter};
use mirrord_config::LayerConfig;
use mirrord_progress::{Progress, ProgressTracker};
use mirrord_protocol::{
    dns::{DnsLookup, GetAddrInfoRequest, GetAddrInfoResponse},
    ClientMessage, DaemonMessage,
};
use tokio::net;

use crate::{
    config::VpnArgs,
    connection::{create_and_connect, AgentConnection},
    error::Result,
};

mod dns;

#[cfg(target_os = "macos")]
mod macos {
    use std::fmt;

    #[derive(Debug, Default)]
    pub struct ResolveFile {
        pub port: u16,
        pub domain: String,
        pub nameservers: Vec<String>,
        pub search: Vec<String>,
        pub options: Vec<String>,
    }

    impl ResolveFile {
        pub fn is_empty(&self) -> bool {
            !(self.port > 0
                || !self.domain.is_empty()
                || !self.nameservers.is_empty()
                || !self.search.is_empty()
                || !self.options.is_empty())
        }
    }

    impl fmt::Display for ResolveFile {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let ResolveFile {
                port,
                domain,
                nameservers,
                search,
                options,
            } = self;

            writeln!(f, "# Generated by mirrord")?;

            if *port > 0 {
                writeln!(f, "port {port}")?;
            }

            if !domain.is_empty() {
                writeln!(f, "domain {domain}")?;
            }

            for nameserver in nameservers {
                writeln!(f, "nameserver {nameserver}")?;
            }

            if !search.is_empty() {
                writeln!(f, "search {}", search.join(" "))?;
            }

            if !options.is_empty() {
                writeln!(f, "options {}", options.join(" "))?;
            }

            Ok(())
        }
    }
}

async fn agent_request<T>(
    connection: &mut AgentConnection,
    request: ClientMessage,
    mapper: impl Fn(DaemonMessage) -> Option<T>,
) -> Option<T> {
    connection.sender.send(request).await.ok()?;

    mapper(connection.receiver.recv().await?)
}

fn get_addr_info_response(message: DaemonMessage) -> Option<GetAddrInfoResponse> {
    match message {
        DaemonMessage::GetAddrInfoResponse(response) => Some(response),
        _ => None,
    }
}

pub async fn vpn_command(_args: VpnArgs) -> Result<()> {
    let mut progress = ProgressTracker::from_env("mirrord vpn");
    let mut sub_progress = progress.subtask("create agent");

    let mut analytics = NullReporter::default();

    let mut config = LayerConfig::from_env()?;
    config.agent.privileged = true;

    let (_, mut connection) = create_and_connect(&config, &mut sub_progress, &mut analytics)
        .await
        .inspect_err(|_| analytics.set_error(AnalyticsError::AgentConnection))?;

    sub_progress.success(None);
    progress.success(None);

    let Ok(socket) = net::UdpSocket::bind("0.0.0.0:52783").await else {
        return Ok(());
    };

    let dns_server = dns::DnsServer::new(socket);
    let port = dns_server.port().expect("Should be bound");

    // #[cfg(target_os = "macos")]
    // {
    //     let test = macos::ResolveFile {
    //         port,
    //         domain: "svc.cluster.local".to_string(),
    //         nameservers: vec!["127.0.0.1".to_string()],
    //         ..Default::default()
    //     };

    //     if let Err(err) =
    //         tokio::fs::write("/etc/resolver/svc.cluster.local", test.to_string()).await
    //     {
    //         panic!("{err}");
    //     }
    // }

    let mut dns_api = dns_server.start();

    println!("Listening on port {port}");

    while let Some(((mut message, addr), reply)) = dns_api.recv().await {
        let mut answers = Vec::new();

        'q: for query in message.queries() {
            if !query.query_type().is_ip_addr() {
                continue 'q;
            }

            let Some(GetAddrInfoResponse(response)) = agent_request(
                &mut connection,
                ClientMessage::GetAddrInfoRequest(GetAddrInfoRequest {
                    node: query.name().to_string(),
                }),
                get_addr_info_response,
            )
            .await
            else {
                continue 'q;
            };

            if let Ok(DnsLookup(records)) = &response {
                answers.extend(records.iter().map(|record| {
                    Record::from_rdata(
                        Name::from_utf8(&record.name).unwrap_or_default(),
                        300,
                        match record.ip {
                            IpAddr::V4(v4) => RData::A(rdata::A(v4)),
                            IpAddr::V6(v6) => RData::AAAA(rdata::AAAA(v6)),
                        },
                    )
                }));
            }
        }

        message.insert_answers(answers);

        let _ = reply.send((message, addr));
    }

    Ok(())
}
