use std::net::IpAddr;

use futures::{SinkExt, StreamExt};
use ipnet::IpNet;
use mirrord_analytics::{AnalyticsError, NullReporter, Reporter};
use mirrord_config::{agent::AgentImageConfig, LayerConfig};
use mirrord_progress::{Progress, ProgressTracker};
use mirrord_protocol::{
    vpn::{ClientVpn, ServerVpn},
    ClientMessage, DaemonMessage,
};
use tokio::{process::Command, signal};

use crate::{
    config::VpnArgs,
    connection::{create_and_connect, AgentConnection},
    error::Result,
};

#[cfg(target_os = "macos")]
mod macos {
    use std::fmt;

    #[derive(Debug, Default)]
    pub struct ResolveFile {
        pub port: u16,
        pub domain: String,
        pub nameservers: Vec<String>,
        pub search: Vec<String>,
        pub options: Vec<String>,
    }

    impl fmt::Display for ResolveFile {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let ResolveFile {
                port,
                domain,
                nameservers,
                search,
                options,
            } = self;

            writeln!(f, "# Generated by mirrord")?;

            if *port > 0 {
                writeln!(f, "port {port}")?;
            }

            if !domain.is_empty() {
                writeln!(f, "domain {domain}")?;
            }

            for nameserver in nameservers {
                writeln!(f, "nameserver {nameserver}")?;
            }

            if !search.is_empty() {
                writeln!(f, "search {}", search.join(" "))?;
            }

            if !options.is_empty() {
                writeln!(f, "options {}", options.join(" "))?;
            }

            Ok(())
        }
    }
}

async fn agent_request<T>(
    connection: &mut AgentConnection,
    request: ClientMessage,
    mapper: impl Fn(DaemonMessage) -> Option<T>,
) -> Option<T> {
    connection.sender.send(request).await.ok()?;

    mapper(connection.receiver.recv().await?)
}

fn get_server_vpn(message: DaemonMessage) -> Option<ServerVpn> {
    match message {
        DaemonMessage::Vpn(response) => Some(response),
        _ => None,
    }
}

pub async fn vpn_command(_args: VpnArgs) -> Result<()> {
    let mut progress = ProgressTracker::from_env("mirrord vpn");
    let mut sub_progress = progress.subtask("create agent");

    let mut analytics = NullReporter::default();

    let mut config = LayerConfig::from_env()?;
    config.agent.image = AgentImageConfig("test".into());
    config.agent.log_level = "warn,mirrord=trace".to_string();
    config.agent.privileged = true;
    config.agent.ttl = 30;

    let (_, mut connection) = create_and_connect(&config, &mut sub_progress, &mut analytics)
        .await
        .inspect_err(|_| analytics.set_error(AnalyticsError::AgentConnection))?;

    sub_progress.success(None);
    progress.success(None);

    let Some(ServerVpn::NetworkConfiguration(network)) = agent_request(
        &mut connection,
        ClientMessage::Vpn(ClientVpn::GetNetworkConfiguration),
        get_server_vpn,
    )
    .await
    else {
        return Ok(());
    };

    println!("{network:?}");

    let (IpAddr::V4(net_mask), IpAddr::V4(gateway)) = (network.net_mask, network.gateway) else {
        return Ok(());
    };

    let subnet = IpNet::with_netmask(IpAddr::V4(gateway & net_mask), IpAddr::V4(net_mask)).unwrap();

    let mut config = tun2::Configuration::default();
    config
        .address(network.ip)
        .netmask(network.net_mask)
        .destination(network.gateway)
        .up();

    #[cfg(target_os = "linux")]
    config.platform_config(|config| {
        config.packet_information(true);
        config.ensure_root_privileges(true);
    });

    let dev = tun2::create_as_async(&config).unwrap();
    let (mut write_stream, read_stream) = dev.into_framed().split();
    let read_stream = read_stream.fuse();

    tokio::pin!(read_stream);

    #[cfg(target_os = "macos")]
    {
        let output = Command::new("route")
            .args([
                "-n",
                "add",
                "-net",
                &subnet.to_string(),
                &gateway.to_string(),
            ])
            .output()
            .await;

        println!("{output:#?}");
    }

    // #[cfg(target_os = "macos")]
    // {
    //     let test = macos::ResolveFile {
    //         port,
    //         domain: "svc.cluster.local".to_string(),
    //         nameservers: vec!["127.0.0.1".to_string()],
    //         ..Default::default()
    //     };

    //     if let Err(err) =
    //         tokio::fs::write("/etc/resolver/svc.cluster.local", test.to_string()).await
    //     {
    //         panic!("{err}");
    //     }
    // }

    'main: loop {
        tokio::select! {
            packet = read_stream.next() => {
                let packet = packet.unwrap().unwrap();
                connection
                    .sender
                    .send(mirrord_protocol::ClientMessage::Vpn(ClientVpn::Packet(packet)))
                    .await
                    .unwrap();
            }
            message = connection.receiver.recv() => {
                if let Some(message) = message {
                    match message {
                        DaemonMessage::Vpn(ServerVpn::Packet(packet)) => {
                            if let Err(err) = write_stream.send(packet).await {
                                tracing::warn!(%err, "Unable to pipe back packet")
                            }
                        }
                        _ => unimplemented!("Unexpected response from agent"),
                    }
                }
            }
            _ = signal::ctrl_c() => {
                break 'main;
            }
        }
    }

    #[cfg(target_os = "macos")]
    {
        let output = Command::new("route")
            .args([
                "-n",
                "delete",
                "-net",
                &subnet.to_string(),
                &gateway.to_string(),
            ])
            .output()
            .await;

        println!("{output:#?}");
    }

    Ok(())
}
