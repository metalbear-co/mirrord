use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use crate::config::{
    ConfigContext, FromMirrordConfig, MirrordConfig, Result, from_env::FromEnv,
    source::MirrordConfigSource,
};

/// Environment variable name for the session key.
pub const MIRRORD_ENV_KEY: &str = "MIRRORD_ENV_KEY";

/// Session key for traffic filtering.
///
/// Distinguishes between user-provided keys (from CLI or config file)
/// and auto-generated keys (UUID v4).
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum EnvKey {
    /// Key provided by user via CLI argument or config file.
    Provided(String),
    /// Auto-generated UUID v4 when no key was provided.
    Generated(String),
}

impl EnvKey {
    /// Prefix used to mark auto-generated keys stored in [`ConfigContext`].
    ///
    /// When [`LayerFileConfig::from_path`] auto-generates a key (because neither CLI nor config
    /// file provided one), it must store the key in the context so that
    /// [`EnvKeyFileConfig::generate_config`] uses the *same* key. Without this, `generate_config`
    /// would generate a *different* key, causing a mismatch between the value used for template
    /// rendering (`{{ key }}`) and the final value in [`LayerConfig`].
    ///
    /// However, storing the auto-generated key in the context creates a problem: `generate_config`
    /// can't distinguish between a user-provided key and an auto-generated one - both just appear
    /// as values in `MIRRORD_ENV_KEY`. This marker solves that by prefixing auto-generated keys.
    /// When `generate_config` finds a key with this prefix, it strips the prefix and wraps the
    /// result in [`EnvKey::Generated`]; otherwise, it wraps it in [`EnvKey::Provided`].
    ///
    /// [`LayerFileConfig::from_path`]: crate::LayerFileConfig::from_path
    /// [`LayerConfig`]: crate::LayerConfig
    pub const AUTOGENERATED_MARKER: &str = "mirrord-internal-autogenerated";

    /// Returns the key value as a string slice.
    pub fn as_str(&self) -> &str {
        match self {
            EnvKey::Provided(s) | EnvKey::Generated(s) => s,
        }
    }

    /// Returns whether this key was provided by the user (not auto-generated).
    pub fn is_provided(&self) -> bool {
        matches!(self, EnvKey::Provided(_))
    }

    /// Returns whether this key was auto-generated (not provided by the user).
    pub fn is_generated(&self) -> bool {
        matches!(self, EnvKey::Generated(_))
    }

    /// Returns the key value if it was provided by the user, `None` if auto-generated.
    pub fn provided(&self) -> Option<&str> {
        match self {
            EnvKey::Provided(s) => Some(s),
            EnvKey::Generated(_) => None,
        }
    }

    /// Returns the length to report in analytics.
    ///
    /// - 0 for auto-generated keys
    /// - Actual length for user-provided keys
    pub fn analytics_len(&self) -> usize {
        match self {
            EnvKey::Provided(s) => s.len(),
            EnvKey::Generated(_) => 0,
        }
    }

    /// Generates a new UUID v4 key without any marker prefix.
    ///
    /// Used by [`EnvKeyFileConfig::generate_config`] when no key was found in the context at all
    /// (i.e., when [`LayerFileConfig::from_path`] was never called, such as when using defaults).
    ///
    /// [`LayerFileConfig::from_path`]: crate::LayerFileConfig::from_path
    pub fn autogenerated() -> String {
        uuid::Uuid::new_v4().to_string()
    }

    /// Generates a new UUID v4 key with [`AUTOGENERATED_MARKER`] prefix.
    ///
    /// Used by [`LayerFileConfig::from_path`] when auto-generating a key. The marker prefix
    /// allows [`EnvKeyFileConfig::generate_config`] to later identify this as an auto-generated
    /// key (see [`AUTOGENERATED_MARKER`] for details).
    ///
    /// [`LayerFileConfig::from_path`]: crate::LayerFileConfig::from_path
    /// [`AUTOGENERATED_MARKER`]: Self::AUTOGENERATED_MARKER
    pub fn autogenerated_with_marker() -> String {
        format!("{}{}", Self::AUTOGENERATED_MARKER, Self::autogenerated())
    }
}

/// File configuration for the session key.
///
/// In the config file, the key is simply an optional string.
/// The resolution happens in [`MirrordConfig::generate_config`].
#[derive(Default, PartialEq, Eq, Clone, Debug, Serialize, Deserialize, JsonSchema)]
#[serde(transparent)]
pub struct EnvKeyFileConfig(pub Option<String>);

impl FromMirrordConfig for EnvKey {
    type Generator = EnvKeyFileConfig;
}

impl MirrordConfig for EnvKeyFileConfig {
    type Generated = EnvKey;

    fn generate_config(self, context: &mut ConfigContext) -> Result<Self::Generated> {
        let key_from_env: Option<String> = FromEnv::new(MIRRORD_ENV_KEY)
            .source_value(context)
            .transpose()?;

        let key = key_from_env
            .map(|key| {
                if let Some(key) = key.strip_prefix(EnvKey::AUTOGENERATED_MARKER) {
                    EnvKey::Generated(key.to_owned())
                } else {
                    EnvKey::Provided(key)
                }
            })
            .or(self.0.map(EnvKey::Provided))
            .unwrap_or_else(|| EnvKey::Generated(EnvKey::autogenerated()));

        Ok(key)
    }
}
