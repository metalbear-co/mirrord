name: Windows Build

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Pick artifacts from GCS (reuse) or build & sign now"
        type: choice
        options: [build_sign, reuse]
        default: build_sign
      release:
        description: "Publish a GitHub Release?"
        type: choice
        options: [no, draft, prerelease, release]
        default: no
      release_tag:
        description: "Release tag (defaults to pushed tag or v<MIRRORD_VERSION>)"
        required: false
        type: string
      sign_artifacts:
        description: "Code-sign EXE & DLL (uses limited signing tokens)"
        type: choice
        options: ["false", "true"]
        default: false

  push:
    paths-ignore:
      - "*.md"
      - "**/*.md"

  pull_request:
    branches: ["main", "*staging*", "windows-support"]
    types: [opened, synchronize, reopened, ready_for_review]
    paths-ignore:
      - "*.md"
      - "**/*.md"

permissions:
  contents: write

env:
  BUCKET_URI: gs://mirrord-windows-builds
  MSI_BUCKET_URI: gs://mirrord-windows-msi
  RUST_BACKTRACE: "1"
  CARGO_NET_GIT_FETCH_WITH_CLI: "true"
  MIRRORD_TELEMETRY: "false"
  LIBCLANG_PATH: "C:\\Program Files\\LLVM\\bin"

jobs:
  windows_tests:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh

    env:
      MODE: ${{ github.event.inputs.mode || 'build_sign' }}
      PUBLISH_MODE: ${{ github.event.inputs.release || 'no' }}
      RELEASE_TAG_INPUT: ${{ github.event.inputs.release_tag || '' }}
      SIGN_ARTIFACTS: ${{ github.event.inputs.sign_artifacts || 'false' }}

    steps:

      # -------------------------
      # Checkout
      # -------------------------
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      # -------------------------
      # Rust info
      # -------------------------
      - name: Toolchain info
        run: |
          rustc -V
          cargo -V
          rustup show

      # -------------------------
      # Prepare artifacts
      # -------------------------
      - name: Prepare artifacts
        id: prep
        run: |
          $ErrorActionPreference = 'Stop'
          function Set-Env($k,$v){ "$k=$v" | Out-File -Append -FilePath $env:GITHUB_ENV }

          $Target = "x86_64-pc-windows-msvc"
          $DbgDir = "target/$Target/debug"
          $RelDir = "target/$Target/release"

          $Tmp  = Join-Path $env:RUNNER_TEMP 'prep'
          New-Item -ItemType Directory -Path $Tmp -Force | Out-Null

          $shouldSign = ($env:SIGN_ARTIFACTS -eq "true")

          if ($env:MODE -eq "reuse") {
            Write-Host "Reusing artifacts from GCS"

            $dest = Join-Path $Tmp 'picked'
            New-Item -ItemType Directory -Path $dest -Force | Out-Null

            gcloud storage cp "$($env:BUCKET_URI)/windows/*" "$dest/"

            $exe = Get-Item -Path "$dest/mirrord.exe"
            $dll = Get-Item -Path "$dest/mirrord_layer_win.dll"

            Set-Env MIRRORD_EXE $exe.FullName
            Set-Env MIRRORD_LAYER_FILE $dll.FullName
            Set-Env MIRRORD_VERSION "unknown"

            exit 0
          }

          rustup target add $Target

          # Build DLL
          cargo build -p mirrord-layer-win --target $Target
          $dll = Get-Item "$DbgDir/mirrord_layer_win.dll"

          # Sign DLL
          if ($shouldSign) {
            & signtool sign /sha1 bfa0bea8d22265cb382d2d5dec55a6ffcff70bcb `
              /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$($dll.FullName)"
          }

          # Build CLI
          $env:MIRRORD_LAYER_FILE = $dll.FullName
          cargo build -p mirrord --bin mirrord --target $Target
          $exe = Get-Item "$DbgDir/mirrord.exe"

          # Sign EXE
          if ($shouldSign) {
            & signtool sign /sha1 bfa0bea8d22265cb382d2d5dec55a6ffcff70bcb `
              /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$($exe.FullName)"
          }

          # Produce sha256 files
          foreach ($f in @($exe,$dll)) {
            $hash = (Get-FileHash -Algorithm SHA256 $f.FullName).Hash
            "$hash  $($f.Name)" | Out-File -Encoding ascii -FilePath "$($f.FullName).sha256"
          }

          # Export ENV
          Set-Env MIRRORD_EXE $exe.FullName
          Set-Env MIRRORD_LAYER_FILE $dll.FullName

          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg = ($meta.packages | Where-Object { $_.name -eq "mirrord" })
          Set-Env MIRRORD_VERSION $pkg.version

      # ---------------------------------------------------------
      # Build MSI (uses *your* main.wxs + icon + license)
      # ---------------------------------------------------------
      - name: Build MSI (WiX)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # Version formatting
          $raw = $env:MIRRORD_VERSION
          if (!$raw -or $raw -eq "unknown") { $msiVersion = "0.0.0.0" }
          else {
            $p = $raw.Split('.')
            if ($p.Count -lt 4) { $p += @("0")*(4-$p.Count) }
            $msiVersion = $p[0..3] -join "."
          }

          # Prepare directories
          $Root      = "C:\wix\mirrord"
          $Src       = "$Root\src"
          $Out       = "$Root\out"
          New-Item -Force -ItemType Directory -Path $Src,$Out | Out-Null

          # Copy artifacts
          Copy-Item $env:MIRRORD_EXE "$Src\mirrord.exe" -Force
          Copy-Item $env:MIRRORD_LAYER_FILE "$Src\mirrord_layer_win.dll" -Force

          # Copy asset files from the repo
          Copy-Item "mirrord/cli/wix/mirrord.ico"     "$Root\mirrord.ico"  -Force
          Copy-Item "mirrord/cli/wix/License.rtf"     "$Root\License.rtf"  -Force
          Copy-Item "mirrord/cli/wix/main.wxs"        "$Root\main.wxs"     -Force

          $candle = (Get-ChildItem 'C:\Program Files (x86)\WiX Toolset v3.*\bin\candle.exe')[0].FullName
          $light  = (Get-ChildItem 'C:\Program Files (x86)\WiX Toolset v3.*\bin\light.exe')[0].FullName

          $WixObj = "$Out\Product_mirrord.wixobj"
          $MsiOut = "$Out\mirrord-$msiVersion.msi"

          if (Test-Path $MsiOut) { Remove-Item $MsiOut -Force }

          & $candle -nologo `
            -dSrc="$Src" `
            -dWixAssets="$Root" `
            -dVersion="$msiVersion" `
            -ext WixUIExtension `
            -out $WixObj `
            "$Root\main.wxs"

          if (-not (Test-Path $WixObj)) { throw "Candle failed: no wixobj" }

          & $light -nologo `
            -ext WixUIExtension `
            -out $MsiOut `
            $WixObj

          if (-not (Test-Path $MsiOut)) { throw "Light failed: no MSI produced" }

          $hash = (Get-FileHash -Algorithm SHA256 $MsiOut).Hash
          "$hash  $(Split-Path $MsiOut -Leaf)" | Out-File -Encoding ascii -FilePath "$MsiOut.sha256"

          "MSI_PATH=$MsiOut"        | Out-File -Append -FilePath $env:GITHUB_ENV
          "MSI_SHA256_PATH=$MsiOut.sha256" | Out-File -Append -FilePath $env:GITHUB_ENV

      # ---------------------------------------------------------
      # Upload MSI to GCS
      # ---------------------------------------------------------
      - name: Upload MSI to GCS
        if: ${{ env.MSI_BUCKET_URI != '' }}
        run: |
          gcloud storage cp $env:MSI_PATH $env:MSI_BUCKET_URI
          gcloud storage cp $env:MSI_SHA256_PATH $env:MSI_BUCKET_URI

      # ---------------------------------------------------------
      # Upload EXE + DLL (build_sign mode)
      # ---------------------------------------------------------
      - name: Upload EXE/DLL to GCS
        if: ${{ env.MODE == 'build_sign' }}
        run: |
          $version = $env:MIRRORD_VERSION
          $sha7 = $env:GITHUB_SHA.Substring(0,7)
          $dest = "$($env:BUCKET_URI)/windows/mirrord-$version-$sha7/"

          gcloud storage cp $env:MIRRORD_EXE             $dest
          gcloud storage cp "$env:MIRRORD_EXE.sha256"   $dest
          gcloud storage cp $env:MIRRORD_LAYER_FILE      $dest
          gcloud storage cp "$env:MIRRORD_LAYER_FILE.sha256" $dest

      # ---------------------------------------------------------
      # GitHub Release
      # ---------------------------------------------------------
      - name: Compute release tag
        id: tag
        if: ${{ github.event_name != 'pull_request' && (startsWith(github.ref, 'refs/tags/') || env.PUBLISH_MODE != 'no') }}
        run: |
          if ("$env:GITHUB_REF".StartsWith("refs/tags/")) {
            $tag = "$env:GITHUB_REF".Substring(10)
          } elseif ($env:RELEASE_TAG_INPUT) {
            $tag = $env:RELEASE_TAG_INPUT
          } else {
            $tag = "v$env:MIRRORD_VERSION"
          }
          "RELEASE_TAG=$tag" | Out-File -Append -FilePath $env:GITHUB_ENV

      - name: Publish GitHub Release (github-script)
        if: ${{ github.event_name != 'pull_request' && (startsWith(github.ref, 'refs/tags/') || env.PUBLISH_MODE != 'no') }}
        uses: actions/github-script@v7
        env:
          RELEASE_TAG: ${{ env.RELEASE_TAG }}
          PUBLISH_MODE: ${{ env.PUBLISH_MODE }}
          MIRRORD_EXE: ${{ env.MIRRORD_EXE }}
          MIRRORD_LAYER_FILE: ${{ env.MIRRORD_LAYER_FILE }}
          MSI_PATH: ${{ env.MSI_PATH }}
          MSI_SHA256_PATH: ${{ env.MSI_SHA256_PATH }}
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const { owner, repo } = context.repo;

            const tag = process.env.RELEASE_TAG;
            const isDraft = process.env.PUBLISH_MODE === "draft";
            const isPrerelease = process.env.PUBLISH_MODE === "prerelease";

            // 1. Get or create release
            let release;
            try {
              const r = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              release = r.data;
            } catch (e) {
              if (e.status !== 404) throw e;
              const r = await github.rest.repos.createRelease({
                owner,
                repo,
                tag_name: tag,
                name: `Windows build ${tag}`,
                draft: isDraft,
                prerelease: isPrerelease,
                target_commitish: context.sha,
                generate_release_notes: true,
              });
              release = r.data;
            }

            // 2. Correct draft/prerelease flags if mismatched
            if (release.draft !== isDraft || release.prerelease !== isPrerelease) {
              const r = await github.rest.repos.updateRelease({
                owner,
                repo,
                release_id: release.id,
                draft: isDraft,
                prerelease: isPrerelease,
                name: `Windows build ${tag}`,
              });
              release = r.data;
            }

            // Helper to upload asset
            async function upload(filePath) {
              if (!filePath || !fs.existsSync(filePath)) {
                core.warning(`Missing file: ${filePath}`);
                return;
              }
              const name = path.basename(filePath);
              const data = fs.readFileSync(filePath);

              // remove old asset
              const assets = await github.rest.repos.listReleaseAssets({
                owner,
                repo,
                release_id: release.id,
              });
              const existing = assets.data.find(a => a.name === name);
              if (existing) {
                await github.rest.repos.deleteReleaseAsset({
                  owner,
                  repo,
                  asset_id: existing.id,
                });
              }

              // upload new asset
              await github.rest.repos.uploadReleaseAsset({
                owner,
                repo,
                release_id: release.id,
                name,
                data,
                headers: {
                  "content-type": "application/octet-stream",
                  "content-length": data.length
                },
              });

              core.info(`Uploaded ${name}`);
            }

            // Upload all artifacts
            const files = [
              process.env.MIRRORD_EXE,
              `${process.env.MIRRORD_EXE}.sha256`,
              process.env.MIRRORD_LAYER_FILE,
              `${process.env.MIRRORD_LAYER_FILE}.sha256`,
              process.env.MSI_PATH,
              process.env.MSI_SHA256_PATH,
            ];

            for (const file of files) {
              await upload(file);
            }

