name: Windows Build & Package

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Pick artifacts from GCS (reuse) or build & sign now"
        type: choice
        options: [build_sign, reuse]
        default: build_sign
      sign_artifacts:
        description: "Code-sign EXE & DLL (uses signing tokens)"
        type: choice
        options: ["false", "true"]
        default: "false"
      release_tag:
        description: "Version / tag override (e.g. 3.174.0 or 0.0.1-test3)"
        required: false
        type: string
      publish_choco:
        description: "Build a Chocolatey .nupkg?"
        type: choice
        options: ["false", "true"]
        default: "false"
      publish_winget:
        description: "Generate a WinGet manifest?"
        type: choice
        options: ["false", "true"]
        default: "false"
      release:
        description: "Create / update GitHub Release and attach assets?"
        type: choice
        options: [no, draft, prerelease, release]
        default: no

  push:
    paths-ignore:
      - "*.md"
      - "**/*.md"

  pull_request:
    branches: ["main", "*staging*", "windows-support"]
    types: [opened, synchronize, reopened, ready_for_review]
    paths-ignore:
      - "*.md"
      - "**/*.md"

permissions:
  contents: write

env:
  # GCS bucket with built artifacts (for reuse mode)
  BUCKET_URI: gs://mirrord-windows-builds
  ARTIFACT_SUBPATH: windows/mirrord-latest

  # Public HTTP base where MSI will be uploaded (used for WinGet manifest URL)
  MSI_HTTP_BASE: https://storage.googleapis.com/mirrord-windows-builds-public

  # Default WinGet package ID (can override via env if needed)
  WINGET_PACKAGE_ID: MetalBear.mirrord


jobs:
  windows_build_and_package:
    runs-on: windows-latest
    # If you use self-hosted runner, change to:
    # runs-on: [self-hosted, windows]

    env:
      MODE: ${{ inputs.mode }}
      SIGN_ARTIFACTS: ${{ inputs.sign_artifacts }}
      PUBLISH_CHOCO: ${{ inputs.publish_choco }}
      PUBLISH_WINGET: ${{ inputs.publish_winget }}
      RELEASE_TAG_INPUT: ${{ inputs.release_tag }}
      RELEASE_MODE: ${{ inputs.release }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@v1
        with:
          toolchain: stable

      # Optional: auth to GCP if you actually use MODE=reuse
      # - name: Authenticate to GCP
      #   if: inputs.mode == 'reuse'
      #   uses: google-github-actions/auth@v2
      #   with:
      #     credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Windows build + MSI + choco + WinGet
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          Write-Host "=== Windows build & packaging script starting ==="

          function Write-Env([string]$k,[string]$v) {
              if (-not $env:GITHUB_ENV) {
                  Write-Warning "GITHUB_ENV not set, cannot export env var $k"
                  return
              }
              "$k=$v" | Out-File -Append -FilePath $env:GITHUB_ENV
              Write-Host "[env] $k=$v"
          }

          function Find-Executable {
              param(
                  [Parameter(Mandatory = $true)][string]$Name,
                  [string[]]$CandidateDirs,
                  [switch]$DeepSearch
              )

              foreach ($dir in $CandidateDirs) {
                  if (-not $dir) { continue }
                  if (-not (Test-Path $dir)) { continue }

                  $direct = Join-Path $dir $Name
                  if (Test-Path $direct) {
                      return (Resolve-Path $direct).Path
                  }

                  if ($DeepSearch) {
                      $found = Get-ChildItem -Path $dir -Recurse -Filter $Name -ErrorAction SilentlyContinue -File | Select-Object -First 1
                      if ($found) {
                          return $found.FullName
                      }
                  }
              }

              if ($DeepSearch) {
                  Write-Host "  Deep searching Program Files/Chocolatey roots for $Name..."
                  $roots = @(
                      "C:\Program Files (x86)",
                      "C:\Program Files",
                      "C:\ProgramData\chocolatey"
                  ) | Where-Object { Test-Path $_ }

                  foreach ($root in $roots) {
                      $found = Get-ChildItem -Path $root -Recurse -Filter $Name -ErrorAction SilentlyContinue -File | Select-Object -First 1
                      if ($found) {
                          return $found.FullName
                      }
                  }
              }

              return $null
          }

          function Find-Candle {
              param([switch]$DeepSearch)

              Write-Host "=== Searching for WiX candle.exe ==="

              $candidateDirs = @()

              if ($env:WIX)      { $candidateDirs += $env:WIX }
              if ($env:WIX_ROOT) { $candidateDirs += $env:WIX_ROOT }

              $candidateDirs += @(
                  "C:\Program Files (x86)\WiX Toolset v3.11\bin",
                  "C:\Program Files (x86)\WiX Toolset v3.14\bin",
                  "C:\Program Files\WiX Toolset v3.11\bin",
                  "C:\Program Files\WiX Toolset v3.14\bin",
                  "C:\ProgramData\chocolatey\lib\wixtoolset\tools\bin",
                  "C:\ProgramData\chocolatey\lib\wixtoolset.portable\tools\wix311\bin",
                  "C:\ProgramData\chocolatey\lib\wix\tools\bin"
              )

              $exe = Find-Executable -Name "candle.exe" -CandidateDirs $candidateDirs -DeepSearch:$DeepSearch

              if (-not $exe) {
                  $listed = ($candidateDirs | Where-Object { $_ }) -join "; "
                  throw @"
          WiX candle.exe not found.

          Please install WiX Toolset *once* on this VM (as Administrator), e.g.:

            choco install wixtoolset --version=3.11.2

          Then re-run the workflow.

          Checked locations:
          $listed
          "@
              }

              $wixBin = Split-Path -Parent $exe
              $env:PATH = "$wixBin;$env:PATH"
              Write-Env "WIX_BIN" $wixBin

              Write-Host "Using candle.exe at: $exe"
              return $exe
          }

          function Find-Light {
              param([switch]$DeepSearch)

              Write-Host "=== Searching for WiX light.exe ==="

              $candidateDirs = @()

              if ($env:WIX)      { $candidateDirs += $env:WIX }
              if ($env:WIX_ROOT) { $candidateDirs += $env:WIX_ROOT }

              $candidateDirs += @(
                  "C:\Program Files (x86)\WiX Toolset v3.11\bin",
                  "C:\Program Files (x86)\WiX Toolset v3.14\bin",
                  "C:\Program Files\WiX Toolset v3.14\bin",
                  "C:\Program Files\WiX Toolset v3.11\bin",
                  "C:\ProgramData\chocolatey\lib\wixtoolset\tools\bin",
                  "C:\ProgramData\chocolatey\lib\wixtoolset.portable\tools\wix311\bin",
                  "C:\ProgramData\chocolatey\lib\wix\tools\bin"
              )

              $exe = Find-Executable -Name "light.exe" -CandidateDirs $candidateDirs -DeepSearch:$DeepSearch

              if (-not $exe) {
                  $listed = ($candidateDirs | Where-Object { $_ }) -join "; "
                  throw @"
          WiX light.exe not found.

          Please install WiX Toolset *once* on this VM (as Administrator), e.g.:

            choco install wixtoolset --version=3.11.2

          Then re-run the workflow.

          Checked locations:
          $listed
          "@
              }

              $wixBin = Split-Path -Parent $exe
              if ($env:PATH -notlike "*$wixBin*") {
                  $env:PATH = "$wixBin;$env:PATH"
              }

              Write-Host "Using light.exe at: $exe"
              return $exe
          }

          function Resolve-Version {
              if ($env:RELEASE_TAG_INPUT -and $env:RELEASE_TAG_INPUT.Trim() -ne "") {
                  return $env:RELEASE_TAG_INPUT.Trim()
              }

              if ($env:MIRRORD_VERSION -and $env:MIRRORD_VERSION.Trim() -ne "") {
                  return $env:MIRRORD_VERSION.Trim()
              }

              return "0.0.0-local"
          }

          # =====================================================================
          # 1) BUILD OR REUSE ARTIFACTS
          # =====================================================================

          $Target = "x86_64-pc-windows-msvc"
          $DbgDir = Join-Path $env:GITHUB_WORKSPACE "target\$Target\debug"
          $RelDir = Join-Path $env:GITHUB_WORKSPACE "target\$Target\release"
          $Tmp    = Join-Path $env:RUNNER_TEMP "prep"

          Write-Host "Target: $Target"
          Write-Host "Debug dir:   $DbgDir"
          Write-Host "Release dir: $RelDir"
          Write-Host "Temp dir:    $Tmp"

          New-Item -ItemType Directory -Force -Path $Tmp | Out-Null

          $shouldSign = [System.String]::Equals($env:SIGN_ARTIFACTS, "true", "InvariantCultureIgnoreCase")

          if ($env:MODE -eq "reuse") {
              Write-Host "=== MODE=reuse: picking artifacts from GCS ==="

              if (-not (Get-Command gcloud -ErrorAction SilentlyContinue)) {
                  throw "gcloud not found on PATH â€“ cannot reuse artifacts from $($env:BUCKET_URI)."
              }

              $dest = Join-Path $Tmp "picked"
              New-Item -ItemType Directory -Force -Path $dest | Out-Null

              Write-Host "Downloading from $($env:BUCKET_URI)/$($env:ARTIFACT_SUBPATH)/* to $dest"
              gcloud --quiet storage cp "$($env:BUCKET_URI)/$($env:ARTIFACT_SUBPATH)/*" "$dest/"

              $exe = (Get-ChildItem $dest -Filter "mirrord.exe" -Recurse -File | Select-Object -First 1).FullName
              $dll = (Get-ChildItem $dest -Filter "mirrord_layer_win.dll" -Recurse -File | Select-Object -First 1).FullName

              if (-not $exe -or -not $dll) {
                  throw "Failed to find EXE or DLL in reused artifacts."
              }

              if ($shouldSign) {
                  Write-Host "Signing reused DLL & EXE..."
                  & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                      /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$dll"
                  & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                      /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$exe"
              }

              Write-Env "MIRRORD_EXE"        $exe
              Write-Env "MIRRORD_LAYER_FILE" $dll
              Write-Env "MIRRORD_VERSION"    (Resolve-Version)

          } else {
              Write-Host "=== MODE=build_sign: building mirrord from source ==="

              rustup target add $Target

              Write-Host "--- Building mirrord-layer-win (DLL) ---"
              cargo build -p mirrord-layer-win --target $Target

              $dll = Join-Path $DbgDir "mirrord_layer_win.dll"
              if (-not (Test-Path $dll)) {
                  $dll = Join-Path $RelDir "mirrord_layer_win.dll"
              }
              if (-not (Test-Path $dll)) {
                  throw "DLL not found after build (looked in $DbgDir and $RelDir)."
              }

              if ($shouldSign) {
                  Write-Host "Signing DLL..."
                  & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                      /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$dll"
              }

              Write-Host "--- Building mirrord CLI (EXE) ---"
              $env:MIRRORD_LAYER_FILE = $dll
              cargo build -p mirrord --bin mirrord --target $Target

              $exe = Join-Path $DbgDir "mirrord.exe"
              if (-not (Test-Path $exe)) {
                  $exe = Join-Path $RelDir "mirrord.exe"
              }
              if (-not (Test-Path $exe)) {
                  throw "EXE not found after build (looked in $DbgDir and $RelDir)."
              }

              if ($shouldSign) {
                  Write-Host "Signing EXE..."
                  & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                      /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$exe"
              }

              Write-Env "MIRRORD_EXE"        $exe
              Write-Env "MIRRORD_LAYER_FILE" $dll

              Write-Host "--- Resolving version via cargo metadata ---"
              $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
              $pkg  = $meta.packages | Where-Object { $_.name -eq "mirrord" } | Select-Object -First 1
              $version = if ($pkg) { $pkg.version } else { "0.0.0-local" }

              $version = if ($env:RELEASE_TAG_INPUT -and $env:RELEASE_TAG_INPUT.Trim() -ne "") {
                  $env:RELEASE_TAG_INPUT.Trim()
              } else {
                  $version
              }

              Write-Env "MIRRORD_VERSION" $version
          }

          $env:MIRRORD_VERSION = Resolve-Version()
          Write-Host "Resolved MIRRORD_VERSION (will also be used as tag): $($env:MIRRORD_VERSION)"

          # =====================================================================
          # 2) MSI BUILD (WIX)
          # =====================================================================

          Write-Host "=== Building MSI with WiX ==="

          $candleExe = Find-Candle -DeepSearch
          $lightExe  = Find-Light  -DeepSearch

          $msiWorkDir = Join-Path $Tmp "msi"
          $objDir     = Join-Path $msiWorkDir "obj"
          $outDir     = if ($env:MSI_OUTPUT_DIR -and $env:MSI_OUTPUT_DIR.Trim() -ne "") {
              $env:MSI_OUTPUT_DIR.Trim()
          } else {
              Join-Path $msiWorkDir "dist"
          }

          New-Item -ItemType Directory -Force -Path $objDir | Out-Null
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          Write-Host "MSI work dir:  $msiWorkDir"
          Write-Host "MSI obj dir:   $objDir"
          Write-Host "MSI out dir:   $outDir"

          $wxs = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Recurse -Filter "mirrord.wxs" -File -ErrorAction SilentlyContinue | Select-Object -First 1

          if (-not $wxs) {
              throw "mirrord.wxs not found in repo. Please ensure a WiX source file named 'mirrord.wxs' exists."
          }

          Write-Host "Using WiX source: $($wxs.FullName)"

          $wixObj  = Join-Path $objDir "mirrord.wixobj"
          $msiName = "mirrord-$($env:MIRRORD_VERSION)-x64.msi"
          $msiPath = Join-Path $outDir $msiName

          & $candleExe -nologo -dVersion=$env:MIRRORD_VERSION -out $wixObj $wxs.FullName

          if (-not (Test-Path $wixObj)) {
              throw "WiX object file not created at $wixObj"
          }

          & $lightExe -nologo -ext WixUIExtension -out $msiPath $wixObj

          if (-not (Test-Path $msiPath)) {
              throw "MSI was not created at $msiPath"
          }

          Write-Host "MSI created: $msiPath"
          Write-Env "MSI_PATH" $msiPath

          # =====================================================================
          # 3) CHOCOLATEY PACKAGE
          # =====================================================================

          $publishChoco = [System.String]::Equals($env:PUBLISH_CHOCO, "true", "InvariantCultureIgnoreCase")
          if ($publishChoco) {
              Write-Host "=== Building Chocolatey package (.nupkg) ==="

              if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
                  throw "PUBLISH_CHOCO=true but 'choco' CLI not found on PATH."
              }

              $chocoDir   = Join-Path $Tmp "choco"
              New-Item -ItemType Directory -Force -Path $chocoDir | Out-Null

              $nuspecPath = Join-Path $chocoDir "mirrord.nuspec"
              $version    = $env:MIRRORD_VERSION
              $id         = "mirrord"
              $authors    = "MetalBear"
              $projectUrl = "https://github.com/metalbear-co/mirrord"
              $licenseUrl = "https://github.com/metalbear-co/mirrord/blob/main/LICENSE"

              @"
          <?xml version="1.0"?>
          <package xmlns="http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd">
            <metadata>
              <id>$id</id>
              <version>$version</version>
              <authors>$authors</authors>
              <owners>$authors</owners>
              <title>mirrord</title>
              <description>mirrord lets you run local code in the context of your Kubernetes cluster.</description>
              <projectUrl>$projectUrl</projectUrl>
              <licenseUrl>$licenseUrl</licenseUrl>
              <requireLicenseAcceptance>false</requireLicenseAcceptance>
              <tags>mirrord kubernetes debugging</tags>
            </metadata>
            <files>
              <file src="$msiPath" target="tools\mirrord.msi" />
            </files>
          </package>
          "@ | Set-Content -Path $nuspecPath -Encoding UTF8

              Push-Location $chocoDir
              try {
                  choco pack $nuspecPath --out $chocoDir
              } finally {
                  Pop-Location
              }

              $chocoNupkg = Join-Path $chocoDir "mirrord.$version.nupkg"
              if (-not (Test-Path $chocoNupkg)) {
                  $chocoNupkg = Get-ChildItem $chocoDir -Filter "*.nupkg" -File -ErrorAction SilentlyContinue |
                      Sort-Object LastWriteTime -Descending |
                      Select-Object -First 1 |
                      ForEach-Object { $_.FullName }
              }

              if (-not $chocoNupkg) {
                  throw "Chocolatey .nupkg was not created in $chocoDir"
              }

              Write-Host "Chocolatey package created: $chocoNupkg"
              Write-Env "CHOCO_NUPKG_PATH" $chocoNupkg
          } else {
              Write-Host "PUBLISH_CHOCO != true, skipping Chocolatey packaging."
          }

          # =====================================================================
          # 4) WINGET MANIFEST
          # =====================================================================

          $publishWinget = [System.String]::Equals($env:PUBLISH_WINGET, "true", "InvariantCultureIgnoreCase")
          if ($publishWinget) {
              Write-Host "=== Generating WinGet manifest ==="

              $wingetDir = Join-Path $Tmp "winget"
              New-Item -ItemType Directory -Force -Path $wingetDir | Out-Null

              $manifestPath = Join-Path $wingetDir "mirrord.yaml"
              $packageId    = if ($env:WINGET_PACKAGE_ID -and $env:WINGET_PACKAGE_ID.Trim() -ne "") {
                  $env:WINGET_PACKAGE_ID.Trim()
              } else {
                  "MetalBear.mirrord"
              }

              $urlBase = if ($env:MSI_HTTP_BASE -and $env:MSI_HTTP_BASE.Trim() -ne "") {
                  $env:MSI_HTTP_BASE.TrimEnd("/")
              } else {
                  "https://storage.googleapis.com/mirrord-windows-builds-public"
              }

              $msiFileName = Split-Path -Leaf $msiPath
              $msiHttp     = "$urlBase/$msiFileName"
              $sha256      = (Get-FileHash -Algorithm SHA256 -Path $msiPath).Hash.ToLowerInvariant()

              @"
          # Generated by CI - do not edit manually
          Id: $packageId
          Version: $($env:MIRRORD_VERSION)
          Name: mirrord
          Publisher: MetalBear
          License: MIT
          LicenseUrl: https://github.com/metalbear-co/mirrord/blob/main/LICENSE
          Homepage: https://github.com/metalbear-co/mirrord
          ShortDescription: Run local code in the context of your Kubernetes cluster.
          Moniker: mirrord
          Installers:
            - Architecture: x64
              InstallerType: wix
              InstallerUrl: $msiHttp
              InstallerSha256: $sha256
          "@ | Set-Content -Path $manifestPath -Encoding UTF8

              Write-Host "WinGet manifest created: $manifestPath"
              Write-Env "WINGET_MANIFEST_PATH" $manifestPath
          } else {
              Write-Host "PUBLISH_WINGET != true, skipping WinGet manifest."
          }

          Write-Host "=== Windows build & packaging script completed successfully ==="

      - name: Upload MSI artifact
        uses: actions/upload-artifact@v4
        with:
          name: mirrord-msi
          path: ${{ env.MSI_PATH }}

      - name: Upload Chocolatey package artifact
        if: inputs.publish_choco == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: mirrord-choco-nupkg
          path: ${{ env.CHOCO_NUPKG_PATH }}

      - name: Upload WinGet manifest artifact
        if: inputs.publish_winget == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: mirrord-winget-manifest
          path: ${{ env.WINGET_MANIFEST_PATH }}

      # ============================================================
      # 5) OPTIONAL: CREATE / UPDATE GITHUB RELEASE & ATTACH FILES
      # ============================================================

      - name: Create / update GitHub Release (MSI)
        if: inputs.release != 'no'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.MIRRORD_VERSION }}
          name: mirrord ${{ env.MIRRORD_VERSION }}
          draft: ${{ inputs.release == 'draft' }}
          prerelease: ${{ inputs.release == 'prerelease' }}
          files: |
            ${{ env.MSI_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Attach Chocolatey package to GitHub Release
        if: inputs.release != 'no' && inputs.publish_choco == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.MIRRORD_VERSION }}
          draft: ${{ inputs.release == 'draft' }}
          prerelease: ${{ inputs.release == 'prerelease' }}
          files: |
            ${{ env.CHOCO_NUPKG_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Attach WinGet manifest to GitHub Release
        if: inputs.release != 'no' && inputs.publish_winget == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.MIRRORD_VERSION }}
          draft: ${{ inputs.release == 'draft' }}
          prerelease: ${{ inputs.release == 'prerelease' }}
          files: |
            ${{ env.WINGET_MANIFEST_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
