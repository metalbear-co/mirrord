# name: Build PR 3536 (Windows, self-hosted, minimal)

# on:
#   workflow_dispatch:

# permissions:
#   contents: read

# jobs:
#   build:
#     runs-on: [self-hosted, Windows]
#     defaults:
#       run:
#         shell: pwsh

#     env:
#       # Build output paths (adjust if you use Release)
#       LAYER_DLL: target\x86_64-pc-windows-msvc\debug\layer_win.dll
#       MIRRORD_EXE: target\x86_64-pc-windows-msvc\debug\mirrord.exe

#     steps:
#       - name: Checkout PR 3536 (merge ref)
#         uses: actions/checkout@v4
#         with:
#           ref: refs/pull/3536/merge
#           fetch-depth: 1

#       - name: Add Rust MSVC target
#         run: rustup target add x86_64-pc-windows-msvc

#       - name: Build layer-win (DLL)
#         run: cargo build -p layer-win --target x86_64-pc-windows-msvc

#       - name: Set MIRRORD_LAYER_FILE
#         run: |
#           $env:MIRRORD_LAYER_FILE = "${{ env.LAYER_DLL }}"
#           "MIRRORD_LAYER_FILE=$env:MIRRORD_LAYER_FILE" | Out-File -FilePath $env:GITHUB_ENV -Append

#       - name: Build mirrord (EXE)
#         run: cargo build -p mirrord --target x86_64-pc-windows-msvc

#       # ---------- Signing prep: ensure SignTool is available ----------
#       - name: Locate or install Windows SDK (SignTool)
#         run: |
#           # Try to locate SignTool in Windows Kits
#           $sdkBin = Get-ChildItem 'C:\Program Files (x86)\Windows Kits\10\bin' -Directory -ErrorAction SilentlyContinue |
#             Sort-Object Name -Descending | Select-Object -First 1

#           if (-not $sdkBin) {
#             Write-Host "Windows SDK not found; attempting install via winget..."
#             try {
#               winget source update | Out-Null
#               # Use the community source explicitly to avoid msstore prompts
#               $pkg = "Microsoft.WindowsSDK.10.0.26100"
#               winget install --source winget --exact --id $pkg --accept-package-agreements --accept-source-agreements
#             } catch {
#               Write-Error "Failed to install Windows SDK automatically. Install it on the runner and rerun."
#               exit 1
#             }
#             $sdkBin = Get-ChildItem 'C:\Program Files (x86)\Windows Kits\10\bin' -Directory |
#               Sort-Object Name -Descending | Select-Object -First 1
#           }

#           $signtool = Join-Path $sdkBin.FullName 'x64\signtool.exe'
#           if (-not (Test-Path $signtool)) {
#             throw "signtool.exe not found under $($sdkBin.FullName). Ensure Windows SDK is installed."
#           }

#           "SIGNTOOL=$signtool" | Out-File -FilePath $env:GITHUB_ENV -Append
#           Write-Host "Using SignTool at $signtool"

#       # ---------- Signing prep: DigiCert smctl + KSP credentials ----------
#       - name: Prepare DigiCert (smctl + KSP)
#         env:
#           DIGICERT_API_KEY:              ${{ secrets.DIGICERT_API_KEY }}
#           DIGICERT_CLIENT_CERT_PFX_B64:  ${{ secrets.DIGICERT_CLIENT_CERT_PFX_B64 }}
#           DIGICERT_CLIENT_CERT_PASSWORD: ${{ secrets.DIGICERT_CLIENT_CERT_PASSWORD }}
#         run: |
#           # Find smctl from typical install paths
#           $smctlCandidates = @(
#             "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools\smctl.exe",
#             "C:\Program Files\DigiCert\DigiCert KeyLocker Tools\smctl.exe"
#           )
#           $smctl = $smctlCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
#           if (-not $smctl) { throw "smctl.exe not found. Install DigiCert Signing Manager/KeyLocker Tools on this runner." }
#           Write-Host "Using smctl at $smctl"

#           # Recreate the client-auth P12 from secret
#           $p12Path = Join-Path $env:RUNNER_TEMP "digicert-client-auth.p12"
#           [IO.File]::WriteAllBytes($p12Path, [Convert]::FromBase64String($env:DIGICERT_CLIENT_CERT_PFX_B64))

#           # Required env vars for smctl
#           $env:SM_HOST = "https://clientauth.one.digicert.com"
#           $env:SM_CLIENT_CERT_FILE = $p12Path

#           # Save API key + P12 password in Windows Credential Manager
#           & $smctl credentials save $env:DIGICERT_API_KEY $env:DIGICERT_CLIENT_CERT_PASSWORD

#           # Register the KSP (safe to re-run). If already registered, it may print 0xC0000035, which is harmless.
#           try { & $smctl windows ksp register } catch { Write-Warning $_ }

#           # Optional: show tools mapping (won't fail the build if unmapped)
#           & $smctl healthcheck --tools || $true

#       # ---------- Fetch the public certificate for your keypair ----------
#       - name: Download signing certificate
#         env:
#           DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
#         run: |
#           $smctl = @(
#             "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools\smctl.exe",
#             "C:\Program Files\DigiCert\DigiCert KeyLocker Tools\smctl.exe"
#           ) | Where-Object { Test-Path $_ } | Select-Object -First 1

#           $outDir = $env:RUNNER_TEMP
#           & $smctl certificate download --keypair-alias $env:DIGICERT_KEYPAIR_ALIAS --format cer --out $outDir

#           $cert = Get-ChildItem $outDir -Filter *.cer | Select-Object -First 1 | % FullName
#           if (-not $cert) { throw "Failed to download .cer for keypair alias $env:DIGICERT_KEYPAIR_ALIAS" }

#           "CODESIGN_CERT=$cert" | Out-File -FilePath $env:GITHUB_ENV -Append
#           Write-Host "Downloaded signing certificate to $cert"

#       # ---------- Sign the DLL and EXE using SignTool + DigiCert KSP ----------
#       - name: Sign artifacts (DLL + EXE)
#         env:
#           DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
#         run: |
#           $ts = "http://timestamp.digicert.com"
#           $signtool = "$env:SIGNTOOL"
#           $cert = "$env:CODESIGN_CERT"
#           $alias = "$env:DIGICERT_KEYPAIR_ALIAS"

#           & $signtool sign /fd SHA256 /tr $ts /td SHA256 `
#             /csp "DigiCert Signing Manager KSP" /kc "$alias" /f "$cert" `
#             "${{ env.LAYER_DLL }}"

#           & $signtool sign /fd SHA256 /tr $ts /td SHA256 `
#             /csp "DigiCert Signing Manager KSP" /kc "$alias" /f "$cert" `
#             "${{ env.MIRRORD_EXE }}"

#       - name: Verify signatures
#         run: |
#           & "$env:SIGNTOOL" verify /pa /all "${{ env.LAYER_DLL }}"
#           & "$env:SIGNTOOL" verify /pa /all "${{ env.MIRRORD_EXE }}"

# name: Build PR 3536 (Windows, self-hosted, minimal)

# on:
#   workflow_dispatch:

# permissions:
#   contents: read

# jobs:
#   build:
#     runs-on: [self-hosted, Windows]
#     defaults:
#       run:
#         shell: pwsh

#     steps:
#       - name: Checkout PR 3536 (merge ref)
#         uses: actions/checkout@v4
#         with:
#           ref: refs/pull/3536/merge
#           fetch-depth: 1

#       - name: Add Rust MSVC target
#         run: |
#           rustup target add x86_64-pc-windows-msvc
#       - name: Build layer-win (DLL)
#         run: |
#           cargo build -p layer-win --target x86_64-pc-windows-msvc
#       - name: Set MIRRORD_LAYER_FILE
#         run: |
#           $env:MIRRORD_LAYER_FILE = "target\x86_64-pc-windows-msvc\debug\layer_win.dll"
#           "MIRRORD_LAYER_FILE=$env:MIRRORD_LAYER_FILE" | Out-File -FilePath $env:GITHUB_ENV -Append
#       - name: Build mirrord (EXE)
#         run: |
#           cargo build -p mirrord --target x86_64-pc-windows-msvc
name: Build PR 3536 (Windows, self-hosted, minimal)

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  build:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout PR 3536 (merge ref)
        uses: actions/checkout@v4
        with:
          ref: refs/pull/3536/merge
          fetch-depth: 0
          submodules: recursive

      # Ensure Rust is available even if the service PATH doesn't include it
      - name: Ensure Rust toolchain (if cargo/rustup missing)
        run: |
          $cargo = Get-Command cargo.exe -ErrorAction SilentlyContinue
          if (-not $cargo) {
            $env:CARGO_HOME  = "$env:RUNNER_TEMP\.cargo"
            $env:RUSTUP_HOME = "$env:RUNNER_TEMP\.rustup"
            $installer = "$env:RUNNER_TEMP\rustup-init.exe"
            Invoke-WebRequest -Uri https://win.rustup.rs/x86_64 -OutFile $installer
            & $installer -y --default-host x86_64-pc-windows-msvc --profile minimal
            $env:PATH = "$env:CARGO_HOME\bin;$env:PATH"
          }
          rustup --version
          cargo --version

      - name: Add Rust MSVC target
        run: rustup target add x86_64-pc-windows-msvc

      # ---- Build the DLL that outputs layer_win.dll (robust manifest search) ----
      - name: Locate & build layer_win (DLL)
        run: |
          $dllName = 'layer_win'
          # Prefer [lib] name match
          $cand = Get-ChildItem -Recurse -Filter Cargo.toml -File | Where-Object {
            (Select-String -Path $_.FullName -Pattern '^\s*\[lib\]' -SimpleMatch -Quiet) -and
            (Select-String -Path $_.FullName -Pattern '^\s*name\s*=\s*"' + [regex]::Escape($dllName) + '"\s*$' -SimpleMatch -Quiet)
          } | Select-Object -First 1
          if (-not $cand) {
            # Fallback: package name that maps to layer_win (hyphen â†’ underscore)
            foreach ($toml in (Get-ChildItem -Recurse -Filter Cargo.toml -File)) {
              $nameLine = Select-String -Path $toml.FullName -Pattern '^\s*name\s*=\s*"(.*)"\s*$' | Select-Object -First 1
              if ($nameLine) {
                $pkg = $nameLine.Matches[0].Groups[1].Value
                if (($pkg -replace '-', '_') -eq $dllName) { $cand = $toml; break }
              }
            }
          }
          if (-not $cand) { throw "Could not find a crate that builds layer_win.dll." }
          Write-Host "Building DLL crate at: $($cand.FullName)"
          cargo build --manifest-path "$($cand.FullName)" --target x86_64-pc-windows-msvc

      # ---- Find which package contains bin target "mirrord"; set MIRRORD_LAYER_FILE ----
      - name: Locate package for bin "mirrord" + set MIRRORD_LAYER_FILE
        run: |
          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg = $meta.packages | Where-Object {
            $_.targets | Where-Object { ($_."kind" -contains 'bin') -and ($_.name -eq 'mirrord') }
          } | Select-Object -First 1
          if (-not $pkg) {
            $names = ($meta.packages | ForEach-Object name) -join ', '
            throw "No bin target named 'mirrord' found. Workspace packages: $names"
          }
          "MIRRORD_PKG=$($pkg.name)" | Out-File -FilePath $env:GITHUB_ENV -Append

          # Absolute path to the built DLL (Debug)
          $dllAbs = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\layer_win.dll'
          "MIRRORD_LAYER_FILE=$dllAbs" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Will build bin 'mirrord' from package: $($pkg.name)"
          Write-Host "MIRRORD_LAYER_FILE=$dllAbs"

      - name: Build mirrord (bin)
        run: cargo build -p "$env:MIRRORD_PKG" --bin mirrord --target x86_64-pc-windows-msvc

      # ---- Export SignTool path and verify artifacts exist ----
      - name: Export SignTool path + verify artifacts
        run: |
          # Pin to the path you confirmed exists
          $signtool = 'C:\Program Files (x86)\Windows Kits\10\bin\10.0.26100.0\x64\signtool.exe'
          if (-not (Test-Path $signtool)) {
            # Fallback search if SDK version changes
            $found = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe" -ErrorAction SilentlyContinue |
              Sort-Object FullName -Descending | Select-Object -First 1
            if ($found) { $signtool = $found.FullName }
          }
          if (-not (Test-Path $signtool)) { throw "SignTool not found." }
          "SIGNTOOL=$signtool" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Using SignTool at $signtool"

          $dll = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\layer_win.dll'
          $exe = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord.exe'
          if (-not (Test-Path $dll)) { throw "DLL not found at $dll" }
          if (-not (Test-Path $exe)) { throw "EXE not found at $exe" }
          "MIRRORD_EXE=$exe" | Out-File -FilePath $env:GITHUB_ENV -Append

      # ---- DigiCert: prepare smctl credentials (requires tools installed on the VM) ----
      - name: Prepare DigiCert (smctl + creds)
        env:
          DIGICERT_API_KEY:              ${{ secrets.DIGICERT_API_KEY }}
          DIGICERT_CLIENT_CERT_PFX_B64:  ${{ secrets.DIGICERT_CLIENT_CERT_PFX_B64 }}
          DIGICERT_CLIENT_CERT_PASSWORD: ${{ secrets.DIGICERT_CLIENT_CERT_PASSWORD }}
        run: |
          $smctl = @(
            "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools\smctl.exe",
            "C:\Program Files\DigiCert\DigiCert KeyLocker Tools\smctl.exe"
          ) | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $smctl) { throw "smctl.exe not found. Install DigiCert Signing Manager/KeyLocker Tools on this runner (once)." }
          Write-Host "Using smctl at: $smctl"

          # Recreate client-auth .p12 from secret
          $p12 = Join-Path $env:RUNNER_TEMP "digicert-client-auth.p12"
          [IO.File]::WriteAllBytes($p12, [Convert]::FromBase64String($env:DIGICERT_CLIENT_CERT_PFX_B64))

          # Required env for smctl
          $env:SM_HOST = "https://clientauth.one.digicert.com"
          $env:SM_CLIENT_CERT_FILE = $p12

          # Store creds in Windows Credential Manager and (re)register KSP
          & $smctl credentials save $env:DIGICERT_API_KEY $env:DIGICERT_CLIENT_CERT_PASSWORD
          try { & $smctl windows ksp register } catch { Write-Warning $_ }

      # (Optional) Download public certificate for embedding (not strictly required with /csp+/kc)
      - name: Download signing certificate (optional)
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        run: |
          $smctl = @(
            "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools\smctl.exe",
            "C:\Program Files\DigiCert\DigiCert KeyLocker Tools\smctl.exe"
          ) | Where-Object { Test-Path $_ } | Select-Object -First 1
          $outDir = $env:RUNNER_TEMP
          & $smctl certificate download --keypair-alias $env:DIGICERT_KEYPAIR_ALIAS --format cer --out $outDir
          $cert = Get-ChildItem $outDir -Filter *.cer | Select-Object -First 1 | % FullName
          if ($cert) {
            "CODESIGN_CERT=$cert" | Out-File -FilePath $env:GITHUB_ENV -Append
            Write-Host "Using .cer: $cert"
          } else {
            Write-Host "No .cer found (signing will still work with KSP alias)."
          }

      # ---- Sign DLL + EXE via DigiCert KSP (HSM) ----
      - name: Sign artifacts (DLL + EXE)
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        run: |
          $ts = "http://timestamp.digicert.com"
          $args = @('/fd','SHA256','/td','SHA256','/tr',$ts,'/csp','DigiCert Signing Manager KSP','/kc',"$env:DIGICERT_KEYPAIR_ALIAS")
          if ($env:CODESIGN_CERT) { $args += @('/f',"$env:CODESIGN_CERT") }
          & "$env:SIGNTOOL" sign @args "$env:MIRRORD_LAYER_FILE"
          & "$env:SIGNTOOL" sign @args "$env:MIRRORD_EXE"

      - name: Verify signatures
        run: |
          & "$env:SIGNTOOL" verify /pa /all "$env:MIRRORD_LAYER_FILE"
          & "$env:SIGNTOOL" verify /pa /all "$env:MIRRORD_EXE"

