name: Windows Build + Choco and WinGet

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Version to use for Chocolatey/WinGet (e.g. 0.0.1-test2). Defaults to MIRRORD_VERSION."
        required: false
        type: string
      runner:
        description: "Runner to execute on (Spot Instances)"
        type: choice
        options: 
          - "win-build-spot-2"
          - "win-build-spot-1"
        default: "win-build-spot-2"
      gcs_msi_source:
        description: "Optional: GS URI to download MSI from (skips build). e.g. gs://mirrord-windows-builds-public/..."
        required: false
        type: string
      sign_artifacts:
        description: "Code-sign EXE & DLL & MSI (Ignored if MSI source provided)"
        type: choice
        options: ["false", "true"]
        default: "false"
      choco_publish:
        description: "Publish a Chocolatey package?"
        type: choice
        options: ["false", "true"]
        default: "false"
      winget_publish:
        description: "Update WinGet manifest (wingetcreate)?"
        type: choice
        options: ["false", "true"]
        default: "false"

  workflow_call:
    inputs:
      release_tag:
        description: "Version to use for Chocolatey/WinGet (e.g. 0.0.1-test2). Defaults to MIRRORD_VERSION."
        required: false
        type: string
      runner:
        description: "Runner to execute on"
        type: string
        default: "win-build-spot-2"
      sign_artifacts:
        description: "Code-sign EXE & DLL & MSI"
        type: string
        default: "false"
      choco_publish:
        description: "Publish a Chocolatey package?"
        type: string
        default: "false"
      winget_publish:
        description: "Update WinGet manifest (wingetcreate)?"
        type: string
        default: "false"

env:
  MSI_BUCKET_URI: gs://mirrord-windows-builds-public
  RUST_BACKTRACE: "1"
  CARGO_NET_GIT_FETCH_WITH_CLI: "true"
  MIRRORD_TELEMETRY: "false"
  LIBCLANG_PATH: "C:\\Program Files\\LLVM\\bin"
  MSI_HTTP_BASE: "https://storage.googleapis.com/mirrord-windows-builds-public"
  WINGET_PACKAGE_ID: "MetalBear.mirrord"

jobs:
  windows_build:
    runs-on: ${{ inputs.runner }}
    permissions:
      contents: write
    defaults:
      run:
        shell: pwsh
    env:
      RELEASE_TAG_INPUT: ${{ inputs.release_tag || '' }}
      SIGN_ARTIFACTS: ${{ inputs.sign_artifacts || 'false' }}
      PUBLISH_CHOCO: ${{ inputs.choco_publish || 'false' }}
      PUBLISH_WINGET: ${{ inputs.winget_publish || 'false' }}
      GCS_MSI_SOURCE: ${{ inputs.gcs_msi_source || '' }}
      CHOCO_API_KEY: ${{ secrets.CHOCO_API_KEY }}
      WINGET_TOKEN: ${{ secrets.WINGET_TOKEN }}
      GH_TOKEN: ${{ secrets.WINGET_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Toolchain info
        if: env.GCS_MSI_SOURCE == ''
        run: |
          $ErrorActionPreference = "Stop"
          whoami
          rustc -V
          cargo -V
          rustup show

      # Early sanity check that the runner account can write to C:.
      - name: Validate C write access
        run: |
          $ErrorActionPreference = "Stop"
          whoami
          $testDir = "C:\actions\workspace-test"
          New-Item -ItemType Directory -Force -Path $testDir | Out-Null
          New-Item -ItemType File -Force -Path (Join-Path $testDir "write-test.txt") -Value "ok" | Out-Null
          Remove-Item $testDir -Recurse -Force

      ###########################################################################
      # SYNC DIGICERT CERTIFICATE (Full Build Only)
      ###########################################################################
      - name: Sync DigiCert Certificate
        if: env.SIGN_ARTIFACTS == 'true' && env.GCS_MSI_SOURCE == ''
        run: |
          $ErrorActionPreference = "Stop"
          
          Write-Host "Syncing DigiCert certificate to system store..."
          
          # Prioritize MSI Paths
          $smctlPaths = @(
              "C:\Program Files\DigiCert\DigiCert Keylocker Tools\smctl.exe",
              "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools\smctl.exe",
              "C:\DigiCert\Tools\smctl.exe" 
          )
          
          $smctl = $null
          foreach ($path in $smctlPaths) {
              if (Test-Path $path) {
                  $smctl = $path
                  Write-Host "Found smctl at: $smctl"
                  break
              }
          }
          
          if (-not $smctl) {
              throw "smctl.exe not found. DigiCert Keylocker Tools may not be installed."
          }

          # Sync certificate to user store 
          & $smctl windows certsync --keypair-alias=key_1346827532 --store user
          
          if ($LASTEXITCODE -ne 0) {
              throw "Certificate sync failed with exit code $LASTEXITCODE"
          }
          
          Write-Host "Certificate synced successfully to user store."
          
          # Verify the certificate is accessible
          $certHash = "BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB"
          $cert = certutil -user -store my $certHash 2>&1
          
          if ($cert -match "Provider DLL could not be found") { throw "KSP DLL issue detected" }
          
          # Export Thumbprint specifically for SHA1 signing
          "SM_CLIENT_CERT_THUMBPRINT=$certHash" | Out-File -Append -FilePath $env:GITHUB_ENV

      ###########################################################################
      # PREPARE ARTIFACTS (Full Build Only)
      ###########################################################################
      
      - name: Prepare e2e tests dependencies
        if: env.GCS_MSI_SOURCE == ''
        run: |
          $ErrorActionPreference = "Stop"
          $ScriptsDir = Join-Path $env:GITHUB_WORKSPACE "scripts"
          & "$ScriptsDir\win_build_test_apps.ps1"

      # Ensure Python deps are present for the Flask test apps.
      - name: Ensure Python test deps (flask/uvicorn/fastapi)
        if: env.GCS_MSI_SOURCE == ''
        run: |
          $ErrorActionPreference = "Stop"
          $py = Get-Command py -ErrorAction SilentlyContinue
          if (-not $py) {
            throw "py launcher not found; ensure Python is installed."
          }
          py -3 -m pip install --upgrade pip
          py -3 -m pip install --upgrade flask uvicorn fastapi
          py -3 -c "import flask, uvicorn, fastapi; print('flask:', flask.__version__); print('uvicorn:', uvicorn.__version__); print('fastapi:', fastapi.__version__)"

      - name: Debug Python environment
        if: env.GCS_MSI_SOURCE == ''
        run: |
          $ErrorActionPreference = "Stop"
          py -3 -c "import sys, site; print('exe:', sys.executable); print('version:', sys.version); print('sys.path:'); [print(' ', p) for p in sys.path]; print('USER_SITE:', site.getusersitepackages()); print('USER_BASE:', site.getuserbase())"
          py -3 -m pip show flask uvicorn fastapi
          py -3 -m pip list

      - name: Build
        if: env.GCS_MSI_SOURCE == ''
        id: prep
        run: |
          $ErrorActionPreference = "Stop"

          function Set-Env([string]$k,[string]$v) {
            "$k=$v" | Out-File -Append -FilePath $env:GITHUB_ENV
          }

          $Target = "x86_64-pc-windows-msvc"
          $DbgDir = Join-Path $env:GITHUB_WORKSPACE "target\$Target\debug"
          $RelDir = Join-Path $env:GITHUB_WORKSPACE "target\$Target\release"
          $Tmp    = Join-Path $env:RUNNER_TEMP "prep"
          New-Item -ItemType Directory -Force -Path $Tmp | Out-Null

          $shouldSign = [System.String]::Equals($env:SIGN_ARTIFACTS, "true", "InvariantCultureIgnoreCase")

          rustup target add $Target

          cargo build -p mirrord-layer-win --target $Target
          $dll = Join-Path $DbgDir "mirrord_layer_win.dll"
          if (-not (Test-Path $dll)) {
            $dll = Join-Path $RelDir "mirrord_layer_win.dll"
          }
          if (-not (Test-Path $dll)) {
            throw "DLL not found"
          }

          if ($shouldSign) {
            Write-Host "Signing DLL..."
            & signtool.exe sign /sha1 $env:SM_CLIENT_CERT_THUMBPRINT /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$dll"
          }

          $env:MIRRORD_LAYER_FILE = $dll

          cargo build -p mirrord --bin mirrord --target $Target
          $exe = Join-Path $DbgDir "mirrord.exe"
          if (-not (Test-Path $exe)) {
            $exe = Join-Path $RelDir "mirrord.exe"
          }
          if (-not (Test-Path $exe)) {
            throw "EXE not found"
          }

          if ($shouldSign) {
            Write-Host "Signing EXE..."
            & signtool.exe sign /sha1 $env:SM_CLIENT_CERT_THUMBPRINT /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$exe"
          }

          Set-Env "MIRRORD_EXE" $exe
          Set-Env "MIRRORD_LAYER_FILE" $dll

          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg  = $meta.packages | Where-Object { $_.name -eq "mirrord" } | Select-Object -First 1
          Set-Env "MIRRORD_VERSION" $pkg.version
          
          # If RELEASE_TAG_INPUT is set, use it as RELEASE_TAG, otherwise default to package version
          if ($env:RELEASE_TAG_INPUT) {
             Set-Env "RELEASE_TAG" $env:RELEASE_TAG_INPUT
          } else {
             Set-Env "RELEASE_TAG" $pkg.version
          }

      ###########################################################################
      # ENSURE WIX TOOLSET IS INSTALLED (Full Build Only)
      ###########################################################################
      - name: Ensure WiX Toolset
        if: env.GCS_MSI_SOURCE == ''
        run: |
          $ErrorActionPreference = "Stop"

          function Write-Env([string]$k,[string]$v) {
            "$k=$v" | Out-File -Append -FilePath $env:GITHUB_ENV
          }

          function Find-Candle {
            param([switch]$DeepSearch)

            Write-Host "Searching for WiX candle.exe in known locations..."
            
            # DEBUG: List Program Files based paths to help diagnosis
            Get-ChildItem -Path "$Env:ProgramFiles(x86)" -Filter "WiX*" -ErrorAction SilentlyContinue | ForEach-Object {
                Write-Host "DEBUG: Found WiX dir: $($_.FullName)"
            }

            $candidateDirs = @()

            if ($Env:ChocolateyInstall -and (Test-Path $Env:ChocolateyInstall)) {
              $candidateDirs += @(
                (Join-Path $Env:ChocolateyInstall "lib\wixtoolset\tools\bin"),
                (Join-Path $Env:ChocolateyInstall "tools"),
                (Join-Path $Env:ChocolateyInstall "bin")
              )
            }

            $candidateDirs += @(
              "$Env:ProgramFiles(x86)\WiX Toolset v3.14\bin",
              "$Env:ProgramFiles(x86)\WiX Toolset v3.13\bin",
              "$Env:ProgramFiles(x86)\WiX Toolset v3.12\bin",
              "$Env:ProgramFiles(x86)\WiX Toolset v3.11\bin",
              "$Env:ProgramFiles\WiX Toolset v3.14\bin",
              "$Env:ProgramFiles\WiX Toolset v3.13\bin",
              "$Env:ProgramFiles\WiX Toolset v3.12\bin",
              "$Env:ProgramFiles\WiX Toolset v3.11\bin",
              "$Env:ProgramData\chocolatey\lib\wixtoolset\tools\bin",
              "$Env:ProgramData\chocolatey\bin"
            )

            $candidateDirs = $candidateDirs | Where-Object { $_ -and (Test-Path $_) }

            foreach ($dir in $candidateDirs) {
              $candlePath = Join-Path $dir "candle.exe"
              if (Test-Path $candlePath) {
                Write-Host "Found candle.exe at $candlePath."
                return $candlePath
              }
            }

            return $null
          }

          $candleCmd  = Get-Command candle.exe -ErrorAction SilentlyContinue
          $candlePath = $null

          if ($candleCmd) {
            $candlePath = $candleCmd.Source
          } else {
            $candlePath = Find-Candle
          }

          if (-not $candlePath) {
             Write-Host "Installing WiX Toolset via Chocolatey..."
             choco install wixtoolset -y
             $candlePath = Find-Candle
          }

          if (-not $candlePath) {
            throw "Could not find candle.exe even after choco install."
          }

          $binDir = Split-Path -Parent $candlePath
          $lightPath = Join-Path $binDir "light.exe"

          if (-not (Test-Path $lightPath)) {
            throw "Found candle.exe at $candlePath but light.exe is missing from $binDir"
          }

          Write-Env "CANDLE_EXE" $candlePath
          Write-Env "LIGHT_EXE"  $lightPath

      - name: Build MSI
        if: env.GCS_MSI_SOURCE == ''
        run: |
          $ErrorActionPreference = "Stop"

          if (-not $env:CANDLE_EXE -or -not (Test-Path $env:CANDLE_EXE)) {
            throw "CANDLE_EXE env var is not set or invalid."
          }
          if (-not $env:LIGHT_EXE -or -not (Test-Path $env:LIGHT_EXE)) {
            throw "LIGHT_EXE env var is not set or invalid."
          }

          $candle = $env:CANDLE_EXE
          $light  = $env:LIGHT_EXE

          Write-Host "Using candle.exe at: $candle"
          Write-Host "Using light.exe  at: $light"

          $Root = "C:\wix\mirrord"
          New-Item -ItemType Directory -Force -Path $Root | Out-Null

          Copy-Item $env:MIRRORD_EXE          "$Root\mirrord.exe"          -Force
          Copy-Item $env:MIRRORD_LAYER_FILE   "$Root\mirrord_layer_win.dll" -Force
          Copy-Item "$env:GITHUB_WORKSPACE\mirrord\cli\wix\mirrord.ico"    "$Root\mirrord.ico"     -Force
          Copy-Item "$env:GITHUB_WORKSPACE\mirrord\cli\wix\License.rtf"    "$Root\License.rtf"     -Force
          Copy-Item "$env:GITHUB_WORKSPACE\mirrord\cli\wix\main.wxs"       "$Root\main.wxs"        -Force

          # Compute raw version from tag, input, or MIRRORD_VERSION
          $rawVersion = $null
          if ("$env:GITHUB_REF".StartsWith("refs/tags/")) {
            $rawVersion = "$env:GITHUB_REF".Substring(10)
          } elseif ($env:RELEASE_TAG_INPUT) {
            $rawVersion = $env:RELEASE_TAG_INPUT
          } else {
            $rawVersion = $env:MIRRORD_VERSION
          }

          if ($rawVersion -and $rawVersion.StartsWith("v")) {
            $rawVersion = $rawVersion.Substring(1)
          }

          if ($rawVersion) {
            # Strip any non-numeric suffix (e.g. "3.174.0-run895-53f857b" -> "3.174.0")
            $match = [Regex]::Match($rawVersion, '^[0-9]+(\.[0-9]+){0,3}')
            if ($match.Success) {
              $clean = $match.Value
            } else {
              Write-Warning "Could not parse numeric version from '$rawVersion', falling back to 1.0.0.0"
              $clean = '1.0.0'
            }

            $parts = $clean.Split('.')
            while ($parts.Count -lt 4) {
              $parts += '0'
            }

            $msiVersion = ($parts[0..3] -join '.')
            Write-Host "Setting MSI Product Version to: $msiVersion (from raw '$rawVersion', clean '$clean')"
          } else {
            $msiVersion = "1.0.0.0"
            Write-Warning "No version found at all, using default: $msiVersion"
          }

          $wxsPath    = "$Root\main.wxs"
          $wxsContent = Get-Content $wxsPath -Raw -Encoding UTF8
          $wxsContent = $wxsContent -creplace '\bVersion="[^"]*"', "Version=`"$msiVersion`""

          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          [System.IO.File]::WriteAllText($wxsPath, $wxsContent, $utf8NoBom)
          Write-Host "Updated Product Version in main.wxs to $msiVersion"

          "MSI_VERSION=$msiVersion" | Out-File -Append -FilePath $env:GITHUB_ENV

          $Obj = "$Root\main.wixobj"
          $Msi = "$Root\mirrord.msi"

          if (Test-Path $Msi) {
            Remove-Item $Msi -Force
          }

          & $candle -nologo -v "$Root\main.wxs" -out $Obj
          & $light  -nologo -v $Obj -out $Msi -ext WixUIExtension -sval

          if (-not (Test-Path $Msi)) {
            throw "MSI not produced"
          }

          "MSI_PATH=$Msi" | Out-File -Append -FilePath $env:GITHUB_ENV

      ###########################################################################
      # SIGN MSI (optional) (Full Build Only)
      ###########################################################################
      - name: Sign MSI
        if: env.SIGN_ARTIFACTS == 'true' && env.GCS_MSI_SOURCE == ''
        run: |
          $ErrorActionPreference = "Stop"

          $msi = $env:MSI_PATH
          if (-not (Test-Path $msi)) {
            throw "MSI_PATH '$msi' does not exist."
          }

          & signtool.exe sign /sha1 $env:SM_CLIENT_CERT_THUMBPRINT `
              /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$msi"

      ###########################################################################
      # UPLOAD MSI TO PUBLIC GCS BUCKET (Full Build Only)
      ###########################################################################
      - name: Upload MSI to GCS
        # Only upload if we are releasing (tag provided) or publishing to Choco/WinGet
        if: env.GCS_MSI_SOURCE == '' && ( env.RELEASE_TAG_INPUT != '' || env.PUBLISH_WINGET == 'true' || env.PUBLISH_CHOCO == 'true' )
        run: |
          $ErrorActionPreference = "Stop"

          $msi = $env:MSI_PATH
          if (-not (Test-Path $msi)) {
            throw "MSI_PATH '$msi' does not exist."
          }

          $runId   = $env:GITHUB_RUN_ID
          $refName = $env:GITHUB_REF_NAME
          if (-not $refName) {
            $refName = "unknown"
          }

          $refSafe    = $refName -replace '[^A-Za-z0-9\.\-]', '_'
          $bucketBase = $env:MSI_BUCKET_URI.TrimEnd('/')
          $destFolder = "$bucketBase/$refSafe/run-$runId"
          $destUri    = "$destFolder/mirrord.msi"

          Write-Host "Uploading MSI to $destUri"
          gcloud --quiet storage cp $msi $destUri

          "MSI_GCS_REF_SAFE=$refSafe" | Out-File -Append -FilePath $env:GITHUB_ENV
          "MSI_GCS_RUN_ID=$runId"     | Out-File -Append -FilePath $env:GITHUB_ENV
          "MSI_GCS_URI=$destUri"      | Out-File -Append -FilePath $env:GITHUB_ENV

      ###########################################################################
      # UPLOAD TO GITHUB RELEASE (Full Build Only)
      ###########################################################################
      - name: Generate Checksums
        if: env.GCS_MSI_SOURCE == '' && env.RELEASE_TAG_INPUT != '' && github.event_name != 'pull_request'
        run: |
           $exe = $env:MIRRORD_EXE
           $dll = $env:MIRRORD_LAYER_FILE
           
           if (Test-Path $exe) {
             (Get-FileHash $exe -Algorithm SHA256).Hash.ToLower() | Out-File -FilePath "$exe.sha256" -NoNewline -Encoding ascii
             "MIRRORD_EXE_SHA256=$exe.sha256" | Out-File -Append -FilePath $env:GITHUB_ENV
           }
           if (Test-Path $dll) {
             (Get-FileHash $dll -Algorithm SHA256).Hash.ToLower() | Out-File -FilePath "$dll.sha256" -NoNewline -Encoding ascii
             "MIRRORD_LAYER_SHA256=$dll.sha256" | Out-File -Append -FilePath $env:GITHUB_ENV
           }

      - name: Upload artifacts to Release
        if: env.GCS_MSI_SOURCE == '' && env.RELEASE_TAG_INPUT != '' && github.event_name != 'pull_request'
        uses: metalbear-co/action-gh-release@ab50eebb6488051c6788d97fa95232267c6a4e23
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          files: |
            ${{ env.MSI_PATH }}
            ${{ env.MIRRORD_EXE }}
            ${{ env.MIRRORD_LAYER_FILE }}
            ${{ env.MIRRORD_EXE_SHA256 }}
            ${{ env.MIRRORD_LAYER_SHA256 }}

      ###########################################################################
      # DOWNLOAD MODE (From GCS Source)
      ###########################################################################
      - name: Download Artifacts from GCS
        if: env.GCS_MSI_SOURCE != ''
        run: |
          $ErrorActionPreference = "Stop"
          $sourceMsi = $env:GCS_MSI_SOURCE
          Write-Host "Downloading MSI from: $sourceMsi"
          
          # Use same Root as full build for consistency
          $Root = "C:\wix\mirrord"
          New-Item -ItemType Directory -Force -Path $Root | Out-Null
          
          gcloud storage cp "$sourceMsi" "$Root\mirrord.msi"
          if (-not (Test-Path "$Root\mirrord.msi")) { throw "Failed to download MSI from $sourceMsi" }
          
          "MSI_PATH=$Root\mirrord.msi" | Out-File -Append -FilePath $env:GITHUB_ENV
          
          # Compute HTTP URL from GCS URI
          # E.g. gs://mirrord-windows-builds-public/3.180.0/... -> https://storage.googleapis.com/mirrord-windows-builds-public/3.180.0/...
          if ($sourceMsi -match "^gs://(.+)$") {
             $path = $matches[1]
             $url = "https://storage.googleapis.com/$path"
             "MSI_DOWNLOAD_URL=$url" | Out-File -Append -FilePath $env:GITHUB_ENV
             Write-Host "Computed MSI Download URL: $url"
          } else {
             Write-Warning "Could not compute HTTP URL from source: $sourceMsi"
          }
          
          # Ensure RELEASE_TAG is set for packaging steps
          if ($env:RELEASE_TAG_INPUT) {
             "RELEASE_TAG=$env:RELEASE_TAG_INPUT" | Out-File -Append -FilePath $env:GITHUB_ENV
          } else {
             Write-Warning "RELEASE_TAG_INPUT not provided. Defaulting RELEASE_TAG to '0.0.0-downloaded'"
             "RELEASE_TAG=0.0.0-downloaded" | Out-File -Append -FilePath $env:GITHUB_ENV
          }

      ###########################################################################
      # COMPUTE MSI DOWNLOAD URL (From Build / Upload)
      ###########################################################################
      - name: Compute MSI Download URL (From Build)
        # Depends on Upload MSI to GCS (Running only if NOT downloading from source)
        if: env.GCS_MSI_SOURCE == '' && (env.RELEASE_TAG_INPUT != '' || env.PUBLISH_WINGET == 'true' || env.PUBLISH_CHOCO == 'true')
        run: |
          $ErrorActionPreference = "Stop"
          
          $gcsUri = $env:MSI_GCS_URI
          if (-not $gcsUri) {
             throw "MSI_GCS_URI is not set. Ensure 'Upload MSI to GCS' step ran successfully."
          }
          
          # Convert gs://bucket/path/to/msi -> https://storage.googleapis.com/bucket/path/to/msi
          if ($gcsUri -match "^gs://(.+)$") {
             $path = $matches[1]
             $url = "https://storage.googleapis.com/$path"
          } else {
             throw "Unexpected GCS URI format: $gcsUri"
          }
          
          Write-Host "Computed MSI Download URL: $url"
          "MSI_DOWNLOAD_URL=$url" | Out-File -Append -FilePath $env:GITHUB_ENV
          
          # Verify URL accessibility
          try {
             $resp = Invoke-WebRequest -Uri $url -Method Head -ErrorAction Stop
             Write-Host "URL Verification: OK ($($resp.StatusCode))"
          } catch {
             Write-Warning "URL Verification FAILED: $($_.Exception.Message). Publishing may fail."
          }

      ###########################################################################
      # INSTALL .NET RUNTIME FOR WINGETCREATE
      ###########################################################################
      - name: Install .NET runtime for wingetcreate
        # Skip on forks without WINGET_TOKEN so they don't fail
        if: ${{ github.event_name != 'pull_request' && env.PUBLISH_WINGET == 'true' }}
        uses: actions/setup-dotnet@v4
        env:
          DOTNET_INSTALL_DIR: ${{ runner.temp }}\dotnet
        with:
          dotnet-version: '8.0.x'

      ###########################################################################
      # UPDATE WinGet MANIFEST (wingetcreate)
      ###########################################################################
      - name: Update WinGet manifest (wingetcreate)
        # Force run to debug why it was skipping. We check token inside script anyway.
        if: ${{ github.event_name != 'pull_request' && env.PUBLISH_WINGET == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"
          $packageId = $env:WINGET_PACKAGE_ID
          if (-not $packageId) {
            throw "WINGET_PACKAGE_ID env var is not set."
          }
          $version = $env:RELEASE_TAG
          if (-not $version) {
            throw "RELEASE_TAG env var is not set."
          }
          $installerUrl = $env:MSI_DOWNLOAD_URL
          if (-not $installerUrl) {
            throw "MSI_DOWNLOAD_URL env var is not set."
          }
          $gitToken = $env:WINGET_TOKEN
          if (-not $gitToken) {
            throw "env.WINGET_TOKEN is not configured in this repo."
          }

          Write-Host "Updating WinGet manifest for package '$packageId' version '$version'"
          Write-Host "Installer URL: $installerUrl"

          # Download latest single-file wingetcreate.exe
          Invoke-WebRequest https://aka.ms/wingetcreate/latest -OutFile wingetcreate.exe

          # Run wingetcreate update and capture output
          $args = @(
            "update", $packageId,
            "--version", $version,
            "--display-version", $version,
            "--urls", $installerUrl,
            "--submit",
            "--token", $gitToken
          )

          Write-Host "Running: wingetcreate.exe $($args -join ' ')"
          $output = & .\wingetcreate.exe @args 2>&1
          $exitCode = $LASTEXITCODE
          $output | ForEach-Object { Write-Host $_ }

          if ($exitCode -ne 0) {
            if ($output -match "was not found") {
              Write-Warning "WinGet package '$packageId' was not found in microsoft/winget-pkgs. Skipping update (non-fatal)."
              Write-Warning "To create the initial package, run 'wingetcreate new' manually and submit the first PR."
              exit 0
            } else {
              throw "wingetcreate update failed with exit code $exitCode"
            }
          }

      - name: Skip WinGet publish (missing token)
        if: ${{ env.PUBLISH_WINGET == 'true' && (github.event_name == 'pull_request' || env.WINGET_TOKEN == '') }}
        run: echo "Skipping WinGet publish because WINGET_TOKEN is not available (expected on forks or PRs)."

      ###########################################################################
      # CHOCOLATEY PACKAGE BUILD & PUBLISH
      ###########################################################################

      - name: Build Chocolatey package
        if: ${{ env.PUBLISH_CHOCO == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"
          if (-not $env:MSI_PATH -or -not (Test-Path $env:MSI_PATH)) {
            throw "MSI_PATH is not set or file does not exist. Cannot build Chocolatey package."
          }
          if (-not $env:RELEASE_TAG) {
            throw "RELEASE_TAG is not set. Ensure 'Compute release tag' ran successfully."
          }
          $pkgRoot  = Join-Path $env:RUNNER_TEMP "choco"
          $toolsDir = Join-Path $pkgRoot "tools"
          if (Test-Path $pkgRoot) {
            Remove-Item $pkgRoot -Recurse -Force
          }
          New-Item -ItemType Directory -Force -Path $toolsDir | Out-Null
          # Copy MSI into tools directory
          Copy-Item $env:MSI_PATH (Join-Path $toolsDir "mirrord.msi") -Force
          # LICENSE.txt (required when shipping binaries)
          $licenseSource = Join-Path $env:GITHUB_WORKSPACE 'LICENSE'
          $licenseDest   = Join-Path $toolsDir 'LICENSE.txt'
          if (Test-Path $licenseSource) {
            Copy-Item $licenseSource $licenseDest -Force
          } else {
            Write-Warning "LICENSE file not found at $licenseSource; Chocolatey expects LICENSE.txt alongside binaries."
          }
          # VERIFICATION.txt (required when shipping binaries)
          $verificationPath = Join-Path $toolsDir 'VERIFICATION.txt'
          $hash = Get-FileHash $env:MSI_PATH -Algorithm SHA256
          $verificationLines = @()
          $verificationLines += 'VERIFICATION'
          $verificationLines += '------------'
          $verificationLines += ''
          $verificationLines += '1. Download the mirrord MSI from the official source:'
          $verificationLines += '   https://github.com/metalbear-co/mirrord/releases'
          $verificationLines += ''
          $verificationLines += '2. Verify the SHA256 checksum of the downloaded file matches:'
          $verificationLines += "   $($hash.Hash)"
          $verificationLines += ''
          $verificationLines += 'This installer is built from the source at:'
          $verificationLines += '   https://github.com/metalbear-co/mirrord'
          $verificationLines | Set-Content -Encoding UTF8 -Path $verificationPath
          $nuspecPath = Join-Path $pkgRoot "mirrord.nuspec"
          $version    = $env:RELEASE_TAG
          $releaseNotesUrl = "https://github.com/metalbear-co/mirrord/releases/tag/$version"
          $nuspecLines = @()
          $nuspecLines += '<?xml version="1.0"?>'
          $nuspecLines += '<package xmlns="http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd">'
          $nuspecLines += '  <metadata>'
          $nuspecLines += '    <id>mirrord</id>'
          $nuspecLines += "    <version>$version</version>"
          $nuspecLines += '    <title>mirrord (Kubernetes dev tool)</title>'
          $nuspecLines += '    <summary>Run local code in the context of your Kubernetes environment.</summary>'
          $nuspecLines += '    <authors>MetalBear</authors>'
          $nuspecLines += '    <owners>MetalBear</owners>'
          $nuspecLines += '    <licenseUrl>https://github.com/metalbear-co/mirrord/blob/main/LICENSE</licenseUrl>'
          $nuspecLines += '    <projectUrl>https://github.com/metalbear-co/mirrord</projectUrl>'
          $nuspecLines += '    <packageSourceUrl>https://github.com/metalbear-co/mirrord</packageSourceUrl>'
          $nuspecLines += '    <projectSourceUrl>https://github.com/metalbear-co/mirrord</projectSourceUrl>'
          $nuspecLines += '    <docsUrl>https://mirrord.dev</docsUrl>'
          $nuspecLines += '    <bugTrackerUrl>https://github.com/metalbear-co/mirrord/issues</bugTrackerUrl>'
          $nuspecLines += '    <iconUrl>https://raw.githubusercontent.com/metalbear-co/mirrord/main/assets/icon.png</iconUrl>'
          $nuspecLines += '    <requireLicenseAcceptance>false</requireLicenseAcceptance>'
          $nuspecLines += '    <description>mirrord lets you run local code in the context of your cloud environment (Kubernetes).</description>'
          $nuspecLines += "    <releaseNotes>$releaseNotesUrl</releaseNotes>"
          $nuspecLines += '    <tags>mirrord kubernetes debugging cloud</tags>'
          $nuspecLines += '  </metadata>'
          $nuspecLines += '  <files>'
          $nuspecLines += '    <file src="tools\**" target="tools" />'
          $nuspecLines += '  </files>'
          $nuspecLines += '</package>'
          $nuspecLines | Set-Content -Encoding UTF8 -Path $nuspecPath
          $installScript = Join-Path $toolsDir "chocolateyinstall.ps1"
          # single-quoted strings so $packageName / $msiPath stay literal in the script
          $installLines = @()
          $installLines += '$ErrorActionPreference = ''Stop'''
          $installLines += ''
          $installLines += '$packageName = ''mirrord'''
          $installLines += '$toolsDir    = Split-Path -Parent $MyInvocation.MyCommand.Definition'
          $installLines += '$msiPath     = Join-Path $toolsDir ''mirrord.msi'''
          $installLines += ''
          $installLines += 'Install-ChocolateyInstallPackage -PackageName $packageName -FileType ''msi'' -SilentArgs ''/qn /norestart'' -ValidExitCodes @(0, 3010) -File $msiPath'
          $installLines | Set-Content -Encoding UTF8 -Path $installScript
          # Ensure choco is available
          if (-not (Get-Command choco.exe -ErrorAction SilentlyContinue)) {
            throw "choco.exe not found on PATH. Ensure Chocolatey is installed on this runner."
          }
          choco pack $nuspecPath --outputdirectory $pkgRoot
          $nupkg = Get-ChildItem $pkgRoot -Filter "mirrord.$version.nupkg" -File -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $nupkg) {
            $nupkg = Get-ChildItem $pkgRoot -Filter "mirrord*.nupkg" -File | Select-Object -First 1
          }
          if (-not $nupkg) {
            throw "Failed to find generated mirrord nupkg in $pkgRoot"
          }
          "CHOCO_NUPKG_PATH=$($nupkg.FullName)" | Out-File -Append -FilePath $env:GITHUB_ENV
          Write-Host "Built Chocolatey package: $($nupkg.FullName)"

      - name: Push Chocolatey package
        # Skip on forks without CHOCO_API_KEY so they don't fail
        if: ${{ env.PUBLISH_CHOCO == 'true' && env.CHOCO_API_KEY != '' }}
        env:
          CHOCO_API_KEY: ${{ env.CHOCO_API_KEY }}
        run: |
          $ErrorActionPreference = "Stop"
          if (-not $env:CHOCO_NUPKG_PATH -or -not (Test-Path $env:CHOCO_NUPKG_PATH)) {
            throw "CHOCO_NUPKG_PATH is not set or file does not exist. Cannot push package."
          }
          if (-not $env:CHOCO_API_KEY) {
            throw "CHOCO_API_KEY is not set. Configure the repository secret 'CHOCO_API_KEY' with your Chocolatey API key."
          }
          Write-Host "Pushing Chocolatey package $env:CHOCO_NUPKG_PATH to Chocolatey.org..."
          choco push $env:CHOCO_NUPKG_PATH --api-key $env:CHOCO_API_KEY --source "https://push.chocolatey.org/"

      - name: Skip Chocolatey publish (missing key)
        if: ${{ env.PUBLISH_CHOCO == 'true' && env.CHOCO_API_KEY == '' }}
        run: echo "Skipping Chocolatey publish because CHOCO_API_KEY is not available (expected on forks)."

      ###########################################################################
      # SUMMARY
      ###########################################################################

      - name: Summary
        if: always()
        run: |
          Write-Host "MSI (local):       $env:MSI_PATH"
          Write-Host "MSI Version:       $env:MSI_VERSION"
          Write-Host "MSI (GCS URI):     $env:MSI_GCS_URI"
          Write-Host "EXE:               $env:MIRRORD_EXE"
          Write-Host "DLL:               $env:MIRRORD_LAYER_FILE"
          Write-Host "Choco package:     $env:CHOCO_NUPKG_PATH"
          Write-Host "MSI HTTP URL:      $env:MSI_DOWNLOAD_URL"
          Write-Host "Publish Choco:     $env:PUBLISH_CHOCO"
          Write-Host "Publish WinGet:    $env:PUBLISH_WINGET"