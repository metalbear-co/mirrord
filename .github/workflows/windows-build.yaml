name: Build PR 3536 (Windows, self-hosted, minimal)

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  build:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout PR 3536 (merge ref)
        uses: actions/checkout@v4
        with:
          ref: refs/pull/3536/merge
          fetch-depth: 0
          submodules: recursive

      # Rust bootstrap (idempotent for service account)
      - name: Ensure Rust toolchain
        run: |
          $cargo = Get-Command cargo.exe -ErrorAction SilentlyContinue
          if (-not $cargo) {
            $env:CARGO_HOME  = "$env:RUNNER_TEMP\.cargo"
            $env:RUSTUP_HOME = "$env:RUNNER_TEMP\.rustup"
            $installer = "$env:RUNNER_TEMP\rustup-init.exe"
            Invoke-WebRequest -Uri https://win.rustup.rs/x86_64 -OutFile $installer
            & $installer -y --default-host x86_64-pc-windows-msvc --profile minimal
            $env:PATH = "$env:CARGO_HOME\bin;$env:PATH"
          }
          rustup --version
          cargo --version

      - name: Add Rust MSVC target
        run: rustup target add x86_64-pc-windows-msvc

      - name: Build mirrord-layer-win (DLL)
        run: cargo build -p mirrord-layer-win --target x86_64-pc-windows-msvc

      - name: Locate package for bin "mirrord" + set MIRRORD_LAYER_FILE
        run: |
          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg = $meta.packages | Where-Object {
            $_.targets | Where-Object { ($_."kind" -contains 'bin') -and ($_.name -eq 'mirrord') }
          } | Select-Object -First 1
          if (-not $pkg) {
            $names = ($meta.packages | ForEach-Object name) -join ', '
            throw "No bin target named 'mirrord' found. Workspace packages: $names"
          }
          "MIRRORD_PKG=$($pkg.name)" | Out-File -FilePath $env:GITHUB_ENV -Append

          $dll = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord_layer_win.dll'
          "MIRRORD_LAYER_FILE=$dll" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Will build bin 'mirrord' from package: $($pkg.name)"
          Write-Host "MIRRORD_LAYER_FILE=$dll"

      - name: Build mirrord (EXE)
        run: cargo build -p "$env:MIRRORD_PKG" --bin mirrord --target x86_64-pc-windows-msvc

      - name: Export SignTool path (pinned)
        shell: pwsh
        run: |
          $signtool = 'C:\Program Files (x86)\Windows Kits\10\bin\10.0.26100.0\x64\signtool.exe'
          if (-not (Test-Path $signtool)) { 
            $found = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe" -ErrorAction SilentlyContinue |
              Sort-Object FullName -Descending | Select-Object -First 1
            if ($found) { $signtool = $found.FullName }
          }
          if (-not (Test-Path $signtool)) { throw "SignTool not found." }
          "SIGNTOOL=$signtool" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Using SignTool at $signtool"

          # make sure smctl can invoke 'signtool' by name
          $signdir = Split-Path $signtool -Parent
          "PATH=$signdir;$env:PATH" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Prepended to PATH: $signdir"

          # Absolute artifact paths
          $dll = "$env:MIRRORD_LAYER_FILE"
          $exe = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord.exe'
          if (-not (Test-Path $dll)) { throw "DLL not found at $dll" }
          if (-not (Test-Path $exe)) { throw "EXE not found at $exe" }
          "MIRRORD_EXE=$exe" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "DLL: $dll"
          Write-Host "EXE: $exe"


      # DigiCert prep: smctl path, services, creds, KSP registration
      - name: Prepare DigiCert (smctl + services + creds + KSP)
        env:
          DIGICERT_API_KEY:              ${{ secrets.DIGICERT_API_KEY }}
          DIGICERT_CLIENT_CERT_PFX_B64:  ${{ secrets.DIGICERT_CLIENT_CERT_PFX_B64 }}
          DIGICERT_CLIENT_CERT_PASSWORD: ${{ secrets.DIGICERT_CLIENT_CERT_PASSWORD }}
        run: |
          $smctl = @(
            "C:\Program Files\DigiCert\DigiCert Keylocker Tools\smctl.exe",
            "C:\Program Files\DigiCert\DigiCert KeyLocker Tools\smctl.exe",
            "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools\smctl.exe"
          ) | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $smctl) { throw "smctl.exe not found. Install Keylocker Windows Clients." }
          "SMCTL=$smctl" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Using smctl at: $smctl"

          # Make sure DigiCert services are up (names vary; start anything under 'DigiCert*')
          Get-Service -Name 'DigiCert*' -ErrorAction SilentlyContinue | ForEach-Object {
            if ($_.Status -ne 'Running') { Start-Service $_.Name }
          }
          Get-Service -Name 'DigiCert*' -ErrorAction SilentlyContinue | Format-Table -AutoSize

          # Rehydrate client-auth .p12 and save creds for THIS account
          $p12 = Join-Path $env:RUNNER_TEMP "client-auth.p12"
          [IO.File]::WriteAllBytes($p12, [Convert]::FromBase64String($env:DIGICERT_CLIENT_CERT_PFX_B64))
          $env:SM_HOST = "https://clientauth.one.digicert.com"
          $env:SM_CLIENT_CERT_FILE = $p12

          & $smctl credentials clear 2>$null
          & $smctl credentials save $env:DIGICERT_API_KEY $env:DIGICERT_CLIENT_CERT_PASSWORD

          # Register KSP and verify provider exists
          & $smctl windows ksp register
          $prov = (certutil -csplist | Select-String -Pattern 'DigiCert.*KSP' -SimpleMatch:$false | Out-String).Trim()
          if (-not $prov) { throw "DigiCert KSP not registered/visible (certutil -csplist). Check install/permissions." }
          Write-Host "KSP present:`n$prov"

          Write-Host "`nKeypairs visible to this user:"
          & $smctl keypair list

      # Certsync alias → detect where cert landed; also attempt PEM→CER for file-mode signing
      - name: Certsync + detect store + export thumbprint and CER
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        run: |
          $ErrorActionPreference = 'Stop'
          $smctl = "$env:SMCTL"
          $alias = "$env:DIGICERT_KEYPAIR_ALIAS".Trim()
          if (-not (Test-Path $smctl)) { throw "smctl.exe not found at $smctl" }
          if (-not $alias) { throw "DIGICERT_KEYPAIR_ALIAS is empty." }

          # Certsync (prints alias + SHA1); capture output
          $lines = & $smctl windows certsync --keypair-alias $alias 2>&1 | Tee-Object -Variable _buf
          if ($LASTEXITCODE -ne 0) {
            throw ("certsync failed for alias '{0}'. Output:`n{1}" -f $alias, ($lines | Out-String))
          }
          $txt = ($lines | Out-String)
          $sha1 = $null
          if ($txt -match 'SHA1\s*Fingerprint:\s*([A-Fa-f0-9]+)') {
            $sha1 = $matches[1].ToUpper()
          }

          # Where did it land?
          $inUser = $false; $inMachine = $false
          if ($sha1) {
            $inUser = ($null -ne (Get-ChildItem Cert:\CurrentUser\My -ErrorAction SilentlyContinue |
                     Where-Object { ($_.Thumbprint -replace '\s','').ToUpper() -eq $sha1 } | Select-Object -First 1))
            if (-not $inUser) {
              $inMachine = ($null -ne (Get-ChildItem Cert:\LocalMachine\My -ErrorAction SilentlyContinue |
                         Where-Object { ($_.Thumbprint -replace '\s','').ToUpper() -eq $sha1 } | Select-Object -First 1))
            }
          }

          if (-not $sha1) {
            Write-Host "`nCurrentUser\My:"
            Get-ChildItem Cert:\CurrentUser\My | Select Subject,Thumbprint,NotAfter
            Write-Host "`nLocalMachine\My:"
            Get-ChildItem Cert:\LocalMachine\My | Select Subject,Thumbprint,NotAfter
            throw "Could not determine cert thumbprint after certsync."
          }

          if ($inUser) {
            "CODESIGN_SHA1=$sha1"    | Out-File -FilePath $env:GITHUB_ENV -Append
            "CODESIGN_STORE_SCOPE=U" | Out-File -FilePath $env:GITHUB_ENV -Append
            Write-Host "Using User store (CurrentUser\\My): $sha1"
          } elseif ($inMachine) {
            "CODESIGN_SHA1=$sha1"    | Out-File -FilePath $env:GITHUB_ENV -Append
            "CODESIGN_STORE_SCOPE=M" | Out-File -FilePath $env:GITHUB_ENV -Append
            Write-Host "Using Machine store (LocalMachine\\My): $sha1"
          } else {
            Write-Host "`nCurrentUser\My:"
            Get-ChildItem Cert:\CurrentUser\My | Select Subject,Thumbprint,NotAfter
            Write-Host "`nLocalMachine\My:"
            Get-ChildItem Cert:\LocalMachine\My | Select Subject,Thumbprint,NotAfter
            throw "Thumbprint $sha1 not found in either store."
          }

          # Try to also prepare a .CER for file-mode signing (PEM→CER)
          $outDir = $env:RUNNER_TEMP
          Remove-Item (Join-Path $outDir 'cert_*.*') -Force -ErrorAction SilentlyContinue
          & $smctl certificate download --keypair-alias $alias --format pem --out $outDir
          $pem = Get-ChildItem $outDir -Filter *.pem -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($pem) {
            $cerPath = [System.IO.Path]::ChangeExtension($pem.FullName, '.cer')
            certutil -decode $pem.FullName $cerPath | Out-Null
            if (Test-Path $cerPath) {
              "CODESIGN_CERT=$cerPath" | Out-File -FilePath $env:GITHUB_ENV -Append
              Write-Host "Prepared CER for file-mode signing: $cerPath"
            } else {
              Write-Warning "PEM→CER conversion failed; will rely on /sha1"
            }
          } else {
            Write-Warning "PEM download failed or not found; will rely on /sha1"
          }
      - name: DigiCert pre-sign diagnostics
        shell: pwsh
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "smctl at: $env:SMCTL"
          if (-not (Test-Path "$env:SMCTL")) { throw "smctl.exe not found at $env:SMCTL" }

          Write-Host "`n--- smctl healthcheck --tools ---"
          & "$env:SMCTL" healthcheck --tools; $hc = $LASTEXITCODE

          Write-Host "`n--- smctl keypair list (expect to see your alias) ---"
          & "$env:SMCTL" keypair list; $kp = $LASTEXITCODE

          Write-Host "`n--- smctl windows certsync --keypair-alias ---"
          & "$env:SMCTL" windows certsync --keypair-alias "$env:DIGICERT_KEYPAIR_ALIAS"; $cs = $LASTEXITCODE

          Write-Host "`n--- Provider list (should include DigiCert Software Trust Manager KSP) ---"
          certutil -csplist | findstr /I "DigiCert" || $true

          Write-Host "`n--- CurrentUser\\My store snapshot ---"
          certutil -store -user My | findstr /I /C:"Provider" /C:"Cert Hash" /C:"Subject" || $true

          Write-Host "`nDiag exit codes => healthcheck:$hc  keypair list:$kp  certsync:$cs"

      # Try file-mode first, then fallback to store-mode (/sha1); add /sm if machine store
      - name: Sign artifacts (prefer smctl; full output; self-verify)
        shell: pwsh
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        run: |
          $ErrorActionPreference = 'Stop'
          $ts    = 'http://timestamp.digicert.com'
          $alias = "$env:DIGICERT_KEYPAIR_ALIAS".Trim()
          $dll   = "$env:MIRRORD_LAYER_FILE"
          $exe   = "$env:MIRRORD_EXE"
          $ok    = $false

          function Is-Signed([string]$path) {
            $sig = Get-AuthenticodeSignature -FilePath $path
            return ($sig.Status -eq 'Valid' -or $sig.SignerCertificate)
          }

          Write-Host "=== C: smctl sign (best with KeyLocker policies) ==="
          if (-not (Test-Path "$env:SMCTL")) { throw "smctl.exe not found at $env:SMCTL" }

          # smctl internally shells out to 'signtool' -> we already put it on PATH
          & "$env:SMCTL" sign --keypair-alias "$alias" --input "$dll" --timestamp-url $ts --verbose; $rc1 = $LASTEXITCODE
          if ($rc1 -eq 0 -and -not (Is-Signed $dll)) { Write-Host "`nVerify dump:"; & "$env:SIGNTOOL" verify /v /pa "$dll"; $rc1 = 1 }

          & "$env:SMCTL" sign --keypair-alias "$alias" --input "$exe" --timestamp-url $ts --verbose; $rc2 = $LASTEXITCODE
          if ($rc2 -eq 0 -and -not (Is-Signed $exe)) { Write-Host "`nVerify dump:"; & "$env:SIGNTOOL" verify /v /pa "$exe"; $rc2 = 1 }

          if ($rc1 -eq 0 -and $rc2 -eq 0) { $ok = $true; Write-Host "smctl sign succeeded." }

          # If smctl path fails (policy/approval aside), try direct signtool with both KSP names
          if (-not $ok) {
            $signtool = "$env:SIGNTOOL"
            $providers = @(
              'DigiCert Software Trust Manager KSP',
              'DigiCert Signing Manager KSP'         # legacy name; present on your box
            )
            foreach ($ksp in $providers) {
              Write-Host "`n=== A: file-mode via $ksp (with timestamp) ==="
              & "$signtool" sign /debug /fd SHA256 /td SHA256 /tr $ts `
                /csp $ksp /kc "$alias" /f "$env:CODESIGN_CERT" "$dll"; $a1 = $LASTEXITCODE
              if ($a1 -eq 0 -and -not (Is-Signed $dll)) { & "$signtool" verify /v /pa "$dll"; $a1 = 1 }

              & "$signtool" sign /debug /fd SHA256 /td SHA256 /tr $ts `
                /csp $ksp /kc "$alias" /f "$env:CODESIGN_CERT" "$exe"; $a2 = $LASTEXITCODE
              if ($a2 -eq 0 -and -not (Is-Signed $exe)) { & "$signtool" verify /v /pa "$exe"; $a2 = 1 }

              if ($a1 -eq 0 -and $a2 -eq 0) { $ok = $true; break }

              Write-Warning "File-mode via '$ksp' failed (DLL=$a1 EXE=$a2). Trying store-mode /sha1…"
              $sha1  = "$env:CODESIGN_SHA1"
              $scope = "$env:CODESIGN_STORE_SCOPE"  # 'U' or 'M'
              if (-not $sha1) { throw "CODESIGN_SHA1 not set (certsync must export it)." }
              $common = @('/debug','/fd','SHA256','/td','SHA256','/sha1',$sha1)
              if ($scope -eq 'M') { $common = @('/sm') + $common }

              & "$signtool" sign @($common + @('/tr',$ts,$dll)); $b1 = $LASTEXITCODE
              if ($b1 -eq 0 -and -not (Is-Signed $dll)) { & "$signtool" verify /v /pa "$dll"; $b1 = 1 }
              & "$signtool" sign @($common + @('/tr',$ts,$exe)); $b2 = $LASTEXITCODE
              if ($b2 -eq 0 -and -not (Is-Signed $exe)) { & "$signtool" verify /v /pa "$exe"; $b2 = 1 }

              if ($b1 -eq 0 -and $b2 -eq 0) { $ok = $true; break }
              Write-Warning "Store-mode via '$ksp' failed (DLL=$b1 EXE=$b2)."
            }
          }

          if (-not $ok) {
            Write-Host "`n=== FINAL DIAGNOSTICS ==="
            certutil -csplist | findstr /I "DigiCert" || $true
            certutil -store -user My | findstr /I /C:"Provider" /C:"Cert Hash" /C:"Subject" || $true
            throw "Signing failed. Now that 'smctl sign' can find signtool, check if your policy requires approvals or if the service account lacks permission to use this key."
          }

          Write-Host "✅ Signing complete and verified."




      - name: Verify signatures (verbose)
        shell: pwsh
        run: |
          & "$env:SIGNTOOL" verify /v /pa "$env:MIRRORD_LAYER_FILE"
          & "$env:SIGNTOOL" verify /v /pa "$env:MIRRORD_EXE"
          Get-AuthenticodeSignature "$env:MIRRORD_LAYER_FILE" | Format-List *
          Get-AuthenticodeSignature "$env:MIRRORD_EXE"        | Format-List *
