name: Build PR 3536 (Windows, self-hosted, minimal)

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  build:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout PR 3536 (merge ref)
        uses: actions/checkout@v4
        with:
          ref: refs/pull/3536/merge
          fetch-depth: 0
          submodules: recursive

      - name: Add Rust MSVC target
        run: rustup target add x86_64-pc-windows-msvc

      - name: Build mirrod-layer-win (DLL)
        run: |
          cargo build -p mirrord-layer-win --target x86_64-pc-windows-msvc

      # Find which *package* contains the bin target named "mirrord"
      - name: Locate package for bin "mirrord" + set MIRRORD_LAYER_FILE
        run: |
          # Find the package that defines a binary target named 'mirrord'
          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg = $meta.packages | Where-Object {
            $_.targets | Where-Object { ($_."kind" -contains 'bin') -and ($_.name -eq 'mirrord') }
          } | Select-Object -First 1
          if (-not $pkg) {
            $names = ($meta.packages | ForEach-Object name) -join ', '
            throw "No bin target named 'mirrord' found. Workspace packages: $names"
          }
          # Save the package name for the next step
          "MIRRORD_PKG=$($pkg.name)" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Will build bin 'mirrord' from package: $($pkg.name)"

          # Set MIRRORD_LAYER_FILE to an *absolute* path in this workspace
          $dll = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord_layer_win.dll'
          "MIRRORD_LAYER_FILE=$dll" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "MIRRORD_LAYER_FILE=$dll"

      - name: Build mirrord
        run: cargo build -p "$env:MIRRORD_PKG" --bin mirrord --target x86_64-pc-windows-msvc

      # --- Prepare DigiCert (smctl + creds) ---
      - name: Prepare DigiCert (smctl + creds)
        env:
          DIGICERT_API_KEY:              ${{ secrets.DIGICERT_API_KEY }}
          DIGICERT_CLIENT_CERT_PFX_B64:  ${{ secrets.DIGICERT_CLIENT_CERT_PFX_B64 }}
          DIGICERT_CLIENT_CERT_PASSWORD: ${{ secrets.DIGICERT_CLIENT_CERT_PASSWORD }}
        run: |
          # Prefer the Keylocker Tools path you have installed
          $smctl = @(
            "C:\Program Files\DigiCert\DigiCert Keylocker Tools\smctl.exe",        # your install
            "C:\Program Files\DigiCert\DigiCert KeyLocker Tools\smctl.exe",        # alt casing
            "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools\smctl.exe"
          ) | Where-Object { Test-Path $_ } | Select-Object -First 1

          # Fallback: search under Program Files just in case
          if (-not $smctl) {
            $hits = @(
              Get-ChildItem "C:\Program Files\DigiCert" -Recurse -File -Filter smctl.exe -ErrorAction SilentlyContinue
              Get-ChildItem "C:\Program Files (x86)\DigiCert" -Recurse -File -Filter smctl.exe -ErrorAction SilentlyContinue
            ) | Where-Object { $_ } | Select-Object -First 1
            if ($hits) { $smctl = $hits.FullName }
          }

          if (-not $smctl) { throw "smctl.exe not found. Ensure 'Keylocker Windows Clients Installer' is installed on this runner." }
          Write-Host "Using smctl at: $smctl"

          # Recreate client-auth .p12 from secret
          $p12 = Join-Path $env:RUNNER_TEMP "digicert-client-auth.p12"
          [IO.File]::WriteAllBytes($p12, [Convert]::FromBase64String($env:DIGICERT_CLIENT_CERT_PFX_B64))

          # Required env for smctl
          $env:SM_HOST = "https://clientauth.one.digicert.com"
          $env:SM_CLIENT_CERT_FILE = $p12

          # Store creds in Windows Credential Manager and (re)register KSP
          & $smctl credentials save $env:DIGICERT_API_KEY $env:DIGICERT_CLIENT_CERT_PASSWORD
          try { & $smctl windows ksp register } catch { Write-Warning $_ }

      # --- Locate SignTool (Windows SDK) and set artifact paths ---
      - name: Export SignTool path (pinned)
        shell: pwsh
        run: |
          $signtool = 'C:\Program Files (x86)\Windows Kits\10\bin\10.0.26100.0\x64\signtool.exe'
          if (-not (Test-Path $signtool)) { throw "SignTool not found at $signtool" }
          "SIGNTOOL=$signtool" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Using SignTool at $signtool"
          # Absolute paths to your freshly built artifacts (Debug)
          $dll = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord_layer_win.dll'
          $exe = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord.exe'
          if (-not (Test-Path $dll)) { throw "DLL not found at $dll" }
          if (-not (Test-Path $exe)) { throw "EXE not found at $exe" }
          "MIRRORD_LAYER_FILE=$dll" | Out-File -FilePath $env:GITHUB_ENV -Append
          "MIRRORD_EXE=$exe"        | Out-File -FilePath $env:GITHUB_ENV -Append

      # --- (Recommended) Download public cert so SignTool can select the matching key ---
      - name: Get certificate (download or certsync fallback)
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        shell: pwsh
        run: |
          $alias = "$env:DIGICERT_KEYPAIR_ALIAS".Trim()
          if (-not $alias) { throw "DIGICERT_KEYPAIR_ALIAS is empty." }

          $smctl = "C:\Program Files\DigiCert\DigiCert Keylocker Tools\smctl.exe"
          if (-not (Test-Path $smctl)) { throw "smctl.exe not found at $smctl" }

          $outDir = $env:RUNNER_TEMP
          $certPath = Join-Path $outDir ("cert_{0}.cer" -f ($alias -replace '\D',''))
          if (Test-Path $certPath) { Remove-Item $certPath -Force }

          Write-Host "Attempting .cer download for alias '$alias'..."
          & $smctl certificate download --keypair-alias $alias --format cer --out $outDir
          $rc = $LASTEXITCODE
          $downloaded = Get-ChildItem $outDir -Filter *.cer -ErrorAction SilentlyContinue | Select-Object -First 1

          if ($rc -eq 0 -and $downloaded) {
            "CODESIGN_CERT=$($downloaded.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append
            "SIGN_MODE=file" | Out-File -FilePath $env:GITHUB_ENV -Append
            Write-Host "Downloaded certificate: $($downloaded.FullName)"
            return
          }

          Write-Warning "smctl returned $rc or no .cer file; falling back to certsync + /sha1 signing."

          # Fallback: sync the cert into the Windows certificate store
          & $smctl windows certsync --keypair-alias $alias
          if ($LASTEXITCODE -ne 0) { throw "certsync failed for alias '$alias'." }

          # Pick most recent Code Signing cert with a private key
          $candidates = Get-ChildItem Cert:\CurrentUser\My |
            Where-Object {
              $_.HasPrivateKey -and
              ($_.EnhancedKeyUsageList | ForEach-Object FriendlyName) -contains 'Code Signing'
            } | Sort-Object NotBefore -Descending

          $cert = $candidates | Select-Object -First 1
          if (-not $cert) { throw "No code-signing certificate found in CurrentUser\My after certsync." }

          "CODESIGN_SHA1=$($cert.Thumbprint)" | Out-File -FilePath $env:GITHUB_ENV -Append
          "SIGN_MODE=sha1" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Using store cert thumbprint: $($cert.Thumbprint)"

      # --- Sign DLL + EXE with DigiCert KeyLocker ---
      - name: Sign artifacts (DLL + EXE)
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        run: |
          $ts = "http://timestamp.digicert.com"
          $args = @('/fd','SHA256','/td','SHA256','/tr',$ts,
                    '/csp','DigiCert Signing Manager KSP',
                    '/kc',"$env:DIGICERT_KEYPAIR_ALIAS",
                    '/f',"$env:CODESIGN_CERT")

          & "$env:SIGNTOOL" sign @args "$env:MIRRORD_LAYER_FILE"
          & "$env:SIGNTOOL" sign @args "$env:MIRRORD_EXE"

      # --- Verify signatures ---
      - name: Verify signatures
        run: |
          & "$env:SIGNTOOL" verify /pa /all "$env:MIRRORD_LAYER_FILE"
          & "$env:SIGNTOOL" verify /pa /all "$env:MIRRORD_EXE"
