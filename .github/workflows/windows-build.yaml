name: Windows Build

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Pick artifacts from GCS (reuse) or build & sign now"
        type: choice
        options: [build_sign, reuse]
        default: build_sign

      release:
        description: "Publish a GitHub Release? (for manual runs)"
        type: choice
        options: [no, draft, prerelease, release]
        default: no

      release_tag:
        description: "Release tag (defaults to pushed tag or untagged-<run_id>)"
        required: false
        type: string

      sign_artifacts:
        description: "Code-sign EXE & DLL (uses signing tokens)"
        type: choice
        options: ["false", "true"]
        default: "false"

      attach_to_release:
        description: "Attach built artifacts to the GitHub Release"
        type: choice
        options: ["false", "true"]
        default: "true"

  push:
    tags:
      - "v*"
    paths-ignore:
      - "*.md"
      - "**/*.md"

  pull_request:
    branches: ["main", "*staging*", "windows-support"]
    types: [opened, synchronize, reopened, ready_for_review]
    paths-ignore:
      - "*.md"
      - "**/*.md"

permissions:
  contents: write    # needed for creating / updating releases

env:
  # Buckets (adjust to your real values)
  BUCKET_URI: gs://mirrord-windows-builds
  MSI_BUCKET_URI: gs://mirrord-windows-msi

  # Where build artifacts are placed (relative to repo root)
  DIST_DIR: dist
  MSI_OUTPUT: dist\\installer\\mirrord.msi
  ZIP_OUTPUT: dist\\mirrord_windows.zip

  # Choco / WinGet (you must ensure tools & secrets exist on runner)
  CHOCO_NUPKG_DIR: dist\\choco
  CHOCO_NUSPEC: packaging\\choco\\mirrord.nuspec
  WINGET_MANIFEST_DIR: dist\\winget

jobs:
  windows-build:
    name: Windows Build & Distribute
    runs-on: windows-2022  # or your self-hosted runner

    env:
      # Resolve some flags for all events
      IS_MANUAL: ${{ github.event_name == 'workflow_dispatch' && 'true' || 'false' }}
      INPUT_MODE: ${{ github.event_name == 'workflow_dispatch' && inputs.mode || 'build_sign' }}
      INPUT_RELEASE: ${{ github.event_name == 'workflow_dispatch' && inputs.release || 'no' }}
      INPUT_SIGN: ${{ github.event_name == 'workflow_dispatch' && inputs.sign_artifacts || 'false' }}
      INPUT_ATTACH: ${{ github.event_name == 'workflow_dispatch' && inputs.attach_to_release || 'true' }}

    steps:
      # -------------------------------------------------------
      # Checkout
      # -------------------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show context
        shell: pwsh
        run: |
          Write-Host "Event: $env:GITHUB_EVENT_NAME"
          Write-Host "Ref:   $env:GITHUB_REF"
          Write-Host "Is manual: $env:IS_MANUAL"
          Write-Host "Mode:      $env:INPUT_MODE"
          Write-Host "Release:   $env:INPUT_RELEASE"
          Write-Host "Sign:      $env:INPUT_SIGN"
          Write-Host "Attach:    $env:INPUT_ATTACH"

      # -------------------------------------------------------
      # Determine tag
      # -------------------------------------------------------
      - name: Determine tag
        id: determine_tag
        shell: pwsh
        run: |
          $tag = $null
          $ref = "${{ github.ref }}"
          $event = "${{ github.event_name }}"
          $inputTag = "${{ github.event_name == 'workflow_dispatch' && inputs.release_tag || '' }}"

          if ($ref.StartsWith("refs/tags/")) {
            $tag = $ref.Split("/")[-1]
          } elseif ($event -eq "workflow_dispatch" -and $inputTag -ne "") {
            $tag = $inputTag
          } else {
            $tag = "untagged-${{ github.run_id }}"
          }

          $isTaggedRef = $ref.StartsWith("refs/tags/") ? "true" : "false"

          "tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "is_tagged_ref=$isTaggedRef" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      # -------------------------------------------------------
      # Optional: print Rust/Cargo versions (Rust should already
      # be installed on your runner)
      # -------------------------------------------------------
      - name: Show Rust version
        shell: pwsh
        run: |
          rustc --version
          cargo --version

      # -------------------------------------------------------
      # Mode: reuse or build_sign
      # If mode == reuse, pull from GCS and skip heavy build.
      # -------------------------------------------------------
      - name: Reuse artifacts from GCS
        id: reuse_from_gcs
        if: env.INPUT_MODE == 'reuse'
        shell: pwsh
        run: |
          Write-Host "Reusing artifacts from GCS..."
          New-Item -ItemType Directory -Force -Path $env:DIST_DIR | Out-Null

          # Example: adjust paths to your naming convention
          # gsutil cp "$env:BUCKET_URI/windows/mirrord.exe" "$env:DIST_DIR\\mirrord.exe"
          # gsutil cp "$env:BUCKET_URI/windows/mirrord_layer.dll" "$env:DIST_DIR\\mirrord_layer.dll"
          #
          # For now, just log message:
          Write-Host "TODO: gsutil cp from $env:BUCKET_URI into $env:DIST_DIR"

      - name: Build & sign binaries
        id: build_and_sign
        if: env.INPUT_MODE == 'build_sign'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path $env:DIST_DIR | Out-Null

          # ========================
          # 1) Build
          # ========================
          Write-Host "Building release binaries..."
          cargo build --locked --release --bin mirrord

          # Example copy results into dist\
          Copy-Item "target\\release\\mirrord.exe" "$env:DIST_DIR\\mirrord.exe" -Force

          # If you have another DLL/EXE:
          # Copy-Item "target\\release\\mirrord_layer.dll" "$env:DIST_DIR\\mirrord_layer.dll" -Force

          # ========================
          # 2) Sign (optional)
          # ========================
          if ("${{ env.INPUT_SIGN }}" -eq "true") {
            Write-Host "Signing artifacts..."
            # Example: use signtool with cert from the runner
            # & "C:\Program Files (x86)\Windows Kits\10\bin\x64\signtool.exe" sign `
            #   /tr http://timestamp.digicert.com /td SHA256 `
            #   /fd SHA256 /a `
            #   "$env:DIST_DIR\\mirrord.exe"
            #
            # Repeat for other files you want to sign.
            Write-Host "TODO: Add your actual signtool commands here."
          } else {
            Write-Host "Signing disabled (INPUT_SIGN != true)."
          }

      # -------------------------------------------------------
      # Build MSI (WiX)
      # -------------------------------------------------------
      - name: Build MSI
        id: build_msi
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path (Split-Path $env:MSI_OUTPUT) | Out-Null

          Write-Host "Building MSI..."
          # Example WiX usage (adjust to your .wxs files):
          # candle.exe .\packaging\wix\mirrord.wxs -out .\packaging\wix\mirrord.wixobj
          # light.exe  .\packaging\wix\mirrord.wixobj -o "$env:MSI_OUTPUT" -ext WixUIExtension

          Write-Host "TODO: Add your actual WiX build commands here."
          # Touch the MSI for now to avoid failures:
          if (-not (Test-Path $env:MSI_OUTPUT)) {
            Write-Host "Creating dummy MSI placeholder."
            New-Item -ItemType File -Path $env:MSI_OUTPUT | Out-Null
          }

      # -------------------------------------------------------
      # Create ZIP of Windows artifacts
      # -------------------------------------------------------
      - name: Create ZIP bundle
        id: zip_bundle
        shell: pwsh
        run: |
          Write-Host "Creating ZIP archive with Windows artifacts..."
          New-Item -ItemType Directory -Force -Path (Split-Path $env:ZIP_OUTPUT) | Out-Null

          # Example zip of dist directory
          if (Test-Path $env:ZIP_OUTPUT) {
            Remove-Item $env:ZIP_OUTPUT -Force
          }

          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $source = Resolve-Path $env:DIST_DIR
          [System.IO.Compression.ZipFile]::CreateFromDirectory($source, $env:ZIP_OUTPUT)

      # -------------------------------------------------------
      # Upload artifacts to GCS
      # -------------------------------------------------------
      - name: Upload MSI to GCS
        id: upload_msi_gcs
        shell: pwsh
        run: |
          Write-Host "Uploading MSI to GCS..."
          # Example:
          # gsutil cp "$env:MSI_OUTPUT" "$env:MSI_BUCKET_URI/windows/"
          Write-Host "TODO: Add gsutil command to upload $env:MSI_OUTPUT to $env:MSI_BUCKET_URI"

      - name: Upload ZIP/binaries to GCS
        id: upload_zip_gcs
        shell: pwsh
        run: |
          Write-Host "Uploading ZIP/binaries to GCS..."
          # Example:
          # gsutil cp "$env:ZIP_OUTPUT" "$env:BUCKET_URI/windows/"
          # gsutil cp "$env:DIST_DIR\\mirrord.exe" "$env:BUCKET_URI/windows/"
          Write-Host "TODO: Add gsutil command to upload $env:ZIP_OUTPUT and others to $env:BUCKET_URI"

      # -------------------------------------------------------
      # Chocolatey package
      # -------------------------------------------------------
      - name: Pack Chocolatey package
        id: choco_pack
        shell: pwsh
        run: |
          Write-Host "Packing Chocolatey package..."
          New-Item -ItemType Directory -Force -Path $env:CHOCO_NUPKG_DIR | Out-Null

          # Example:
          # choco pack "$env:CHOCO_NUSPEC" --outputdirectory "$env:CHOCO_NUPKG_DIR"
          Write-Host "TODO: Add choco pack command here."

      - name: Push Chocolatey package
        id: choco_push
        env:
          CHOCO_API_KEY: ${{ secrets.CHOCO_API_KEY }}
        shell: pwsh
        run: |
          Write-Host "Pushing Chocolatey package..."
          # Example:
          # $nupkg = Get-ChildItem $env:CHOCO_NUPKG_DIR -Filter *.nupkg | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          # if ($null -eq $nupkg) {
          #   Write-Error "No .nupkg found in $env:CHOCO_NUPKG_DIR"
          # }
          # choco push $nupkg.FullName --source "https://push.chocolatey.org/" --api-key $env:CHOCO_API_KEY
          Write-Host "TODO: Add choco push command here."

      # -------------------------------------------------------
      # WinGet manifests
      # -------------------------------------------------------
      - name: Generate WinGet manifest
        id: winget_generate
        shell: pwsh
        run: |
          Write-Host "Generating WinGet manifests..."
          New-Item -ItemType Directory -Force -Path $env:WINGET_MANIFEST_DIR | Out-Null

          # Example using wingetcreate (must be installed on runner)
          # wingetcreate.exe new `
          #   --installer "$env:MSI_OUTPUT" `
          #   --output "$env:WINGET_MANIFEST_DIR" `
          #   --publisher "MetalBear" `
          #   --version "${{ steps.determine_tag.outputs.tag }}" `
          #   --id "MetalBear.mirrord"
          Write-Host "TODO: Add wingetcreate commands here."

      - name: Publish WinGet package
        id: winget_publish
        env:
          WINGET_PAT: ${{ secrets.WINGET_PAT }}   # PAT for the WinGet repo
        shell: pwsh
        run: |
          Write-Host "Publishing WinGet manifests (e.g. via git push to your WinGet repo)..."
          # Example outline (adjust to your repo):
          # git config user.name  "mirrord-bot"
          # git config user.email "bot@metalbear.com"
          # git clone https://$env:WINGET_PAT@github.com/<your-org>/winget-pkgs.git winget-repo
          # Copy-Item "$env:WINGET_MANIFEST_DIR\\*" "winget-repo\\manifests\\M\\MetalBear\\mirrord\\${{ steps.determine_tag.outputs.tag }}" -Recurse -Force
          # cd winget-repo
          # git add .
          # git commit -m "Add mirrord ${{ steps.determine_tag.outputs.tag }}"
          # git push origin main
          Write-Host "TODO: Add your WinGet publishing logic here."

      # -------------------------------------------------------
      # Decide if we should create/update a Release
      #  - Manual run: uses INPUT_RELEASE
      #  - Non-manual & tag push: always 'release'
      # -------------------------------------------------------
      - name: Compute release mode
        id: compute_release_mode
        shell: pwsh
        run: |
          $event = "${{ github.event_name }}"
          $ref = "${{ github.ref }}"
          $inputRelease = "${{ env.INPUT_RELEASE }}"

          $mode = "no"

          if ($event -eq "workflow_dispatch") {
            $mode = $inputRelease
          } elseif ($ref.StartsWith("refs/tags/")) {
            # Non-manual tag push -> full release
            $mode = "release"
          }

          "mode=$mode" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Host "Effective release mode: $mode"

      # -------------------------------------------------------
      # Ensure GitHub Release exists (no softprops, use github-script)
      # -------------------------------------------------------
      - name: Ensure GitHub Release
        id: ensure_release
        if: steps.compute_release_mode.outputs.mode != 'no'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const tag = '${{ steps.determine_tag.outputs.tag }}';
            const mode = '${{ steps.compute_release_mode.outputs.mode }}'; // no | draft | prerelease | release

            core.info(`Ensuring release for tag=${tag}, mode=${mode}`);

            let release;
            try {
              const existing = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              release = existing.data;
              core.info(`Found existing release id=${release.id}`);
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
              core.info("No release found, creating a new one...");
              const draft = mode === 'draft';
              const prerelease = mode === 'prerelease';

              const createParams = {
                owner,
                repo,
                tag_name: tag,
                name: tag,
                draft,
                prerelease
              };

              const created = await github.rest.repos.createRelease(createParams);
              release = created.data;
              core.info(`Created new release id=${release.id}`);
            }

            core.setOutput('release_id', release.id.toString());
            core.setOutput('upload_url', release.upload_url);

      # -------------------------------------------------------
      # Attach assets to Release (if attach_to_release == true)
      # -------------------------------------------------------
      - name: Attach artifacts to Release
        id: attach_release_assets
        if: steps.compute_release_mode.outputs.mode != 'no' && env.INPUT_ATTACH == 'true'
        uses: actions/github-script@v7
        env:
          DIST_DIR: ${{ env.DIST_DIR }}
          MSI_OUTPUT: ${{ env.MSI_OUTPUT }}
          ZIP_OUTPUT: ${{ env.ZIP_OUTPUT }}
          CHOCO_NUPKG_DIR: ${{ env.CHOCO_NUPKG_DIR }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const { owner, repo } = context.repo;
            const release_id = parseInt('${{ steps.ensure_release.outputs.release_id }}', 10);

            const candidates = [];

            function addCandidate(p) {
              if (!p) return;
              if (fs.existsSync(p) && fs.statSync(p).isFile()) {
                candidates.push(p);
              } else {
                core.info(`Skipping missing asset: ${p}`);
              }
            }

            // Main artifacts
            addCandidate(process.env.MSI_OUTPUT);
            addCandidate(process.env.ZIP_OUTPUT);

            // Add binaries from DIST_DIR (optional; you can comment this out)
            const distDir = process.env.DIST_DIR;
            if (fs.existsSync(distDir)) {
              for (const file of fs.readdirSync(distDir)) {
                const full = path.join(distDir, file);
                if (fs.statSync(full).isFile()) {
                  addCandidate(full);
                }
              }
            }

            // Add Choco nupkgs
            const nupkgDir = process.env.CHOCO_NUPKG_DIR;
            if (fs.existsSync(nupkgDir)) {
              for (const file of fs.readdirSync(nupkgDir)) {
                if (file.toLowerCase().endsWith('.nupkg')) {
                  addCandidate(path.join(nupkgDir, file));
                }
              }
            }

            core.info(`Attaching ${candidates.length} assets to release ${release_id}...`);

            for (const filePath of candidates) {
              const name = path.basename(filePath);
              const fileData = fs.readFileSync(filePath);
              core.info(`Uploading asset: ${name} (${fileData.length} bytes)`);

              await github.rest.repos.uploadReleaseAsset({
                owner,
                repo,
                release_id,
                name,
                data: fileData
              });
            }

      # -------------------------------------------------------
      # Optional: Release validation tests (curl/brew/etc.)
      # -------------------------------------------------------
      - name: Release validation tests
        id: release_tests
        if: steps.compute_release_mode.outputs.mode != 'no'
        shell: pwsh
        run: |
          Write-Host "Run your post-release tests here (curl/brew/etc.)"
          # Example:
          # Invoke-WebRequest "https://github.com/metalbear-co/mirrord/releases/download/${{ steps.determine_tag.outputs.tag }}/mirrord_windows.zip" -OutFile test.zip
          # TODO: Add real tests.

      # -------------------------------------------------------
      # Post-build summary (Summary tab)
      # -------------------------------------------------------
      - name: Post-build summary
        if: always()
        shell: pwsh
        run: |
          $summary = $env:GITHUB_STEP_SUMMARY

          "## Windows Build Summary"        | Out-File -FilePath $summary -Encoding utf8 -Append
          ""                                | Out-File -FilePath $summary -Encoding utf8 -Append
          "**Overall job status:** `${{ job.status }}`" |
            Out-File -FilePath $summary -Encoding utf8 -Append
          ""                                | Out-File -FilePath $summary -Encoding utf8 -Append

          "| Stage | Status | Details |"     | Out-File -FilePath $summary -Encoding utf8 -Append
          "|-------|--------|---------|"     | Out-File -FilePath $summary -Encoding utf8 -Append

          # üîß Build & sign
          "| Build & sign binaries | ${{ steps.build_and_sign.outcome || 'skipped' }} | cargo + signing |" |
            Out-File -FilePath $summary -Encoding utf8 -Append

          # üì¶ MSI
          "| Build MSI | ${{ steps.build_msi.outcome || 'skipped' }} | WiX / .msi packaging |" |
            Out-File -FilePath $summary -Encoding utf8 -Append

          # ‚òÅÔ∏è Uploads to GCS
          "| Upload MSI to GCS | ${{ steps.upload_msi_gcs.outcome || 'skipped' }} | ${{ env.MSI_BUCKET_URI }} |" |
            Out-File -FilePath $summary -Encoding utf8 -Append

          "| Upload ZIP/binaries to GCS | ${{ steps.upload_zip_gcs.outcome || 'skipped' }} | ${{ env.BUCKET_URI }} |" |
            Out-File -FilePath $summary -Encoding utf8 -Append

          # üç´ Chocolatey
          "| Chocolatey package | ${{ steps.choco_pack.outcome || 'skipped' }} | nupkg creation |" |
            Out-File -FilePath $summary -Encoding utf8 -Append

          "| Push to Chocolatey feed | ${{ steps.choco_push.outcome || 'skipped' }} | internal/external feed |" |
            Out-File -FilePath $summary -Encoding utf8 -Append

          # ü™ü WinGet
          "| Generate WinGet manifest | ${{ steps.winget_generate.outcome || 'skipped' }} | yaml manifest |" |
            Out-File -FilePath $summary -Encoding utf8 -Append

          "| Publish WinGet package | ${{ steps.winget_publish.outcome || 'skipped' }} | submit to repo |" |
            Out-File -FilePath $summary -Encoding utf8 -Append

          # üè∑Ô∏è GitHub Release
          "| Ensure GitHub Release exists | ${{ steps.ensure_release.outcome || 'skipped' }} | create/find release |" |
            Out-File -FilePath $summary -Encoding utf8 -Append

          "| Attach artifacts to Release | ${{ steps.attach_release_assets.outcome || 'skipped' }} | upload assets |" |
            Out-File -FilePath $summary -Encoding utf8 -Append

          # üß™ Release validation tests
          "| Release validation tests | ${{ steps.release_tests.outcome || 'skipped' }} | curl/brew checks etc. |" |
            Out-File -FilePath $summary -Encoding utf8 -Append
