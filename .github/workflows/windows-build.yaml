name: Build PR 3536 (Windows, self-hosted, signed)

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  build:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout PR 3536 (merge ref)
        uses: actions/checkout@v4
        with:
          ref: refs/pull/3536/merge
          fetch-depth: 0
          submodules: recursive

      # Ensure Rust is present even if the service PATH doesn't include it
      - name: Ensure Rust toolchain (if cargo/rustup missing)
        run: |
          $cargo = Get-Command cargo.exe -ErrorAction SilentlyContinue
          if (-not $cargo) {
            $env:CARGO_HOME  = "$env:RUNNER_TEMP\.cargo"
            $env:RUSTUP_HOME = "$env:RUNNER_TEMP\.rustup"
            $installer = "$env:RUNNER_TEMP\rustup-init.exe"
            Invoke-WebRequest -Uri https://win.rustup.rs/x86_64 -OutFile $installer
            & $installer -y --default-host x86_64-pc-windows-msvc --profile minimal
            $env:PATH = "$env:CARGO_HOME\bin;$env:PATH"
          }
          rustup --version
          cargo --version

      - name: Add Rust MSVC target
        run: rustup target add x86_64-pc-windows-msvc

      # Build the layer crate that produces mirrord_layer_win.dll
      - name: Build mirrord-layer-win (DLL)
        run: cargo build -p mirrord-layer-win --target x86_64-pc-windows-msvc

      # Find which *package* contains the bin target named "mirrord" and set MIRRORD_LAYER_FILE
      - name: Locate package for bin "mirrord" + set MIRRORD_LAYER_FILE
        run: |
          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg = $meta.packages | Where-Object {
            $_.targets | Where-Object { ($_."kind" -contains 'bin') -and ($_.name -eq 'mirrord') }
          } | Select-Object -First 1
          if (-not $pkg) {
            $names = ($meta.packages | ForEach-Object name) -join ', '
            throw "No bin target named 'mirrord' found. Workspace packages: $names"
          }
          "MIRRORD_PKG=$($pkg.name)" | Out-File -FilePath $env:GITHUB_ENV -Append
          $dll = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord_layer_win.dll'
          "MIRRORD_LAYER_FILE=$dll" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Will build bin 'mirrord' from package: $($pkg.name)"
          Write-Host "MIRRORD_LAYER_FILE=$dll"

      - name: Build mirrord (bin)
        run: cargo build -p "$env:MIRRORD_PKG" --bin mirrord --target x86_64-pc-windows-msvc

      # Export SignTool path and verify artifacts exist
      - name: Export SignTool path + verify artifacts
        run: |
          $signtool = 'C:\Program Files (x86)\Windows Kits\10\bin\10.0.26100.0\x64\signtool.exe'
          if (-not (Test-Path $signtool)) {
            $found = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe" -ErrorAction SilentlyContinue |
              Sort-Object FullName -Descending | Select-Object -First 1
            if ($found) { $signtool = $found.FullName }
          }
          if (-not (Test-Path $signtool)) { throw "SignTool not found." }
          "SIGNTOOL=$signtool" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Using SignTool at $signtool"

          $dll = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord_layer_win.dll'
          $exe = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord.exe'
          if (-not (Test-Path $dll)) { throw "DLL not found at $dll" }
          if (-not (Test-Path $exe)) { throw "EXE not found at $exe" }
          "MIRRORD_EXE=$exe" | Out-File -FilePath $env:GITHUB_ENV -Append

      # DigiCert: (re)hydrate creds for THIS account every run
      - name: Prepare DigiCert creds (overwrite each run)
        env:
          DIGICERT_API_KEY:              ${{ secrets.DIGICERT_API_KEY }}
          DIGICERT_CLIENT_CERT_PFX_B64:  ${{ secrets.DIGICERT_CLIENT_CERT_PFX_B64 }}
          DIGICERT_CLIENT_CERT_PASSWORD: ${{ secrets.DIGICERT_CLIENT_CERT_PASSWORD }}
        run: |
          $smctl = @(
            "C:\Program Files\DigiCert\DigiCert Keylocker Tools\smctl.exe",
            "C:\Program Files\DigiCert\DigiCert KeyLocker Tools\smctl.exe",
            "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools\smctl.exe"
          ) | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $smctl) { throw "smctl.exe not found at expected DigiCert paths." }
          "SMCTL=$smctl" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Using smctl at: $smctl"

          $p12 = Join-Path $env:RUNNER_TEMP "client-auth.p12"
          [IO.File]::WriteAllBytes($p12, [Convert]::FromBase64String($env:DIGICERT_CLIENT_CERT_PFX_B64))
          $env:SM_HOST = "https://clientauth.one.digicert.com"
          $env:SM_CLIENT_CERT_FILE = $p12

          & $smctl credentials clear 2>$null
          & $smctl credentials save $env:DIGICERT_API_KEY $env:DIGICERT_CLIENT_CERT_PASSWORD
          try { & $smctl windows ksp register } catch { Write-Warning $_ }

          Write-Host "`nKeypairs visible to this user:"
          & $smctl keypair list

      # Try to get the .cer; if that fails, fallback to certsync + /sha1
      - name: Get certificate (download .cer, fallback to certsync)
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        run: |
          $smctl = "$env:SMCTL"
          $alias = "$env:DIGICERT_KEYPAIR_ALIAS".Trim()
          if (-not $alias) { throw "DIGICERT_KEYPAIR_ALIAS is empty." }

          $outDir = $env:RUNNER_TEMP
          Remove-Item (Join-Path $outDir '*.cer') -Force -ErrorAction SilentlyContinue

          Write-Host "Attempting .cer download for alias '$alias'..."
          & $smctl certificate download --keypair-alias $alias --format cer --out $outDir
          $rc = $LASTEXITCODE
          $cert = Get-ChildItem $outDir -Filter *.cer -ErrorAction SilentlyContinue | Select-Object -First 1

          if ($cert) {
            "CODESIGN_CERT=$($cert.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append
            Write-Host "Downloaded certificate: $($cert.FullName) (smctl rc=$rc)"
          } else {
            Write-Warning "No .cer written (smctl rc=$rc). Falling back to certsync â†’ /sha1."
          }

          # If we don't have a file, or if you prefer to always ensure store linkage, do certsync:
          if (-not $cert) {
            & $smctl windows certsync --keypair-alias $alias
            if ($LASTEXITCODE -ne 0) { throw "certsync failed for alias '$alias'." }
          }

          # Optional: extract a DigiCert KSP-backed thumbprint for fallback signing
          $dump = certutil -store -user My | Out-String
          $blocks = $dump -split "(?m)^================ Certificate [0-9]+ ================"
          $kspSha1 = $null
          foreach ($b in $blocks) {
            if ($b -match 'Provider = DigiCert Signing Manager KSP') {
              if ($b -match 'Cert Hash\(sha1\):\s*([A-F0-9 ]+)') {
                $kspSha1 = ($Matches[1] -replace '\s','').ToUpper()
                break
              }
            }
          }
          if ($kspSha1) {
            "CODESIGN_SHA1=$kspSha1" | Out-File -FilePath $env:GITHUB_ENV -Append
            Write-Host "KSP-backed thumbprint discovered: $kspSha1"
          } else {
            Write-Host "No KSP-backed thumbprint discovered yet (may still be fine if file mode works)."
          }

      # Sign using file-mode first (/csp+/kc+/f). If it fails, fallback to /sha1 (store mode).
      - name: Sign artifacts (DLL + EXE) with fallback
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        run: |
          $ts = "http://timestamp.digicert.com"
          $signtool = "$env:SIGNTOOL"
          $alias = "$env:DIGICERT_KEYPAIR_ALIAS".Trim()
          $dll = "$env:MIRRORD_LAYER_FILE"
          $exe = "$env:MIRRORD_EXE"

          function Sign-FileMode {
            param($path)
            $args = @('/fd','SHA256','/td','SHA256','/tr',$ts,
                      '/csp','DigiCert Signing Manager KSP',
                      '/kc',"$alias",
                      '/f', "$env:CODESIGN_CERT")
            & "$signtool" sign @args "$path"
            return $LASTEXITCODE
          }

          function Get-KspBackedThumbprint {
            $dump = certutil -store -user My | Out-String
            $blocks = $dump -split "(?m)^================ Certificate [0-9]+ ================"
            foreach ($b in $blocks) {
              if ($b -match 'Provider = DigiCert Signing Manager KSP') {
                if ($b -match 'Cert Hash\(sha1\):\s*([A-F0-9 ]+)') {
                  return (($Matches[1] -replace '\s','').ToUpper())
                }
              }
            }
            return $null
          }

          $fileModeUsable = ($env:CODESIGN_CERT -and (Test-Path "$env:CODESIGN_CERT"))
          if ($fileModeUsable) {
            Write-Host "Signing (file mode) with alias '$alias' and cert '$env:CODESIGN_CERT'..."
            $rc1 = Sign-FileMode $dll
            $rc2 = if ($rc1 -eq 0) { Sign-FileMode $exe } else { $rc1 }

            if ($rc1 -eq 0 -and $rc2 -eq 0) { Write-Host "File mode signing OK."; exit 0 }
            Write-Warning "File mode signing failed (rc1=$rc1 rc2=$rc2). Falling back to store mode (/sha1)..."
          } else {
            Write-Host "No CODESIGN_CERT file present; using store mode (/sha1)."
          }

          # Ensure cert is synced for this alias before /sha1
          $smctl = "$env:SMCTL"
          & $smctl windows certsync --keypair-alias "$alias" | Out-Null

          $sha1 = if ($env:CODESIGN_SHA1) { "$env:CODESIGN_SHA1" } else { Get-KspBackedThumbprint }
          if (-not $sha1) { throw "No DigiCert KSP-backed certificate found in CurrentUser\My for /sha1 signing." }

          & "$signtool" sign /fd SHA256 /td SHA256 /tr $ts /sha1 $sha1 "$dll"
          $rc3 = $LASTEXITCODE
          & "$signtool" sign /fd SHA256 /td SHA256 /tr $ts /sha1 $sha1 "$exe"
          $rc4 = $LASTEXITCODE

          if ($rc3 -ne 0 -or $rc4 -ne 0) {
            throw "Store mode signing failed (rc3=$rc3 rc4=$rc4). Check alias, signer assignment, creds, and KSP registration."
          }

      - name: Verify signatures
        run: |
          & "$env:SIGNTOOL" verify /pa /all "$env:MIRRORD_LAYER_FILE"
          & "$env:SIGNTOOL" verify /pa /all "$env:MIRRORD_EXE"
