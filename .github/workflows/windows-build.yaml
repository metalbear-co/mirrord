name: Build PR 3536 (Windows, self-hosted, signed)

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  build:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout PR 3536 (merge ref)
        uses: actions/checkout@v4
        with:
          ref: refs/pull/3536/merge
          fetch-depth: 0
          submodules: recursive

      # Ensure Rust is present even if the service PATH doesn't include it
      - name: Ensure Rust toolchain (if cargo/rustup missing)
        run: |
          $cargo = Get-Command cargo.exe -ErrorAction SilentlyContinue
          if (-not $cargo) {
            $env:CARGO_HOME  = "$env:RUNNER_TEMP\.cargo"
            $env:RUSTUP_HOME = "$env:RUNNER_TEMP\.rustup"
            $installer = "$env:RUNNER_TEMP\rustup-init.exe"
            Invoke-WebRequest -Uri https://win.rustup.rs/x86_64 -OutFile $installer
            & $installer -y --default-host x86_64-pc-windows-msvc --profile minimal
            $env:PATH = "$env:CARGO_HOME\bin;$env:PATH"
          }
          rustup --version
          cargo --version

      - name: Add Rust MSVC target
        run: rustup target add x86_64-pc-windows-msvc

      # Build the layer crate that produces mirrord_layer_win.dll
      - name: Build mirrord-layer-win (DLL)
        run: cargo build -p mirrord-layer-win --target x86_64-pc-windows-msvc

      # Find which *package* contains the bin target named "mirrord" and set MIRRORD_LAYER_FILE
      - name: Locate package for bin "mirrord" + set MIRRORD_LAYER_FILE
        run: |
          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg = $meta.packages | Where-Object {
            $_.targets | Where-Object { ($_."kind" -contains 'bin') -and ($_.name -eq 'mirrord') }
          } | Select-Object -First 1
          if (-not $pkg) {
            $names = ($meta.packages | ForEach-Object name) -join ', '
            throw "No bin target named 'mirrord' found. Workspace packages: $names"
          }
          "MIRRORD_PKG=$($pkg.name)" | Out-File -FilePath $env:GITHUB_ENV -Append
          $dll = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord_layer_win.dll'
          "MIRRORD_LAYER_FILE=$dll" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Will build bin 'mirrord' from package: $($pkg.name)"
          Write-Host "MIRRORD_LAYER_FILE=$dll"

      - name: Build mirrord (bin)
        run: cargo build -p "$env:MIRRORD_PKG" --bin mirrord --target x86_64-pc-windows-msvc

      # Export SignTool path and verify artifacts exist
      - name: Export SignTool path + verify artifacts
        run: |
          $signtool = 'C:\Program Files (x86)\Windows Kits\10\bin\10.0.26100.0\x64\signtool.exe'
          if (-not (Test-Path $signtool)) {
            $found = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe" -ErrorAction SilentlyContinue |
              Sort-Object FullName -Descending | Select-Object -First 1
            if ($found) { $signtool = $found.FullName }
          }
          if (-not (Test-Path $signtool)) { throw "SignTool not found." }
          "SIGNTOOL=$signtool" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Using SignTool at $signtool"

          $dll = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord_layer_win.dll'
          $exe = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord.exe'
          if (-not (Test-Path $dll)) { throw "DLL not found at $dll" }
          if (-not (Test-Path $exe)) { throw "EXE not found at $exe" }
          "MIRRORD_EXE=$exe" | Out-File -FilePath $env:GITHUB_ENV -Append

      # DigiCert: (re)hydrate creds for THIS account every run
      - name: Prepare DigiCert creds (overwrite each run)
        env:
          DIGICERT_API_KEY:              ${{ secrets.DIGICERT_API_KEY }}
          DIGICERT_CLIENT_CERT_PFX_B64:  ${{ secrets.DIGICERT_CLIENT_CERT_PFX_B64 }}
          DIGICERT_CLIENT_CERT_PASSWORD: ${{ secrets.DIGICERT_CLIENT_CERT_PASSWORD }}
        run: |
          $smctl = @(
            "C:\Program Files\DigiCert\DigiCert Keylocker Tools\smctl.exe",
            "C:\Program Files\DigiCert\DigiCert KeyLocker Tools\smctl.exe",
            "C:\Program Files\DigiCert\DigiCert One Signing Manager Tools\smctl.exe"
          ) | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $smctl) { throw "smctl.exe not found at expected DigiCert paths." }
          "SMCTL=$smctl" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Using smctl at: $smctl"

          $p12 = Join-Path $env:RUNNER_TEMP "client-auth.p12"
          [IO.File]::WriteAllBytes($p12, [Convert]::FromBase64String($env:DIGICERT_CLIENT_CERT_PFX_B64))
          $env:SM_HOST = "https://clientauth.one.digicert.com"
          $env:SM_CLIENT_CERT_FILE = $p12

          & $smctl credentials clear 2>$null
          & $smctl credentials save $env:DIGICERT_API_KEY $env:DIGICERT_CLIENT_CERT_PASSWORD
          try { & $smctl windows ksp register } catch { Write-Warning $_ }

          Write-Host "`nKeypairs visible to this user:"
          & $smctl keypair list

      # Download the public cert, compute its thumbprint, certsync the alias, then sign by /sha1
      - name: Prepare certificate (download → thumbprint → certsync)
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        run: |
          $ErrorActionPreference = "Stop"
          $smctl = "$env:SMCTL"
          $alias = "$env:DIGICERT_KEYPAIR_ALIAS".Trim()
          if (-not $alias) { throw "DIGICERT_KEYPAIR_ALIAS is empty." }

          $outDir = $env:RUNNER_TEMP
          Remove-Item (Join-Path $outDir '*.cer') -Force -ErrorAction SilentlyContinue

          Write-Host "Downloading .cer for alias '$alias'..."
          & $smctl certificate download --keypair-alias $alias --format cer --out $outDir
          $rc = $LASTEXITCODE
          $cer = Get-ChildItem $outDir -Filter *.cer -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $cer) {
            throw "No .cer downloaded for alias '$alias' (smctl rc=$rc). Make sure the certificate is Issued and linked to this KeyLocker key."
          }

          # Compute thumbprint from the downloaded file
          $x = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($cer.FullName)
          $thumb = ($x.Thumbprint -replace '\s','').ToUpper()
          "CODESIGN_THUMBPRINT=$thumb" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Certificate thumbprint (from file): $thumb (smctl rc=$rc)"

          # Sync that alias into CurrentUser\My for THIS service account
          Write-Host "Running certsync for alias '$alias'..."
          & $smctl windows certsync --keypair-alias $alias
          if ($LASTEXITCODE -ne 0) { throw "certsync failed for alias '$alias'." }

          # Ensure the exact thumbprint is now present in CurrentUser\My
          $storeCert = Get-ChildItem Cert:\CurrentUser\My | Where-Object { ($_.Thumbprint -replace '\s','').ToUpper() -eq $thumb } | Select-Object -First 1
          if (-not $storeCert) {
            Start-Sleep -Seconds 2
            $storeCert = Get-ChildItem Cert:\CurrentUser\My | Where-Object { ($_.Thumbprint -replace '\s','').ToUpper() -eq $thumb } | Select-Object -First 1
          }
          if (-not $storeCert) {
            Write-Host "CurrentUser\My contents (for diagnostics):"
            Get-ChildItem Cert:\CurrentUser\My | Select-Object Subject, Thumbprint, NotAfter
            throw "Thumbprint $thumb not found in CurrentUser\My after certsync. Check signer assignment, creds, and division access."
          }
          Write-Host "Thumbprint present in store."

      - name: Sign artifacts (DLL + EXE) via /sha1
        env:
          CODESIGN_THUMBPRINT: ${{ env.CODESIGN_THUMBPRINT }}
        run: |
          $ts = "http://timestamp.digicert.com"
          $sha1 = "$env:CODESIGN_THUMBPRINT"
          if (-not $sha1) { throw "CODESIGN_THUMBPRINT missing." }

          & "$env:SIGNTOOL" sign /fd SHA256 /td SHA256 /tr $ts /sha1 $sha1 "$env:MIRRORD_LAYER_FILE"
          if ($LASTEXITCODE -ne 0) { throw "Signing DLL failed with /sha1 $sha1." }

          & "$env:SIGNTOOL" sign /fd SHA256 /td SHA256 /tr $ts /sha1 $sha1 "$env:MIRRORD_EXE"
          if ($LASTEXITCODE -ne 0) { throw "Signing EXE failed with /sha1 $sha1." }

      - name: Verify signatures
        run: |
          & "$env:SIGNTOOL" verify /pa /all "$env:MIRRORD_LAYER_FILE"
          & "$env:SIGNTOOL" verify /pa /all "$env:MIRRORD_EXE"
