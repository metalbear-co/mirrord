name: Build PR 3536 (Windows, self-hosted, minimal)

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  build:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout PR 3536 (merge ref)
        uses: actions/checkout@v4
        with:
          ref: refs/pull/3536/merge
          fetch-depth: 0
          submodules: recursive

      # Ensure smctl resolves even if the System PATH wasn't updated
      - name: Ensure smctl (KeyLocker Tools) on PATH
        run: |
          'C:\Program Files\DigiCert\DigiCert Keylocker Tools' | Out-File -Append $env:GITHUB_PATH

      # Single sanity step: identity + smctl health
      - name: Identity & DigiCert healthcheck
        run: |
          $ErrorActionPreference = 'Stop'
          whoami
          Write-Host "USERPROFILE=$env:USERPROFILE"
          Write-Host "SM_HOST=$env:SM_HOST"
          Write-Host "SM_CLIENT_CERT_FILE=$env:SM_CLIENT_CERT_FILE"
          smctl --version
          smctl healthcheck

      # Check the code-signing cert thumbprint; service context uses LocalMachine\My
      - name: Check code-signing cert presence
        run: |
          $ErrorActionPreference = 'Stop'
          $thumb = 'BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB'

          Write-Host "== LocalMachine\My =="
          $lm = Get-ChildItem Cert:\LocalMachine\My | Where-Object Thumbprint -eq $thumb
          if (-not $lm) { Write-Warning "Cert NOT found in LocalMachine\My. /sha1 signing under a service account will fail." }
          else { $lm | Format-List Subject,Thumbprint,NotAfter }

          Write-Host "== CurrentUser\My =="
          Get-ChildItem Cert:\CurrentUser\My | Where-Object Thumbprint -eq $thumb | Format-List Subject,Thumbprint,NotAfter

      # Rust target
      - name: Add Rust MSVC target
        run: rustup target add x86_64-pc-windows-msvc

      # Discover the package that owns the 'mirrord' bin and set env vars
      - name: Locate package for bin "mirrord" + set MIRRORD_LAYER_FILE
        run: |
          $ErrorActionPreference = 'Stop'
          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg = $meta.packages | Where-Object {
            $_.targets | Where-Object { ($_."kind" -contains 'bin') -and ($_.name -eq 'mirrord') }
          } | Select-Object -First 1
          if (-not $pkg) {
            $names = ($meta.packages | ForEach-Object name) -join ', '
            throw "No bin target named 'mirrord' found. Workspace packages: $names"
          }
          "MIRRORD_PKG=$($pkg.name)" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Will build bin 'mirrord' from package: $($pkg.name)"

          $dll = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\layer_win.dll'
          "MIRRORD_LAYER_FILE=$dll" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "MIRRORD_LAYER_FILE=$dll"

      # Build
      - name: Build mirrord
        run: cargo build -p "$env:MIRRORD_PKG" --bin mirrord --target x86_64-pc-windows-msvc

      # Code sign (thumbprint in LocalMachine\My); sign EXE + DLL and verify both
      - name: Code sign mirrord.exe + layer DLL (thumbprint) + verify
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $buildDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug'

          $exe = Join-Path $buildDir 'mirrord.exe'

          # Try MIRRORD_LAYER_FILE first, then common names
          $dllCandidates = @()
          if ($env:MIRRORD_LAYER_FILE) { $dllCandidates += $env:MIRRORD_LAYER_FILE }
          $dllCandidates += @(
            (Join-Path $buildDir 'win_layer.dll'),
            (Join-Path $buildDir 'layer_win.dll')
          )
          $dll = $dllCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1

          if (!(Test-Path $exe)) {
            Write-Error "Expected binary not found at $exe"
            Get-ChildItem -Path $buildDir -Recurse -Filter 'mirrord*.exe' | ForEach-Object { Write-Host "Found EXE: $($_.FullName)" }
            exit 1
          }
          if (-not $dll) {
            Write-Error "Layer DLL not found. Looked for:`n$($dllCandidates -join \"`n\")"
            Get-ChildItem -Path $buildDir -Recurse -Filter '*.dll' | ForEach-Object { Write-Host "Found DLL: $($_.FullName)" }
            exit 1
          }

          $filesToSign = @($exe, $dll)

          foreach ($f in $filesToSign) {
            Write-Host "Signing $f"
            signtool.exe sign `
              /sha1 bfa0bea8d22265cb382d2d5dec55a6ffcff70bcb `
              /tr http://timestamp.digicert.com `
              /td SHA256 `
              /fd SHA256 `
              "$f"

            Write-Host "Verifying $f"
            signtool.exe verify /pa "$f"
          }

