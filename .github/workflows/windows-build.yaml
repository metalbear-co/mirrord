name: Windows Build + Choco and WinGet

on:
  workflow_dispatch:
    inputs:

      release_tag:
        description: "Version to use for Chocolatey/WinGet (e.g. 0.0.1-test2). Defaults to MIRRORD_VERSION."
        required: false
        type: string
      sign_artifacts:
        description: "Code-sign EXE & DLL & MSI"
        type: choice
        options: ["false", "true"]
        default: false
      choco_publish:
        description: "Publish a Chocolatey package?"
        type: choice
        options: ["false", "true"]
        default: "false"
      winget_publish:
        description: "Update WinGet manifest (wingetcreate)?"
        type: choice
        options: ["false", "true"]
        default: "false"

  workflow_call:
    inputs:

      release_tag:
        description: "Version to use for Chocolatey/WinGet (e.g. 0.0.1-test2). Defaults to MIRRORD_VERSION."
        required: false
        type: string
      sign_artifacts:
        description: "Code-sign EXE & DLL & MSI"
        type: string
        default: "false"
      choco_publish:
        description: "Publish a Chocolatey package?"
        type: string
        default: "false"
      winget_publish:
        description: "Update WinGet manifest (wingetcreate)?"
        type: string
        default: "false"

  # pull_request: REMOVED (triggered via ci.yaml now)

# permissions: contents: write - REMOVED to allow inheritance (Read in CI, Write in Release)

env:
  MSI_BUCKET_URI: gs://mirrord-windows-builds-public
  RUST_BACKTRACE: "1"
  CARGO_NET_GIT_FETCH_WITH_CLI: "true"
  MIRRORD_TELEMETRY: "false"
  LIBCLANG_PATH: "C:\\Program Files\\LLVM\\bin"
  MSI_HTTP_BASE: "https://storage.googleapis.com/mirrord-windows-builds-public"
  WINGET_PACKAGE_ID: "MetalBear.mirrord"

jobs:
  windows_build:
    runs-on: [self-hosted, Windows]
    permissions:
      contents: write
    defaults:
      run:
        shell: pwsh
    env:

      RELEASE_TAG_INPUT: ${{ inputs.release_tag || '' }}
      SIGN_ARTIFACTS: ${{ inputs.sign_artifacts || 'false' }}
      PUBLISH_CHOCO: ${{ inputs.choco_publish || 'true' }}
      PUBLISH_WINGET: ${{ inputs.winget_publish || 'false' }}
      CHOCO_API_KEY: ${{ secrets.CHOCO_API_KEY }}
      WINGET_TOKEN: ${{ secrets.WINGET_TOKEN }}
      GH_TOKEN: ${{ secrets.WINGET_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive
      ###########################################################################
      # TEMP: DOWNLOAD ARTIFACTS FROM GCS (SKIP BUILD)
      ###########################################################################
      - name: Compute release tag
        id: tag
        run: |
          $ErrorActionPreference = "Stop"
          if ($env:RELEASE_TAG_INPUT) {
            $tag = $env:RELEASE_TAG_INPUT
          } else {
            $tag = "3.180.0"
          }
          "RELEASE_TAG=$tag" | Out-File -Append -FilePath $env:GITHUB_ENV
          Write-Host "RELEASE_TAG set to $tag"

      - name: Download Artifacts from GCS
        run: |
          $ErrorActionPreference = "Stop"
          
          # Hardcoded GCS source as requested
          # NOTE: We need the RUN ID folders if that's how they are stored, 
          # BUT user said: "gs://mirrord-windows-builds-public/release-windows-3.180.0/"
          # I will trust the user and try to download recursively or from specific expected structure.
          # If the user meant the PARENT folder, I'll need to find the latest run.
          
          # Let's assume the user knows the path or we search for latest 'run-*'
          # Hardcoded GCS source as requested by user
          # Path: mirrord-windows-builds-public/3.180.0/run-20757133456
          $sourceMsi = "gs://mirrord-windows-builds-public/3.180.0/run-20757133456/mirrord.msi"
          
          Write-Host "Downloading MSI from: $sourceMsi"
          
          $Root = "C:\wix\mirrord"
          New-Item -ItemType Directory -Force -Path $Root | Out-Null

          # Copy MSI
          gcloud storage cp "$sourceMsi" "$Root\mirrord.msi"
          if (-not (Test-Path "$Root\mirrord.msi")) { throw "Failed to download MSI" }
          
          # Set Env Vars required for Publishing
          "MSI_PATH=$Root\mirrord.msi" | Out-File -Append -FilePath $env:GITHUB_ENV
          
          # Construct HTTP URL (Manual construction is safest here)
          # gs://mirrord-windows-builds-public/3.180.0/run-20757133456/mirrord.msi
          # -> https://storage.googleapis.com/mirrord-windows-builds-public/3.180.0/run-20757133456/mirrord.msi
          
          $url = "https://storage.googleapis.com/mirrord-windows-builds-public/3.180.0/run-20757133456/mirrord.msi"
          
          Write-Host "Computed MSI Download URL: $url"
          
          # Fix double slashes if any
          $url = $url.Replace("//", "/")
          
          Write-Host "Computed MSI Download URL: $url"
          "MSI_DOWNLOAD_URL=$url" | Out-File -Append -FilePath $env:GITHUB_ENV

      ###########################################################################
      # INSTALL .NET RUNTIME FOR WINGETCREATE
      ###########################################################################
      - name: Install .NET runtime for wingetcreate
        # Skip on forks without WINGET_TOKEN so they don't fail
        if: ${{ github.event_name != 'pull_request' && env.PUBLISH_WINGET == 'true' && env.WINGET_TOKEN != '' }}
        uses: actions/setup-dotnet@v4
        env:
          DOTNET_INSTALL_DIR: ${{ runner.temp }}\dotnet
        with:
          dotnet-version: '8.0.x'

      ###########################################################################
      # UPDATE WinGet MANIFEST (wingetcreate)
      ###########################################################################

      - name: Update WinGet manifest (wingetcreate)
        # Skip on forks without WINGET_TOKEN so they don't fail
        if: ${{ github.event_name != 'pull_request' && env.PUBLISH_WINGET == 'true' && env.WINGET_TOKEN != '' }}
        run: |
          $ErrorActionPreference = "Stop"
          $packageId = $env:WINGET_PACKAGE_ID
          if (-not $packageId) {
            throw "WINGET_PACKAGE_ID env var is not set."
          }
          $version = $env:RELEASE_TAG
          if (-not $version) {
            throw "RELEASE_TAG env var is not set."
          }
          $installerUrl = $env:MSI_DOWNLOAD_URL
          if (-not $installerUrl) {
            throw "MSI_DOWNLOAD_URL env var is not set."
          }
          $gitToken = $env:WINGET_TOKEN
          if (-not $gitToken) {
            throw "env.WINGET_TOKEN is not configured in this repo."
          }
          Write-Host "Updating WinGet manifest for package '$packageId' version '$version'"
          Write-Host "Installer URL: $installerUrl"
          # Download latest single-file wingetcreate.exe
          Invoke-WebRequest https://aka.ms/wingetcreate/latest -OutFile wingetcreate.exe
          # Run wingetcreate update and capture output
          $args = @(
            "update", $packageId,
            "--version", $version,
            "--urls", $installerUrl,
            "--submit",
            "--token", $gitToken
          )
          Write-Host "Running: wingetcreate.exe $($args -join ' ')"
          $output = & .\wingetcreate.exe @args 2>&1
          $exitCode = $LASTEXITCODE
          $output | ForEach-Object { Write-Host $_ }
          if ($exitCode -ne 0) {
            if ($output -match "was not found") {
              Write-Warning "WinGet package '$packageId' was not found in microsoft/winget-pkgs. Skipping update (non-fatal)."
              Write-Warning "To create the initial package, run 'wingetcreate new' manually and submit the first PR."
              exit 0
            } else {
              throw "wingetcreate update failed with exit code $exitCode"
            }
          }
      - name: Skip WinGet publish (missing token)
        if: ${{ env.PUBLISH_WINGET == 'true' && (github.event_name == 'pull_request' || env.WINGET_TOKEN == '') }}
        run: echo "Skipping WinGet publish because WINGET_TOKEN is not available (expected on forks or PRs)."
      ###########################################################################
      # CHOCOLATEY PACKAGE BUILD & PUBLISH
      ###########################################################################

      - name: Build Chocolatey package
        if: ${{ env.PUBLISH_CHOCO == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"
          if (-not $env:MSI_PATH -or -not (Test-Path $env:MSI_PATH)) {
            throw "MSI_PATH is not set or file does not exist. Cannot build Chocolatey package."
          }
          if (-not $env:RELEASE_TAG) {
            throw "RELEASE_TAG is not set. Ensure 'Compute release tag' ran successfully."
          }
          $pkgRoot  = Join-Path $env:RUNNER_TEMP "choco"
          $toolsDir = Join-Path $pkgRoot "tools"
          if (Test-Path $pkgRoot) {
            Remove-Item $pkgRoot -Recurse -Force
          }
          New-Item -ItemType Directory -Force -Path $toolsDir | Out-Null
          # Copy MSI into tools directory
          Copy-Item $env:MSI_PATH (Join-Path $toolsDir "mirrord.msi") -Force
          # LICENSE.txt (required when shipping binaries)
          $licenseSource = Join-Path $env:GITHUB_WORKSPACE 'LICENSE'
          $licenseDest   = Join-Path $toolsDir 'LICENSE.txt'
          if (Test-Path $licenseSource) {
            Copy-Item $licenseSource $licenseDest -Force
          } else {
            Write-Warning "LICENSE file not found at $licenseSource; Chocolatey expects LICENSE.txt alongside binaries."
          }
          # VERIFICATION.txt (required when shipping binaries)
          $verificationPath = Join-Path $toolsDir 'VERIFICATION.txt'
          $hash = Get-FileHash $env:MSI_PATH -Algorithm SHA256
          $verificationLines = @()
          $verificationLines += 'VERIFICATION'
          $verificationLines += '------------'
          $verificationLines += ''
          $verificationLines += '1. Download the mirrord MSI from the official source:'
          $verificationLines += '   https://github.com/metalbear-co/mirrord/releases'
          $verificationLines += ''
          $verificationLines += '2. Verify the SHA256 checksum of the downloaded file matches:'
          $verificationLines += "   $($hash.Hash)"
          $verificationLines += ''
          $verificationLines += 'This installer is built from the source at:'
          $verificationLines += '   https://github.com/metalbear-co/mirrord'
          $verificationLines | Set-Content -Encoding UTF8 -Path $verificationPath
          $nuspecPath = Join-Path $pkgRoot "mirrord.nuspec"
          $version    = $env:RELEASE_TAG
          $releaseNotesUrl = "https://github.com/metalbear-co/mirrord/releases/tag/$version"
          $nuspecLines = @()
          $nuspecLines += '<?xml version="1.0"?>'
          $nuspecLines += '<package xmlns="http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd">'
          $nuspecLines += '  <metadata>'
          $nuspecLines += '    <id>mirrord</id>'
          $nuspecLines += "    <version>$version</version>"
          $nuspecLines += '    <title>mirrord (Kubernetes dev tool)</title>'
          $nuspecLines += '    <summary>Run local code in the context of your Kubernetes environment.</summary>'
          $nuspecLines += '    <authors>MetalBear</authors>'
          $nuspecLines += '    <owners>MetalBear</owners>'
          $nuspecLines += '    <licenseUrl>https://github.com/metalbear-co/mirrord/blob/main/LICENSE</licenseUrl>'
          $nuspecLines += '    <projectUrl>https://github.com/metalbear-co/mirrord</projectUrl>'
          $nuspecLines += '    <packageSourceUrl>https://github.com/metalbear-co/mirrord</packageSourceUrl>'
          $nuspecLines += '    <projectSourceUrl>https://github.com/metalbear-co/mirrord</projectSourceUrl>'
          $nuspecLines += '    <docsUrl>https://mirrord.dev</docsUrl>'
          $nuspecLines += '    <bugTrackerUrl>https://github.com/metalbear-co/mirrord/issues</bugTrackerUrl>'
          $nuspecLines += '    <iconUrl>https://raw.githubusercontent.com/metalbear-co/mirrord/main/assets/icon.png</iconUrl>'
          $nuspecLines += '    <requireLicenseAcceptance>false</requireLicenseAcceptance>'
          $nuspecLines += '    <description>mirrord lets you run local code in the context of your cloud environment (Kubernetes).</description>'
          $nuspecLines += "    <releaseNotes>$releaseNotesUrl</releaseNotes>"
          $nuspecLines += '    <tags>mirrord kubernetes debugging cloud</tags>'
          $nuspecLines += '  </metadata>'
          $nuspecLines += '  <files>'
          $nuspecLines += '    <file src="tools\**" target="tools" />'
          $nuspecLines += '  </files>'
          $nuspecLines += '</package>'
          $nuspecLines | Set-Content -Encoding UTF8 -Path $nuspecPath
          $installScript = Join-Path $toolsDir "chocolateyinstall.ps1"
          # single-quoted strings so $packageName / $msiPath stay literal in the script
          $installLines = @()
          $installLines += '$ErrorActionPreference = ''Stop'''
          $installLines += ''
          $installLines += '$packageName = ''mirrord'''
          $installLines += '$toolsDir    = Split-Path -Parent $MyInvocation.MyCommand.Definition'
          $installLines += '$msiPath     = Join-Path $toolsDir ''mirrord.msi'''
          $installLines += ''
          $installLines += 'Install-ChocolateyInstallPackage -PackageName $packageName -FileType ''msi'' -SilentArgs ''/qn /norestart'' -ValidExitCodes @(0, 3010) -File $msiPath'
          $installLines | Set-Content -Encoding UTF8 -Path $installScript
          # Ensure choco is available
          if (-not (Get-Command choco.exe -ErrorAction SilentlyContinue)) {
            throw "choco.exe not found on PATH. Ensure Chocolatey is installed on this runner."
          }
          choco pack $nuspecPath --outputdirectory $pkgRoot
          $nupkg = Get-ChildItem $pkgRoot -Filter "mirrord.$version.nupkg" -File -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $nupkg) {
            $nupkg = Get-ChildItem $pkgRoot -Filter "mirrord*.nupkg" -File | Select-Object -First 1
          }
          if (-not $nupkg) {
            throw "Failed to find generated mirrord nupkg in $pkgRoot"
          }
          "CHOCO_NUPKG_PATH=$($nupkg.FullName)" | Out-File -Append -FilePath $env:GITHUB_ENV
          Write-Host "Built Chocolatey package: $($nupkg.FullName)"
      - name: Push Chocolatey package
        # Skip on forks without CHOCO_API_KEY so they don't fail
        if: ${{ env.PUBLISH_CHOCO == 'true' && env.CHOCO_API_KEY != '' }}
        env:
          CHOCO_API_KEY: ${{ env.CHOCO_API_KEY }}
        run: |
          $ErrorActionPreference = "Stop"
          if (-not $env:CHOCO_NUPKG_PATH -or -not (Test-Path $env:CHOCO_NUPKG_PATH)) {
            throw "CHOCO_NUPKG_PATH is not set or file does not exist. Cannot push package."
          }
          if (-not $env:CHOCO_API_KEY) {
            throw "CHOCO_API_KEY is not set. Configure the repository secret 'CHOCO_API_KEY' with your Chocolatey API key."
          }
          Write-Host "Pushing Chocolatey package $env:CHOCO_NUPKG_PATH to Chocolatey.org..."
          choco push $env:CHOCO_NUPKG_PATH --api-key $env:CHOCO_API_KEY --source "https://push.chocolatey.org/"
      - name: Skip Chocolatey publish (missing key)
        if: ${{ env.PUBLISH_CHOCO == 'true' && env.CHOCO_API_KEY == '' }}
        run: echo "Skipping Chocolatey publish because CHOCO_API_KEY is not available (expected on forks)."
      ###########################################################################
      # SUMMARY
      ###########################################################################

      - name: Summary
        if: always()
        run: |
          Write-Host "MSI (local):       $env:MSI_PATH"
          Write-Host "MSI Version:       $env:MSI_VERSION"
          Write-Host "MSI (GCS URI):     $env:MSI_GCS_URI"
          Write-Host "EXE:               $env:MIRRORD_EXE"
          Write-Host "DLL:               $env:MIRRORD_LAYER_FILE"
          Write-Host "Choco package:     $env:CHOCO_NUPKG_PATH"
          Write-Host "MSI HTTP URL:      $env:MSI_DOWNLOAD_URL"
          Write-Host "Publish Choco:     $env:PUBLISH_CHOCO"
          Write-Host "Publish WinGet:    $env:PUBLISH_WINGET"