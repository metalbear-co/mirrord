name: Windows Build + Choco and WinGet

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Version to use for Chocolatey/WinGet (e.g. 0.0.1-test2). Defaults to MIRRORD_VERSION."
        required: false
        type: string
      msi_gcs_path:
        description: "GCS URI of the existing MSI to release (e.g. gs://mirrord-windows-builds-public/.../mirrord.msi)"
        required: true
        type: string
      runner:
        description: "Runner to execute on (Spot Instances)"
        type: choice
        options: 
          - "win-build-spot-2"
          - "win-build-spot-1"
        default: "win-build-spot-2"
      sign_artifacts:
        description: "Code-sign EXE & DLL & MSI (Ignored in this mode, assumes signed artifact)"
        type: choice
        options: ["false", "true"]
        default: "false"
      choco_publish:
        description: "Publish a Chocolatey package?"
        type: choice
        options: ["false", "true"]
        default: "false"
      winget_publish:
        description: "Update WinGet manifest (wingetcreate)?"
        type: choice
        options: ["false", "true"]
        default: "false"

  workflow_call:
    inputs:
      release_tag:
        description: "Version to use for Chocolatey/WinGet (e.g. 0.0.1-test2). Defaults to MIRRORD_VERSION."
        required: false
        type: string
      msi_gcs_path:
        description: "GCS URI of the existing MSI to release"
        required: false
        type: string
      runner:
        description: "Runner to execute on"
        type: string
        default: "win-build-spot-2"
      sign_artifacts:
        description: "Code-sign EXE & DLL & MSI"
        type: string
        default: "false"
      choco_publish:
        description: "Publish a Chocolatey package?"
        type: string
        default: "false"
      winget_publish:
        description: "Update WinGet manifest (wingetcreate)?"
        type: string
        default: "false"

env:
  MSI_BUCKET_URI: gs://mirrord-windows-builds-public
  RUST_BACKTRACE: "1"
  CARGO_NET_GIT_FETCH_WITH_CLI: "true"
  MIRRORD_TELEMETRY: "false"
  LIBCLANG_PATH: "C:\\Program Files\\LLVM\\bin"
  MSI_HTTP_BASE: "https://storage.googleapis.com/mirrord-windows-builds-public"
  WINGET_PACKAGE_ID: "MetalBear.mirrord"

jobs:
  windows_build:
    # Target selected spot instance (default spot-2)
    runs-on: ${{ inputs.runner }}
    permissions:
      contents: write
    defaults:
      run:
        shell: pwsh
    env:
      RELEASE_TAG_INPUT: ${{ inputs.release_tag || '' }}
      SIGN_ARTIFACTS: ${{ inputs.sign_artifacts || 'false' }}
      PUBLISH_CHOCO: ${{ inputs.choco_publish || 'false' }}
      PUBLISH_WINGET: ${{ inputs.winget_publish || 'false' }}
      CHOCO_API_KEY: ${{ secrets.CHOCO_API_KEY }}
      WINGET_TOKEN: ${{ secrets.WINGET_TOKEN }}
      GH_TOKEN: ${{ secrets.WINGET_TOKEN }}
      # Input GCS Path
      MSI_GCS_INPUT: ${{ inputs.msi_gcs_path }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download MSI from GCS
        run: |
          $ErrorActionPreference = "Stop"
          
          $gcsUri = $env:MSI_GCS_INPUT
          if (-not $gcsUri) {
            # Fallback if workflow_call didn't provide it but env passed it differently?
            # Or fail.
            throw "Input 'msi_gcs_path' is required for this release-only workflow."
          }
          
          Write-Host "Downloading MSI from: $gcsUri"
          
          # Create temp dir
          $downloadDir = Join-Path $env:RUNNER_TEMP "artifacts"
          New-Item -ItemType Directory -Force -Path $downloadDir | Out-Null
          
          $localPath = Join-Path $downloadDir "mirrord.msi"
          
          # Use gcloud
          gcloud storage cp $gcsUri $localPath
          
          if (-not (Test-Path $localPath)) {
             throw "Failed to download MSI to $localPath"
          }
          
          Write-Host "Downloaded to: $localPath"
          "MSI_PATH=$localPath"      | Out-File -Append -FilePath $env:GITHUB_ENV
          "MSI_GCS_URI=$gcsUri"      | Out-File -Append -FilePath $env:GITHUB_ENV
          
          if ($env:RELEASE_TAG_INPUT) {
             "RELEASE_TAG=$env:RELEASE_TAG_INPUT" | Out-File -Append -FilePath $env:GITHUB_ENV
          } else {
             Write-Warning "No release_tag input provided; assuming 0.0.0"
             "RELEASE_TAG=0.0.0" | Out-File -Append -FilePath $env:GITHUB_ENV
          }

      ###########################################################################
      # UPLOAD TO GITHUB RELEASE (Adapted for MSI only)
      ###########################################################################
      - name: Generate Checksums (MSI Only)
        if: env.RELEASE_TAG_INPUT != '' && github.event_name != 'pull_request'
        run: |
           $msi = $env:MSI_PATH
           if (Test-Path $msi) {
             (Get-FileHash $msi -Algorithm SHA256).Hash.ToLower() | Out-File -FilePath "$msi.sha256" -NoNewline -Encoding ascii
             "MSI_SHA256_FILE=$msi.sha256" | Out-File -Append -FilePath $env:GITHUB_ENV
           }

      - name: Upload artifacts to Release
        if: env.RELEASE_TAG_INPUT != '' && github.event_name != 'pull_request'
        uses: metalbear-co/action-gh-release@ab50eebb6488051c6788d97fa95232267c6a4e23
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          files: |
            ${{ env.MSI_PATH }}
            ${{ env.MSI_SHA256_FILE }}

      ###########################################################################
      # COMPUTE MSI DOWNLOAD URL (Dynamic from Input GCS)
      ###########################################################################
      - name: Compute MSI Download URL
        # Depends on MSI_GCS_URI being set
        if: ${{ env.RELEASE_TAG_INPUT != '' || env.PUBLISH_WINGET == 'true' || env.PUBLISH_CHOCO == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"
          
          $gcsUri = $env:MSI_GCS_URI
          if (-not $gcsUri) {
             throw "MSI_GCS_URI is not set."
          }
          
          # Convert gs://bucket/path/to/msi -> https://storage.googleapis.com/bucket/path/to/msi
          if ($gcsUri -match "^gs://(.+)$") {
             $path = $matches[1]
             $url = "https://storage.googleapis.com/$path"
          } else {
             throw "Unexpected GCS URI format: $gcsUri"
          }
          
          Write-Host "Computed MSI Download URL: $url"
          "MSI_DOWNLOAD_URL=$url" | Out-File -Append -FilePath $env:GITHUB_ENV
          
          # Verify URL accessibility
          try {
             $resp = Invoke-WebRequest -Uri $url -Method Head -ErrorAction Stop
             Write-Host "URL Verification: OK ($($resp.StatusCode))"
          } catch {
             Write-Warning "URL Verification FAILED: $($_.Exception.Message). Publishing may fail."
          }

      ###########################################################################
      # INSTALL .NET RUNTIME FOR WINGETCREATE
      ###########################################################################
      - name: Install .NET runtime for wingetcreate
        # Skip on forks without WINGET_TOKEN so they don't fail
        if: ${{ github.event_name != 'pull_request' && env.PUBLISH_WINGET == 'true' }}
        uses: actions/setup-dotnet@v4
        env:
          DOTNET_INSTALL_DIR: ${{ runner.temp }}\dotnet
        with:
          dotnet-version: '8.0.x'

      ###########################################################################
      # UPDATE WinGet MANIFEST (wingetcreate)
      ###########################################################################
      - name: Update WinGet manifest (wingetcreate)
        # Force run to debug why it was skipping. We check token inside script anyway.
        if: ${{ github.event_name != 'pull_request' && env.PUBLISH_WINGET == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"
          $packageId = $env:WINGET_PACKAGE_ID
          if (-not $packageId) {
            throw "WINGET_PACKAGE_ID env var is not set."
          }
          $version = $env:RELEASE_TAG
          if (-not $version) {
            throw "RELEASE_TAG env var is not set."
          }
          $installerUrl = $env:MSI_DOWNLOAD_URL
          if (-not $installerUrl) {
            throw "MSI_DOWNLOAD_URL env var is not set."
          }
          $gitToken = $env:WINGET_TOKEN
          if (-not $gitToken) {
            throw "env.WINGET_TOKEN is not configured in this repo."
          }

          Write-Host "Updating WinGet manifest for package '$packageId' version '$version'"
          Write-Host "Installer URL: $installerUrl"

          # Download latest single-file wingetcreate.exe
          Invoke-WebRequest https://aka.ms/wingetcreate/latest -OutFile wingetcreate.exe

          # Run wingetcreate update and capture output
          $args = @(
            "update", $packageId,
            "--version", $version,
            "--display-version", $version,
            "--urls", $installerUrl,
            "--submit",
            "--token", $gitToken
          )

          Write-Host "Running: wingetcreate.exe $($args -join ' ')"
          $output = & .\wingetcreate.exe @args 2>&1
          $exitCode = $LASTEXITCODE
          $output | ForEach-Object { Write-Host $_ }

          if ($exitCode -ne 0) {
            if ($output -match "was not found") {
              Write-Warning "WinGet package '$packageId' was not found in microsoft/winget-pkgs. Skipping update (non-fatal)."
              Write-Warning "To create the initial package, run 'wingetcreate new' manually and submit the first PR."
              exit 0
            } else {
              throw "wingetcreate update failed with exit code $exitCode"
            }
          }

      - name: Skip WinGet publish (missing token)
        if: ${{ env.PUBLISH_WINGET == 'true' && (github.event_name == 'pull_request' || env.WINGET_TOKEN == '') }}
        run: echo "Skipping WinGet publish because WINGET_TOKEN is not available (expected on forks or PRs)."

      ###########################################################################
      # CHOCOLATEY PACKAGE BUILD & PUBLISH
      ###########################################################################

      - name: Build Chocolatey package
        if: ${{ env.PUBLISH_CHOCO == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"
          if (-not $env:MSI_PATH -or -not (Test-Path $env:MSI_PATH)) {
            throw "MSI_PATH is not set or file does not exist. Cannot build Chocolatey package."
          }
          if (-not $env:RELEASE_TAG) {
            throw "RELEASE_TAG is not set. Ensure 'Compute release tag' ran successfully."
          }
          $pkgRoot  = Join-Path $env:RUNNER_TEMP "choco"
          $toolsDir = Join-Path $pkgRoot "tools"
          if (Test-Path $pkgRoot) {
            Remove-Item $pkgRoot -Recurse -Force
          }
          New-Item -ItemType Directory -Force -Path $toolsDir | Out-Null
          # Copy MSI into tools directory
          Copy-Item $env:MSI_PATH (Join-Path $toolsDir "mirrord.msi") -Force
          # LICENSE.txt (required when shipping binaries)
          $licenseSource = Join-Path $env:GITHUB_WORKSPACE 'LICENSE'
          $licenseDest   = Join-Path $toolsDir 'LICENSE.txt'
          if (Test-Path $licenseSource) {
            Copy-Item $licenseSource $licenseDest -Force
          } else {
            Write-Warning "LICENSE file not found at $licenseSource; Chocolatey expects LICENSE.txt alongside binaries."
          }
          # VERIFICATION.txt (required when shipping binaries)
          $verificationPath = Join-Path $toolsDir 'VERIFICATION.txt'
          $hash = Get-FileHash $env:MSI_PATH -Algorithm SHA256
          $verificationLines = @()
          $verificationLines += 'VERIFICATION'
          $verificationLines += '------------'
          $verificationLines += ''
          $verificationLines += '1. Download the mirrord MSI from the official source:'
          $verificationLines += '   https://github.com/metalbear-co/mirrord/releases'
          $verificationLines += ''
          $verificationLines += '2. Verify the SHA256 checksum of the downloaded file matches:'
          $verificationLines += "   $($hash.Hash)"
          $verificationLines += ''
          $verificationLines += 'This installer is built from the source at:'
          $verificationLines += '   https://github.com/metalbear-co/mirrord'
          $verificationLines | Set-Content -Encoding UTF8 -Path $verificationPath
          $nuspecPath = Join-Path $pkgRoot "mirrord.nuspec"
          $version    = $env:RELEASE_TAG
          $releaseNotesUrl = "https://github.com/metalbear-co/mirrord/releases/tag/$version"
          $nuspecLines = @()
          $nuspecLines += '<?xml version="1.0"?>'
          $nuspecLines += '<package xmlns="http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd">'
          $nuspecLines += '  <metadata>'
          $nuspecLines += '    <id>mirrord</id>'
          $nuspecLines += "    <version>$version</version>"
          $nuspecLines += '    <title>mirrord (Kubernetes dev tool)</title>'
          $nuspecLines += '    <summary>Run local code in the context of your Kubernetes environment.</summary>'
          $nuspecLines += '    <authors>MetalBear</authors>'
          $nuspecLines += '    <owners>MetalBear</owners>'
          $nuspecLines += '    <licenseUrl>https://github.com/metalbear-co/mirrord/blob/main/LICENSE</licenseUrl>'
          $nuspecLines += '    <projectUrl>https://github.com/metalbear-co/mirrord</projectUrl>'
          $nuspecLines += '    <packageSourceUrl>https://github.com/metalbear-co/mirrord</packageSourceUrl>'
          $nuspecLines += '    <projectSourceUrl>https://github.com/metalbear-co/mirrord</projectSourceUrl>'
          $nuspecLines += '    <docsUrl>https://mirrord.dev</docsUrl>'
          $nuspecLines += '    <bugTrackerUrl>https://github.com/metalbear-co/mirrord/issues</bugTrackerUrl>'
          $nuspecLines += '    <iconUrl>https://raw.githubusercontent.com/metalbear-co/mirrord/main/assets/icon.png</iconUrl>'
          $nuspecLines += '    <requireLicenseAcceptance>false</requireLicenseAcceptance>'
          $nuspecLines += '    <description>mirrord lets you run local code in the context of your cloud environment (Kubernetes).</description>'
          $nuspecLines += "    <releaseNotes>$releaseNotesUrl</releaseNotes>"
          $nuspecLines += '    <tags>mirrord kubernetes debugging cloud</tags>'
          $nuspecLines += '  </metadata>'
          $nuspecLines += '  <files>'
          $nuspecLines += '    <file src="tools\**" target="tools" />'
          $nuspecLines += '  </files>'
          $nuspecLines += '</package>'
          $nuspecLines | Set-Content -Encoding UTF8 -Path $nuspecPath
          $installScript = Join-Path $toolsDir "chocolateyinstall.ps1"
          # single-quoted strings so $packageName / $msiPath stay literal in the script
          $installLines = @()
          $installLines += '$ErrorActionPreference = ''Stop'''
          $installLines += ''
          $installLines += '$packageName = ''mirrord'''
          $installLines += '$toolsDir    = Split-Path -Parent $MyInvocation.MyCommand.Definition'
          $installLines += '$msiPath     = Join-Path $toolsDir ''mirrord.msi'''
          $installLines += ''
          $installLines += 'Install-ChocolateyInstallPackage -PackageName $packageName -FileType ''msi'' -SilentArgs ''/qn /norestart'' -ValidExitCodes @(0, 3010) -File $msiPath'
          $installLines | Set-Content -Encoding UTF8 -Path $installScript
          # Ensure choco is available
          if (-not (Get-Command choco.exe -ErrorAction SilentlyContinue)) {
            throw "choco.exe not found on PATH. Ensure Chocolatey is installed on this runner."
          }
          choco pack $nuspecPath --outputdirectory $pkgRoot
          $nupkg = Get-ChildItem $pkgRoot -Filter "mirrord.$version.nupkg" -File -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $nupkg) {
            $nupkg = Get-ChildItem $pkgRoot -Filter "mirrord*.nupkg" -File | Select-Object -First 1
          }
          if (-not $nupkg) {
            throw "Failed to find generated mirrord nupkg in $pkgRoot"
          }
          "CHOCO_NUPKG_PATH=$($nupkg.FullName)" | Out-File -Append -FilePath $env:GITHUB_ENV
          Write-Host "Built Chocolatey package: $($nupkg.FullName)"

      - name: Push Chocolatey package
        # Skip on forks without CHOCO_API_KEY so they don't fail
        if: ${{ env.PUBLISH_CHOCO == 'true' && env.CHOCO_API_KEY != '' }}
        env:
          CHOCO_API_KEY: ${{ env.CHOCO_API_KEY }}
        run: |
          $ErrorActionPreference = "Stop"
          if (-not $env:CHOCO_NUPKG_PATH -or -not (Test-Path $env:CHOCO_NUPKG_PATH)) {
            throw "CHOCO_NUPKG_PATH is not set or file does not exist. Cannot push package."
          }
          if (-not $env:CHOCO_API_KEY) {
            throw "CHOCO_API_KEY is not set. Configure the repository secret 'CHOCO_API_KEY' with your Chocolatey API key."
          }
          Write-Host "Pushing Chocolatey package $env:CHOCO_NUPKG_PATH to Chocolatey.org..."
          choco push $env:CHOCO_NUPKG_PATH --api-key $env:CHOCO_API_KEY --source "https://push.chocolatey.org/"

      - name: Skip Chocolatey publish (missing key)
        if: ${{ env.PUBLISH_CHOCO == 'true' && env.CHOCO_API_KEY == '' }}
        run: echo "Skipping Chocolatey publish because CHOCO_API_KEY is not available (expected on forks)."

      ###########################################################################
      # SUMMARY
      ###########################################################################

      - name: Summary
        if: always()
        run: |
          Write-Host "MSI (local):       $env:MSI_PATH"
          Write-Host "MSI (GCS URI):     $env:MSI_GCS_URI"
          Write-Host "Choco package:     $env:CHOCO_NUPKG_PATH"
          Write-Host "MSI HTTP URL:      $env:MSI_DOWNLOAD_URL"
          Write-Host "Publish Choco:     $env:PUBLISH_CHOCO"
          Write-Host "Publish WinGet:    $env:PUBLISH_WINGET"