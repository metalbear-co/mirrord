name: Windows tests (reuse/build & sign) + GCS upload on failure

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Pick artifacts from GCS (reuse) or build & sign now"
        type: choice
        options: [reuse, build_sign]
        default: reuse
      upload_on_fail:
        description: "Upload bundle to GCS when tests fail?"
        type: boolean
        default: false
      upload_gcs_prefix:
        description: "Subpath under BUCKET_URI to store failure bundles"
        type: string
        default: windows/builds-on-fail
  push:
  pull_request:
    branches: [main, "*staging*"]
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read

env:
  # GCS where we read (and optionally write) artifacts
  BUCKET_URI: gs://mirrord-windows-builds
  # Used in "reuse" mode to download a known set of artifacts
  ARTIFACT_SUBPATH: windows/mirrord-3.163.0-run70-0932953

  RUST_BACKTRACE: "1"
  CARGO_NET_GIT_FETCH_WITH_CLI: "true"
  MIRRORD_TELEMETRY: "false"
  LIBCLANG_PATH: "C:\\Program Files\\LLVM\\bin"

jobs:
  windows_tests:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh
    env:
      # Map dispatch inputs into env for easy access (with safe defaults for non-dispatch triggers)
      MODE: ${{ github.event.inputs.mode || 'reuse' }}
      UPLOAD_ON_FAIL: ${{ github.event.inputs.upload_on_fail || 'false' }}
      UPLOAD_GCS_PREFIX: ${{ github.event.inputs.upload_gcs_prefix || 'windows/builds-on-fail' }}

    steps:
      - name: Checkout repo (tests need sources)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Toolchain info
        run: |
          whoami
          rustc -V
          cargo -V
          rustup show

      # =========================
      # === MODE: REUSE (GCS) ===
      # =========================
      - name: Reuse | Pick Windows artifacts from GCS
        if: ${{ env.MODE == 'reuse' }}
        run: |
          $ErrorActionPreference = 'Stop'

          if (-not (Get-Command gcloud -ErrorAction SilentlyContinue)) {
            throw "gcloud not found on PATH. Please ensure the runner is authenticated and has gcloud installed."
          }

          $dest = Join-Path $env:RUNNER_TEMP 'picked'
          New-Item -ItemType Directory -Path $dest -Force | Out-Null

          Write-Host "Downloading from: $env:BUCKET_URI/$env:ARTIFACT_SUBPATH/*"
          gcloud --quiet storage cp "$($env:BUCKET_URI)/$($env:ARTIFACT_SUBPATH)/*" "$dest/"
          if ($LASTEXITCODE -ne 0) { throw "gcloud cp failed (check path or perms)" }

          Write-Host "Downloaded files:"; Get-ChildItem $dest | Format-Table Name,Length

          $wild = Join-Path $dest '*'
          $exe = (Get-ChildItem -Path $wild -Filter 'mirrord.exe' -File | Select-Object -First 1).FullName
          $dll = (Get-ChildItem -Path $wild -Filter 'mirrord_layer_win.dll' -File | Select-Object -First 1).FullName
          if (-not $dll) { $dll = (Get-ChildItem -Path $wild -Filter 'mirrord-layer-win.dll' -File | Select-Object -First 1).FullName }
          if (-not $dll) { $dll = (Get-ChildItem -Path $wild -Filter '*layer*.dll' -File | Select-Object -First 1).FullName }

          if (-not $exe -or -not $dll) {
            Write-Host "Files present:"; Get-ChildItem -Path $wild -File | Select Name,FullName | Format-Table
            throw "Did not find mirrord.exe or layer DLL under $dest"
          }

          # Unify the names we use everywhere from here
          "MIRRORD_EXE=$exe"                     | Out-File -FilePath $env:GITHUB_ENV -Append
          "MIRRORD_LAYER_FILE=$dll"              | Out-File -FilePath $env:GITHUB_ENV -Append
          "MIRRORD_TEST_USE_EXISTING_LIB=$dll"   | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "Picked EXE: $exe"
          Write-Host "Picked DLL: $dll"

      # ==============================
      # === MODE: BUILD & SIGN NOW ===
      # ==============================
      - name: Build & Sign | Build layer (DLL)
        if: ${{ env.MODE == 'build_sign' }}
        run: |
          $ErrorActionPreference = 'Stop'
          rustup target add x86_64-pc-windows-msvc
          cargo build -p mirrord-layer-win --target x86_64-pc-windows-msvc

      - name: Build & Sign | Locate package & set env
        if: ${{ env.MODE == 'build_sign' }}
        run: |
          $ErrorActionPreference = 'Stop'

          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg = $meta.packages | Where-Object {
            $_.targets | Where-Object { ($_."kind" -contains 'bin') -and ($_.name -eq 'mirrord') }
          } | Select-Object -First 1
          if (-not $pkg) {
            $names = ($meta.packages | ForEach-Object name) -join ', '
            throw "No bin target named 'mirrord' found. Workspace packages: $names"
          }

          $dllDbg = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord_layer_win.dll'
          $dllRel = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\release\mirrord_layer_win.dll'
          if     (Test-Path $dllDbg) { $dll = $dllDbg }
          elseif (Test-Path $dllRel) { $dll = $dllRel }
          else   { throw "Layer DLL not found. Expected at:`n  $dllDbg`n  $dllRel" }

          "MIRRORD_PKG=$($pkg.name)"        | Out-File -FilePath $env:GITHUB_ENV -Append
          "MIRRORD_VERSION=$($pkg.version)" | Out-File -FilePath $env:GITHUB_ENV -Append
          "MIRRORD_LAYER_FILE=$dll"         | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "Will build 'mirrord' from package: $($pkg.name) v$($pkg.version)"
          Write-Host "Layer DLL path: $dll"

      - name: Build & Sign | Build mirrord (bin)
        if: ${{ env.MODE == 'build_sign' }}
        run: |
          $ErrorActionPreference = 'Stop'
          cargo build -p "$env:MIRRORD_PKG" --bin mirrord --target x86_64-pc-windows-msvc

          $dbgDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug'
          $relDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\release'

          $exe = Join-Path $dbgDir 'mirrord.exe'
          if (!(Test-Path $exe)) {
            $exeRel = Join-Path $relDir 'mirrord.exe'
            if (Test-Path $exeRel) { $exe = $exeRel } else { throw "mirrord.exe not found at $exe or $exeRel" }
          }

          "MIRRORD_EXE=$exe" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Host "Built EXE: $exe"

      - name: Build & Sign | Code sign EXE + DLL (and verify)
        if: ${{ env.MODE == 'build_sign' }}
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:MIRRORD_EXE -or -not (Test-Path $env:MIRRORD_EXE)) { throw "MIRRORD_EXE not set/found" }
          if (-not $env:MIRRORD_LAYER_FILE -or -not (Test-Path $env:MIRRORD_LAYER_FILE)) { throw "MIRRORD_LAYER_FILE not set/found" }

          foreach ($f in @($env:MIRRORD_EXE, $env:MIRRORD_LAYER_FILE)) {
            Write-Host "Signing $f"
            & signtool.exe sign `
              /sha1 bfa0bea8d22265cb382d2d5dec55a6ffcff70bcb `
              /tr http://timestamp.digicert.com `
              /td SHA256 `
              /fd SHA256 `
              "$f"
            if ($LASTEXITCODE -ne 0) { throw "signtool sign failed for $f (exit $LASTEXITCODE)" }

            Write-Host "Verifying $f"
            & signtool.exe verify /pa "$f"
            if ($LASTEXITCODE -ne 0) { throw "signtool verify failed for $f (exit $LASTEXITCODE)" }
          }

      # ===========================
      # === Quick smoke checks ====
      # ===========================
      - name: Quick smoke (hash + signature + --version/--help)
        run: |
          $ErrorActionPreference = 'Stop'
          $exe = $env:MIRRORD_EXE
          $dll = $env:MIRRORD_LAYER_FILE
          if (-not (Test-Path $exe)) { throw "Missing exe at $exe" }
          if (-not (Test-Path $dll)) { throw "Missing dll at $dll" }

          $base = Split-Path $exe -Parent
          $sum = Join-Path $env:RUNNER_TEMP 'layer_win_summary.txt'
          Remove-Item $sum -ErrorAction SilentlyContinue

          function Get-ExpectedSha256([string]$shaFile) {
            if (-not (Test-Path $shaFile)) { return $null }
            $raw = Get-Content $shaFile -Raw
            return $raw.Split(" ",[System.StringSplitOptions]::RemoveEmptyEntries)[0].Trim().ToLower()
          }

          $exeShaFile = Join-Path $base 'mirrord.exe.sha256'
          $dllShaFile = Join-Path $base ((Split-Path $dll -Leaf) + '.sha256')
          if (-not (Test-Path $dllShaFile)) { $dllShaFile = Join-Path $base 'mirrord_layer_win.dll.sha256' }

          $exeHash = (Get-FileHash -Algorithm SHA256 $exe).Hash.ToLower()
          $dllHash = (Get-FileHash -Algorithm SHA256 $dll).Hash.ToLower()
          $exeExpect = Get-ExpectedSha256 $exeShaFile
          $dllExpect = Get-ExpectedSha256 $dllShaFile

          $lines = @()
          $lines += '## Windows smoke tests'
          $lines += ''
          $lines += ('**Picked/Build EXE**: `{0}`' -f $exe)
          $lines += ('**Picked/Build DLL**: `{0}`' -f $dll)
          $lines += ''
          $lines += '### SHA256'
          if ($exeExpect) { $lines += ('- mirrord.exe:  `{0}` (expected `{1}`) -> {2}' -f $exeHash, $exeExpect, ($(if ($exeHash -eq $exeExpect) {'OK'} else {'**MISMATCH**'}))) } else { $lines += ('- mirrord.exe:  `{0}` (no .sha256 file present)' -f $exeHash) }
          if ($dllExpect) { $lines += ('- layer dll:    `{0}` (expected `{1}`) -> {2}' -f $dllHash, $dllExpect, ($(if ($dllHash -eq $dllExpect) {'OK'} else {'**MISMATCH**'}))) } else { $lines += ('- layer dll:    `{0}` (no .sha256 file present)' -f $dllHash) }
          $lines += ''
          $lines += '### Code signing'
          if (Get-Command signtool.exe -ErrorAction SilentlyContinue) {
            & signtool.exe verify /pa $exe | Out-Null; $rcExe = $LASTEXITCODE
            & signtool.exe verify /pa $dll | Out-Null; $rcDll = $LASTEXITCODE
            $lines += ('- signtool mirrord.exe: {0}' -f ($(if ($rcExe -eq 0) {'OK'} else {"FAIL ($rcExe)"})))
            $lines += ('- signtool layer dll:   {0}' -f ($(if ($rcDll -eq 0) {'OK'} else {"FAIL ($rcDll)"})))
          } else {
            $lines += '- signtool.exe not found on PATH (skipping)'
          }
          $lines += ''
          $lines += '### CLI'
          $versionOut = & $exe --version 2>&1; $verRc = $LASTEXITCODE
          $helpOut = & $exe --help 2>&1;     $helpRc = $LASTEXITCODE
          $lines += ('- `mirrord.exe --version` exit code: {0}' -f $verRc)
          $lines += ''
          $lines += '```'
          $lines += $versionOut
          $lines += '```'
          $lines += ''
          $lines += ('- `mirrord.exe --help` exit code: {0}' -f $helpRc)
          $lines += ''
          $lines += '```'
          $lines += $helpOut
          $lines += '```'
          $lines += ''
          $lines -join "`n" | Out-File -FilePath $sum -Encoding utf8

      # ===============================
      # === Windows Rust unit tests ===
      # ===============================
      - name: mirrord-layer-win UT
        run: cargo test --target x86_64-pc-windows-msvc -p mirrord-layer-win
      - name: mirrord protocol UT
        run: cargo test --target x86_64-pc-windows-msvc -p mirrord-protocol
      - name: mirrord config UT
        run: cargo test --target x86_64-pc-windows-msvc -p mirrord-config
      - name: mirrord kube UT
        run: cargo test --target x86_64-pc-windows-msvc -p mirrord-kube --all-features
      - name: mirrord intproxy UT
        run: cargo test --target x86_64-pc-windows-msvc -p mirrord-intproxy
      - name: mirrord auth UT
        run: cargo test --target x86_64-pc-windows-msvc -p mirrord-auth
      - name: mirrord operator UT
        run: cargo test --target x86_64-pc-windows-msvc -p mirrord-operator --features "crd, client"
      - name: mirrord CLI UT (embed the chosen DLL)
        env:
          MIRRORD_LAYER_FILE: ${{ env.MIRRORD_LAYER_FILE }}
        run: cargo test --target x86_64-pc-windows-msvc -p mirrord

      # ==================================
      # === Pretty summary to step tab ===
      # ==================================
      - name: Publish Windows test results (summary table, sandboxed)
        if: always()
        run: |
          $ErrorActionPreference = 'Stop'

          $exe = $env:MIRRORD_EXE
          $dll = $env:MIRRORD_LAYER_FILE
          if (-not (Test-Path $exe)) { throw "Missing exe at $exe" }
          if (-not (Test-Path $dll)) { throw "Missing dll at $dll" }
          $base = Split-Path $exe -Parent

          function Get-ExpectedSha256([string]$shaFile) {
            if (-not (Test-Path $shaFile)) { return $null }
            $raw = Get-Content $shaFile -Raw
            $raw.Split(" ",[System.StringSplitOptions]::RemoveEmptyEntries)[0].Trim().ToLower()
          }

          $exeShaFile = Join-Path $base 'mirrord.exe.sha256'
          $dllShaFile = Join-Path $base ((Split-Path $dll -Leaf) + '.sha256')
          if (-not (Test-Path $dllShaFile)) { $dllShaFile = Join-Path $base 'mirrord_layer_win.dll.sha256' }

          $exeHash   = (Get-FileHash -Algorithm SHA256 $exe).Hash.ToLower()
          $dllHash   = (Get-FileHash -Algorithm SHA256 $dll).Hash.ToLower()
          $exeExpect = Get-ExpectedSha256 $exeShaFile
          $dllExpect = Get-ExpectedSha256 $dllShaFile
          $shaExeOk  = ($exeExpect -and $exeHash -eq $exeExpect)
          $shaDllOk  = ($dllExpect -and $dllHash -eq $dllExpect)

          $sigExe = $null; $sigDll = $null
          if (Get-Command signtool.exe -ErrorAction SilentlyContinue) {
            & signtool.exe verify /pa $exe | Out-Null; $sigExe = ($LASTEXITCODE -eq 0)
            & signtool.exe verify /pa $dll | Out-Null; $sigDll = ($LASTEXITCODE -eq 0)
          }

          # DLL load/unload in child so crashes don't kill the step
          $dllLoadOk = $false
          $dllCrash = $false
          $loader = @"
          try {
            Add-Type -TypeDefinition @'
          using System;
          using System.Runtime.InteropServices;
          public static class L {
            [DllImport("kernel32.dll", SetLastError=true, CharSet=CharSet.Unicode)]
            public static extern IntPtr LoadLibrary(string lpFileName);
            [DllImport("kernel32.dll", SetLastError=true)]
            public static extern bool FreeLibrary(IntPtr hModule);
          }
          '@;
            var ptr = L.LoadLibrary(@"{($dll -replace '"','""')}");
            if (ptr == IntPtr.Zero) Environment.Exit(2);
            L.FreeLibrary(ptr);
            Environment.Exit(0);
          } catch { Environment.Exit(3); }
          "@
          $loaderPath = Join-Path $env:RUNNER_TEMP 'dll_load_test.ps1'
          Set-Content -Path $loaderPath -Value $loader -Encoding UTF8
          $p = Start-Process pwsh -ArgumentList '-NoProfile','-NonInteractive','-File', $loaderPath -Wait -PassThru
          $childExit = $p.ExitCode
          if ($childExit -eq 0) { $dllLoadOk = $true }
          if ($childExit -eq 3221225477 -or $childExit -eq -1073741819) { $dllCrash = $true }

          $verRc = $null; $verText = ""
          try { $verText = & $exe --version 2>&1; $verRc = $LASTEXITCODE } catch { $verRc = -1; $verText = $_.ToString() }
          $helpRc = $null; $helpText = ""
          try { $helpText = & $exe --help 2>&1;    $helpRc = $LASTEXITCODE } catch { $helpRc = -1; $helpText = $_.ToString() }

          $exeSize = (Get-Item $exe).Length
          $dllSize = (Get-Item $dll).Length

          $rows = @()
          $rows += [pscustomobject]@{ Check='SHA256 (exe)';  Result=($(if($shaExeOk){'✅ OK'}else{'❌ Mismatch/None'})); Notes= "hash=$exeHash expected=$exeExpect" }
          $rows += [pscustomobject]@{ Check='SHA256 (dll)';  Result=($(if($shaDllOk){'✅ OK'}else{'❌ Mismatch/None'})); Notes= "hash=$dllHash expected=$dllExpect" }
          $rows += [pscustomobject]@{ Check='Signing (exe)'; Result=($(if($sigExe -eq $true){'✅ Verified'}elseif($sigExe -eq $false){'❌ Failed'}else{'⚠️ Skipped'})); Notes= 'signtool verify /pa' }
          $rows += [pscustomobject]@{ Check='Signing (dll)'; Result=($(if($sigDll -eq $true){'✅ Verified'}elseif($sigDll -eq $false){'❌ Failed'}else{'⚠️ Skipped'})); Notes= 'signtool verify /pa' }
          $rows += [pscustomobject]@{ Check='DLL load/unload'; Result=($(if($dllLoadOk){'✅ OK'}elseif($dllCrash){'❌ Crash'}else{'❌ Failed'})); Notes= "child-exit=$childExit" }
          $rows += [pscustomobject]@{ Check='CLI --version';  Result="exit $verRc"; Notes= ($verText -split "`n")[0] }
          $rows += [pscustomobject]@{ Check='CLI --help';     Result="exit $helpRc"; Notes= ($helpText -split "`n")[0] }
          $rows += [pscustomobject]@{ Check='File sizes';     Result=''; Notes= "exe=$exeSize bytes; dll=$dllSize bytes" }

          $md = @()
          $md += '### Windows test results'
          $md += ''
          $md += ('**Mode:** `{0}`  ' -f $env:MODE)
          $md += ('**EXE:** `{0}`  ' -f $exe)
          $md += ('**DLL:** `{0}`' -f $dll)
          $md += ''
          $md += '| Check | Result | Notes |'
          $md += '|------:|:------:|-------|'
          foreach ($r in $rows) {
            $c = ($r.Check  -replace '\|','\|')
            $res = ($r.Result -replace '\|','\|')
            $n = ($r.Notes  -replace '\r',' ' -replace '\n',' ' -replace '\|','\|')
            $md += "| $c | $res | $n |"
          }
          $md += ''
          $md += '<sub>DLL load runs in a child process to avoid crashing the job. See step logs for full outputs.</sub>'

          $md -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append

      # ==================================================
      # === Package outputs so we can upload to GCS on fail
      # ==================================================
      - name: Package build/downloaded outputs (for potential GCS upload)
        if: always()
        run: |
          $ErrorActionPreference = 'Stop'

          $exe = $env:MIRRORD_EXE
          $dll = $env:MIRRORD_LAYER_FILE
          if (-not (Test-Path $exe)) { Write-Host "No EXE to package."; $exe = $null }
          if (-not (Test-Path $dll)) { Write-Host "No DLL to package."; $dll = $null }

          $bundle = Join-Path $env:RUNNER_TEMP 'upload_bundle'
          New-Item -ItemType Directory -Path $bundle -Force | Out-Null

          if ($exe) {
            Copy-Item $exe $bundle -Force
            (Get-FileHash -Algorithm SHA256 $exe).Hash | Set-Content (Join-Path $bundle 'mirrord.exe.sha256.txt')
          }
          if ($dll) {
            Copy-Item $dll $bundle -Force
            (Get-FileHash -Algorithm SHA256 $dll).Hash | Set-Content (Join-Path $bundle 'mirrord_layer_win.dll.sha256.txt')
          }

          $sum = Join-Path $env:RUNNER_TEMP 'layer_win_summary.txt'
          if (Test-Path $sum) { Copy-Item $sum $bundle -Force }

          # Compute a clean destination prefix inside the bucket
          $ref = ${env:GITHUB_REF_NAME}
          if (-not $ref) { $ref = 'no-ref' }
          $safeRef = ($ref -replace '[^A-Za-z0-9._-]','_')
          $sha7 = ${env:GITHUB_SHA}.Substring(0,7)
          $ts = Get-Date -Format 'yyyyMMdd-HHmmss'

          $prefix = $env:UPLOAD_GCS_PREFIX
          if (-not $prefix) { $prefix = 'windows/builds-on-fail' }

          $dst = ("{0}/{1}/run-{2}-{3}/{4}/{5}" -f ($env:BUCKET_URI.TrimEnd('/')), $prefix.Trim('/'), $env:GITHUB_RUN_ID, $env:GITHUB_RUN_ATTEMPT, $safeRef, $sha7)

          "BUNDLE_DIR=$bundle" | Out-File -FilePath $env:GITHUB_ENV -Append
          "GCS_UPLOAD_DST=$dst/$ts" | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "Prepared bundle: $bundle"
          Write-Host "Planned GCS destination: $($env:GCS_UPLOAD_DST)"

      # ==========================================
      # === Upload to Google Cloud Storage on fail
      # ==========================================
      - name: Upload bundle to GCS (only on failure & enabled)
        if: ${{ failure() && (env.UPLOAD_ON_FAIL == 'true') }}
        run: |
          $ErrorActionPreference = 'Stop'

          if (-not (Get-Command gcloud -ErrorAction SilentlyContinue)) {
            throw "gcloud not found on PATH. Please ensure the runner is authenticated and has gcloud installed."
          }

          if (-not $env:BUNDLE_DIR -or -not (Test-Path $env:BUNDLE_DIR)) {
            Write-Warning "Bundle dir not found: $env:BUNDLE_DIR"
            exit 0
          }
          if (-not $env:GCS_UPLOAD_DST) {
            throw "GCS_UPLOAD_DST not set."
          }

          Write-Host "Uploading $env:BUNDLE_DIR to $env:GCS_UPLOAD_DST ..."
          gcloud --quiet storage cp -r "$env:BUNDLE_DIR" "$env:GCS_UPLOAD_DST"
          if ($LASTEXITCODE -ne 0) {
            throw "gcloud storage cp failed with exit code $LASTEXITCODE"
          }

          Write-Host "Upload complete. Listing destination:"
          gcloud --quiet storage ls "$env:GCS_UPLOAD_DST"
