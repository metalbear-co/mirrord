name: Windows â€“ reuse prebuilt & run tests

on:
  workflow_dispatch: {}

env:
  # Where the artifacts live
  BUCKET_URI: gs://mirrord-windows-builds
  # Fixed path you asked to assume:
  ARTIFACT_SUBPATH: windows/mirrord-3.163.0-run70-0932953

  # Common env
  RUST_BACKTRACE: "1"
  CARGO_NET_GIT_FETCH_WITH_CLI: "true"
  MIRRORD_TELEMETRY: "false"
  # If LLVM is installed in a custom path on your runner, update this (used by frida-gum/bindgen)
  LIBCLANG_PATH: C:\Program Files\LLVM\bin

jobs:
  windows-tests:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Toolchain info
        shell: pwsh
        run: |
          Write-Host "whoami: $(whoami)"
          Write-Host "PowerShell: $($PSVersionTable.PSVersion)"
          rustc -V
          cargo -V
          rustup show
          if (Get-Command signtool.exe -ErrorAction SilentlyContinue) {
            Write-Host "signtool: OK"
          } else {
            Write-Host "signtool: not found"
          }
          if (Test-Path "$env:LIBCLANG_PATH\libclang.dll") {
            Write-Host "libclang: $env:LIBCLANG_PATH\libclang.dll"
          }


      - name: Ensure MSVC target
        run: rustup target add x86_64-pc-windows-msvc

      # ---------- Pick the prebuilt Windows artifacts from GCS ----------
      - name: Download chosen Windows build
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $dest = Join-Path $env:RUNNER_TEMP 'picked'
          New-Item -ItemType Directory -Path $dest -Force | Out-Null

          Write-Host "Downloading from: $env:BUCKET_URI/$env:ARTIFACT_SUBPATH/*"
          gcloud --quiet storage cp "$($env:BUCKET_URI)/$($env:ARTIFACT_SUBPATH)/*" "$dest/"
          if ($LASTEXITCODE -ne 0) { throw "gcloud cp failed (check path or perms)" }

          Write-Host "Downloaded files:"
          Get-ChildItem $dest | Format-Table Name,Length -HideTableHeaders

          # Resolve files (don't use -Include without wildcard/recurse)
          $exe = Get-Item -Path (Join-Path $dest 'mirrord.exe') -ErrorAction SilentlyContinue
          $dll = $null
          foreach ($candidate in @('mirrord_layer_win.dll','mirrord-layer-win.dll')) {
            $p = Join-Path $dest $candidate
            if (Test-Path $p) { $dll = Get-Item $p; break }
          }
          if (-not $dll) {
            # Fallback: any file with "layer" in name
            $dll = Get-ChildItem -Path $dest -File | Where-Object { $_.Name -like '*layer*.dll' } | Select-Object -First 1
          }

          if (-not $exe -or -not $dll) {
            Write-Host "Files present:"; Get-ChildItem $dest -File | Select Name,FullName | Format-Table -HideTableHeaders
            throw "Did not find mirrord.exe or layer DLL under $dest"
          }

          "MIRRORD_DOWNLOADED_EXE=$($exe.FullName)"        | Out-File -FilePath $env:GITHUB_ENV -Append
          "MIRRORD_LAYER_FILE=$($dll.FullName)"            | Out-File -FilePath $env:GITHUB_ENV -Append
          "MIRRORD_TEST_USE_EXISTING_LIB=$($dll.FullName)" | Out-File -FilePath $env:GITHUB_ENV -Append

          Write-Host "exe: $($exe.FullName)"
          Write-Host "dll: $($dll.FullName)"
        env:
          BUCKET_URI: gs://mirrord-windows-builds
          ARTIFACT_SUBPATH: windows/mirrord-3.163.0-run70-0932953


      - name: Show picked files
        run: |
          Write-Host "exe:  $env:MIRRORD_DOWNLOADED_EXE"
          Write-Host "dll:  $env:MIRRORD_LAYER_FILE"
          Get-Item $env:MIRRORD_LAYER_FILE | Format-List FullName,Length,LastWriteTime

      # ---------- Sanity check DLL without executing DllMain ----------
      - name: Map DLL without running DllMain (LoadLibraryEx)
        run: |
          $dll = $env:MIRRORD_LAYER_FILE
          if (-not (Test-Path $dll)) { throw "Layer DLL not found at $dll" }

          $csPath = Join-Path $env:RUNNER_TEMP 'WinApi_LoadEx.cs'
          $lines = @(
            'using System;',
            'using System.Runtime.InteropServices;',
            'namespace Util {',
            '  public static class WinApi {',
            '    [DllImport("kernel32.dll", SetLastError=true, CharSet=CharSet.Unicode)]',
            '    public static extern IntPtr LoadLibraryEx(string lpFileName, IntPtr hFile, uint dwFlags);',
            '  }',
            '}'
          )
          Set-Content -Path $csPath -Value $lines -Encoding UTF8
          Add-Type -Path $csPath

          $DONT_RESOLVE_DLL_REFERENCES = 0x00000001
          $h = [Util.WinApi]::LoadLibraryEx($dll, [IntPtr]::Zero, $DONT_RESOLVE_DLL_REFERENCES)
          if ($h -eq [IntPtr]::Zero) {
            $err = [Runtime.InteropServices.Marshal]::GetLastWin32Error()
            throw "LoadLibraryEx(DONT_RESOLVE_DLL_REFERENCES) failed for $dll (Win32 $err)"
          }
          Write-Host "DLL mapped OK (no DllMain executed): $dll"

      - name: (Optional) Verify signature
        if: ${{ always() }}
        continue-on-error: true
        run: |
          if (Get-Command "signtool.exe" -ErrorAction SilentlyContinue) {
            & signtool.exe verify /pa "$env:MIRRORD_LAYER_FILE"
            if ($LASTEXITCODE -ne 0) { throw "Signature verify failed for $env:MIRRORD_LAYER_FILE" }
            Write-Host "Signature OK for $env:MIRRORD_LAYER_FILE"
          } else {
            Write-Host "signtool.exe not found; skipping signature verify."
          }

      # ---------- Run Windows tests ----------
      - name: List mirrord-layer-win tests
        run: |
          $log = Join-Path $env:RUNNER_TEMP "layer_win_tests_list.txt"
          cargo test -p mirrord-layer-win --target x86_64-pc-windows-msvc -- --list 2>&1 | Tee-Object -FilePath $log
          Write-Host "Saved list to $log"

      - name: Run mirrord-layer-win tests
        env:
          MIRRORD_TEST_USE_EXISTING_LIB: ${{ env.MIRRORD_LAYER_FILE }}
        run: |
          $log = Join-Path $env:RUNNER_TEMP "layer_win_tests.log"
          cargo test -p mirrord-layer-win --target x86_64-pc-windows-msvc -- --nocapture 2>&1 | Tee-Object -FilePath $log

          # Fail if zero tests ran
          $txt = Get-Content $log -Raw
          $m = [regex]::Matches($txt, 'running\s+(\d+)\s+tests')
          $total = 0
          foreach ($x in $m) { $total += [int]$x.Groups[1].Value }
          if ($total -lt 1) {
            Write-Host $txt
            throw "No mirrord-layer-win tests ran. Check crate filters / configuration."
          }
          Write-Host "Total tests reported by harness: $total"
          # Soft report of suite results
          $ok = ([regex]::Matches($txt, 'test result:\s+ok\.')).Count
          $fail = ([regex]::Matches($txt, 'test result:\s+FAILED\.')).Count
          "OK suites: $ok; FAILED suites: $fail" | Tee-Object -FilePath (Join-Path $env:RUNNER_TEMP 'layer_win_summary.txt')

      - name: (Optional) Run mirrord CLI unit tests on Windows
        continue-on-error: true
        env:
          MIRRORD_LAYER_FILE: ${{ env.MIRRORD_LAYER_FILE }}   # for include_bytes! at compile-time
        run: |
          $log = Join-Path $env:RUNNER_TEMP "cli_tests.log"
          cargo test -p mirrord --target x86_64-pc-windows-msvc -- --nocapture 2>&1 | Tee-Object -FilePath $log
          Write-Host "CLI tests done (optional). Log: $log"

      - name: Upload Windows test logs
        uses: actions/upload-artifact@v4
        with:
          name: windows-test-logs
          path: |
            ${{ runner.temp }}\layer_win_tests_list.txt
            ${{ runner.temp }}\layer_win_tests.log
            ${{ runner.temp }}\layer_win_summary.txt
            ${{ runner.temp }}\cli_tests.log
          if-no-files-found: warn

      - name: Job summary
        if: ${{ always() }}
        run: |
          $sum = Join-Path $env:RUNNER_TEMP 'layer_win_summary.txt'
          $dll = $env:MIRRORD_LAYER_FILE
          $exe = $env:MIRRORD_DOWNLOADED_EXE
          $out = @()
          $out += "### Windows tests summary"
          $out += ""
          $out += "* Picked EXE: `$exe`"
          $out += "* Picked DLL: `$dll`"
          if (Test-Path $sum) {
            $out += ""
            $out += (Get-Content $sum -Raw)
          } else {
            $out += ""
            $out += "_No summary file (tests may not have run)._"
          }
          $out -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append







### THIS PART WORKS ###
# name: Windows mirrord build and cert signing

# on:
#   workflow_dispatch:

# permissions:
#   contents: read

# jobs:
#   build:
#     runs-on: [self-hosted, Windows]
#     defaults:
#       run:
#         shell: pwsh
#     env:
#       BUCKET_URI: gs://mirrord-windows-builds

#     steps:
#       - name: Checkout windows branch
#         uses: actions/checkout@v4
#         with:
#           ref: windows-builds-gh
#           fetch-depth: 0
#           submodules: recursive

#       - name: Identity & DigiCert healthcheck
#         run: |
#           $ErrorActionPreference = 'Stop'
#           whoami
#           Write-Host "SM_HOST=$env:SM_HOST"
#           Write-Host "SM_CLIENT_CERT_FILE=$env:SM_CLIENT_CERT_FILE"
#           smctl --version
#           smctl healthcheck

#       - name: Ensure Rust MSVC target
#         run: rustup target add x86_64-pc-windows-msvc

#       # --- Build the layer FIRST so include_bytes! can find it ---
#       - name: Build mirrord-layer-win (DLL)
#         run: cargo build -p mirrord-layer-win --target x86_64-pc-windows-msvc

#       - name: Locate package for bin "mirrord" + set envs (package, version, layer path)
#         run: |
#           $ErrorActionPreference = 'Stop'

#           # Which package contains bin "mirrord"?
#           $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
#           $pkg = $meta.packages | Where-Object {
#             $_.targets | Where-Object { ($_."kind" -contains 'bin') -and ($_.name -eq 'mirrord') }
#           } | Select-Object -First 1
#           if (-not $pkg) {
#             $names = ($meta.packages | ForEach-Object name) -join ', '
#             throw "No bin target named 'mirrord' found. Workspace packages: $names"
#           }

#           "MIRRORD_PKG=$($pkg.name)"           | Out-File -FilePath $env:GITHUB_ENV -Append
#           "MIRRORD_VERSION=$($pkg.version)"    | Out-File -FilePath $env:GITHUB_ENV -Append

#           # IMPORTANT: underscores in the produced DLL name
#           $dllDbg = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord_layer_win.dll'
#           $dllRel = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\release\mirrord_layer_win.dll'
#           if     (Test-Path $dllDbg) { $dll = $dllDbg }
#           elseif (Test-Path $dllRel) { $dll = $dllRel }
#           else   { throw "Layer DLL not found. Expected at:`n  $dllDbg`n  $dllRel" }

#           "MIRRORD_LAYER_FILE=$dll"            | Out-File -FilePath $env:GITHUB_ENV -Append
#           Write-Host "Will embed layer DLL from: $dll"
#           Write-Host "Will build bin 'mirrord' from package: $($pkg.name) v$($pkg.version)"

#           # Print size for sanity
#           Get-Item $dll | Format-List FullName,Length,LastWriteTime

#       # --- Build the CLI AFTER the layer exists & env var is set ---
#       - name: Build mirrord (bin)
#         run: cargo build -p "$env:MIRRORD_PKG" --bin mirrord --target x86_64-pc-windows-msvc

#       - name: Code sign mirrord.exe + layer DLL (thumbprint) + verify
#         run: |
#           $ErrorActionPreference = 'Stop'

#           $dbgDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug'
#           $relDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\release'

#           # Resolve exe (prefer Debug, fallback Release)
#           $exe = Join-Path $dbgDir 'mirrord.exe'
#           if (!(Test-Path $exe)) {
#             $exeRel = Join-Path $relDir 'mirrord.exe'
#             if (Test-Path $exeRel) { $exe = $exeRel } else { throw "Expected mirrord.exe not found at $exe or $exeRel" }
#           }

#           # Resolve dll (prefer env, else common locations)
#           $dllCandidates = @()
#           if ($env:MIRRORD_LAYER_FILE) { $dllCandidates += $env:MIRRORD_LAYER_FILE }
#           $dllCandidates += @(
#             (Join-Path $dbgDir 'mirrord_layer_win.dll'),
#             (Join-Path $relDir 'mirrord_layer_win.dll')
#           )
#           $dll = $dllCandidates | Where-Object { $_ -and (Test-Path $_) } | Select-Object -First 1
#           if (-not $dll) {
#             $list = ($dllCandidates | ForEach-Object { $_ }) -join [Environment]::NewLine
#             throw ("Layer DLL not found. Looked for:{0}{1}" -f [Environment]::NewLine, $list)
#           }

#           foreach ($f in @($exe, $dll)) {
#             Write-Host "Signing $f"
#             & signtool.exe sign `
#               /sha1 bfa0bea8d22265cb382d2d5dec55a6ffcff70bcb `
#               /tr http://timestamp.digicert.com `
#               /td SHA256 `
#               /fd SHA256 `
#               "$f"
#             if ($LASTEXITCODE -ne 0) { throw "signtool sign failed for $f (exit $LASTEXITCODE)" }

#             Write-Host "Verifying $f"
#             & signtool.exe verify /pa "$f"
#             if ($LASTEXITCODE -ne 0) { throw "signtool verify failed for $f (exit $LASTEXITCODE)" }
#           }

#       - name: Stage and upload signed artifacts to GCS
#         run: |
#           $ErrorActionPreference = 'Stop'
#           if (-not $env:BUCKET_URI) { throw "BUCKET_URI env is empty. Set gs://<bucket> at job.env." }

#           $dbgDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug'
#           $relDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\release'

#           # Resolve exe and dll like above
#           $exe = (Get-Item -EA SilentlyContinue (Join-Path $dbgDir 'mirrord.exe'))
#           if (-not $exe) { $exe = Get-Item -EA Stop (Join-Path $relDir 'mirrord.exe') }

#           $dll = $env:MIRRORD_LAYER_FILE
#           if (-not $dll -or !(Test-Path $dll)) {
#             $dll = (Get-ChildItem -Path $dbgDir -Filter 'mirrord_layer_win.dll' -EA SilentlyContinue | Select-Object -First 1).FullName
#             if (-not $dll) {
#               $dll = (Get-ChildItem -Path $relDir -Filter 'mirrord_layer_win.dll' -EA SilentlyContinue | Select-Object -First 1).FullName
#             }
#             if (-not $dll) { throw "Layer DLL not found in debug or release directories." }
#           }

#           $staging = Join-Path $env:RUNNER_TEMP 'artifacts'
#           New-Item -ItemType Directory -Path $staging -Force | Out-Null
#           Copy-Item $exe.FullName -Destination $staging -Force
#           Copy-Item $dll        -Destination (Join-Path $staging (Split-Path $dll -Leaf)) -Force

#           # Show what we staged (helps debugging)
#           Write-Host "Staged files:"; Get-ChildItem $staging | Format-Table Name,Length

#           # Make checksums
#           Get-ChildItem -Path (Join-Path $staging '*') -Include *.exe,*.dll | ForEach-Object {
#             $h = Get-FileHash -Algorithm SHA256 $_.FullName
#             "$($h.Hash)  $($_.Name)" | Out-File (Join-Path $staging "$($_.Name).sha256") -Encoding ascii
#           }

#           # Collect files (NOTE the wildcard so -Include works)
#           $files = Get-ChildItem -Path (Join-Path $staging '*') -Include *.exe,*.dll,*.sha256 -File
#           if (-not $files) { throw "No artifacts found in $staging" }

#           $version = if ($env:MIRRORD_VERSION) { $env:MIRRORD_VERSION } else { 'unknown' }
#           $sha7 = $env:GITHUB_SHA.Substring(0,7)
#           $artifactDir = "windows/mirrord-$version-run$($env:GITHUB_RUN_NUMBER)-$sha7"
#           $dest = "$($env:BUCKET_URI)/$artifactDir/"
#           Write-Host "Uploading to $dest"

#           foreach ($f in $files) {
#             gcloud --quiet storage cp $($f.FullName) $dest
#             if ($LASTEXITCODE -ne 0) { throw "gcloud cp failed for $($f.Name) (exit $LASTEXITCODE)" }
#           }

#           gcloud --quiet storage ls $dest
