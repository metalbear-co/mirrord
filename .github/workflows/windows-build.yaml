name: Windows Build

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Pick artifacts from GCS (reuse) or build & sign now"
        type: choice
        options: [build_sign, reuse]
        default: build_sign
      release:
        description: "Publish a GitHub Release?"
        type: choice
        options: [no, draft, prerelease, release]
        default: no
      release_tag:
        description: "Release tag (defaults to pushed tag or v<MIRRORD_VERSION>)"
        required: false
        type: string
      sign_artifacts:
        description: "Code-sign EXE & DLL"
        type: choice
        options: ["false", "true"]
        default: false

  push:
    paths-ignore:
      - "*.md"
      - "**/*.md"

  pull_request:
    branches: ["main", "*staging*", "windows-support"]
    types: [opened, synchronize, reopened, ready_for_review]
    paths-ignore:
      - "*.md"
      - "**/*.md"

permissions:
  contents: write

env:
  BUCKET_URI: gs://mirrord-windows-builds
  MSI_BUCKET_URI: gs://mirrord-windows-msi
  ARTIFACT_SUBPATH: windows/mirrord-latest
  RUST_BACKTRACE: "1"
  CARGO_NET_GIT_FETCH_WITH_CLI: "true"
  MIRRORD_TELEMETRY: "false"
  LIBCLANG_PATH: "C:\\Program Files\\LLVM\\bin"

jobs:
  windows_tests:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh
    env:
      MODE: ${{ github.event.inputs.mode || 'build_sign' }}
      PUBLISH_MODE: ${{ github.event.inputs.release || 'no' }}
      RELEASE_TAG_INPUT: ${{ github.event.inputs.release_tag || '' }}
      SIGN_ARTIFACTS: ${{ github.event.inputs.sign_artifacts || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Toolchain info
        run: |
          $ErrorActionPreference = "Stop"
          whoami
          rustc -V
          cargo -V
          rustup show

      ###########################################################################
      # PREPARE ARTIFACTS (either reuse from GCS OR build+sign)
      ###########################################################################

      - name: Prepare artifacts
        id: prep
        run: |
          $ErrorActionPreference = "Stop"
          function Set-Env([string]$k,[string]$v){ "$k=$v" | Out-File -Append -FilePath $env:GITHUB_ENV }

          $Target = "x86_64-pc-windows-msvc"
          $DbgDir = Join-Path $env:GITHUB_WORKSPACE "target\$Target\debug"
          $RelDir = Join-Path $env:GITHUB_WORKSPACE "target\$Target\release"

          $Tmp = Join-Path $env:RUNNER_TEMP "prep"
          New-Item -ItemType Directory -Force -Path $Tmp | Out-Null

          $shouldSign = [System.String]::Equals($env:SIGN_ARTIFACTS, "true", "InvariantCultureIgnoreCase")

          if ($env:MODE -eq "reuse") {
            # DOWNLOAD FROM GCS
            if (-not (Get-Command gcloud -ErrorAction SilentlyContinue)) {
              throw "gcloud not found"
            }
            $dest = Join-Path $Tmp "picked"
            New-Item -ItemType Directory -Force -Path $dest | Out-Null

            gcloud --quiet storage cp "$($env:BUCKET_URI)/$($env:ARTIFACT_SUBPATH)/*" "$dest/"

            $exe = (Get-ChildItem $dest -Filter "mirrord.exe" -Recurse -File | Select-Object -First 1).FullName
            $dll = (Get-ChildItem $dest -Filter "mirrord_layer_win.dll" -Recurse -File | Select-Object -First 1).FullName

            if (-not $exe -or -not $dll) { throw "Failed to find EXE or DLL" }

            # SIGN IF NEEDED
            if ($shouldSign) {
              & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                  /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$dll"
              & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                  /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$exe"
            }

            Set-Env "MIRRORD_EXE" $exe
            Set-Env "MIRRORD_LAYER_FILE" $dll
            Set-Env "MIRRORD_VERSION" "unknown"

            exit 0
          }

          ####################################################################
          # BUILD + SIGN ARTIFACTS
          ####################################################################

          rustup target add $Target

          # BUILD DLL
          cargo build -p mirrord-layer-win --target $Target
          $dll = Join-Path $DbgDir "mirrord_layer_win.dll"
          if (-not (Test-Path $dll)) {
            $dll = Join-Path $RelDir "mirrord_layer_win.dll"
          }
          if (-not (Test-Path $dll)) { throw "DLL not found" }

          if ($shouldSign) {
            & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$dll"
          }

          # BUILD CLI
          $env:MIRRORD_LAYER_FILE = $dll
          cargo build -p mirrord --bin mirrord --target $Target
          $exe = Join-Path $DbgDir "mirrord.exe"
          if (-not (Test-Path $exe)) {
            $exe = Join-Path $RelDir "mirrord.exe"
          }
          if (-not (Test-Path $exe)) { throw "EXE not found" }

          if ($shouldSign) {
            & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$exe"
          }

          # EXPORT ENV
          Set-Env "MIRRORD_EXE" $exe
          Set-Env "MIRRORD_LAYER_FILE" $dll

          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg = $meta.packages | Where-Object { $_.name -eq "mirrord" } | Select-Object -First 1
          Set-Env "MIRRORD_VERSION" $pkg.version

      ###########################################################################
      # ENSURE WIX TOOLSET IS INSTALLED
      ###########################################################################

      - name: Ensure WiX Toolset
        run: |
          $ErrorActionPreference = "Stop"

          function Write-Env([string]$k,[string]$v) {
            "$k=$v" | Out-File -Append -FilePath $env:GITHUB_ENV
          }

          function Find-Candle {
            param(
              [switch]$DeepSearch
            )

            Write-Host "Searching for WiX candle.exe in known locations..."

            $candidateDirs = @()

            if ($Env:ChocolateyInstall -and (Test-Path $Env:ChocolateyInstall)) {
              $candidateDirs += @(
                (Join-Path $Env:ChocolateyInstall "lib\wixtoolset\tools\bin"),
                (Join-Path $Env:ChocolateyInstall "tools"),
                (Join-Path $Env:ChocolateyInstall "bin")
              )
            }

            $candidateDirs += @(
              "$Env:ProgramFiles(x86)\WiX Toolset v3.14\bin",
              "$Env:ProgramFiles(x86)\WiX Toolset v3.13\bin",
              "$Env:ProgramFiles(x86)\WiX Toolset v3.12\bin",
              "$Env:ProgramFiles(x86)\WiX Toolset v3.11\bin",
              "$Env:ProgramFiles\WiX Toolset v3.14\bin",
              "$Env:ProgramFiles\WiX Toolset v3.13\bin",
              "$Env:ProgramFiles\WiX Toolset v3.12\bin",
              "$Env:ProgramFiles\WiX Toolset v3.11\bin",
              "$Env:ProgramData\chocolatey\lib\wixtoolset\tools\bin",
              "$Env:ProgramData\chocolatey\bin"
            )

            $candidateDirs = $candidateDirs | Where-Object { $_ -and (Test-Path $_) }

            foreach ($dir in $candidateDirs) {
              $candlePath = Join-Path $dir "candle.exe"
              if (Test-Path $candlePath) {
                Write-Host "Found candle.exe at $candlePath."
                return $candlePath
              }
            }

            if ($DeepSearch) {
              Write-Host "No candle.exe in known dirs. Deep searching C:\ for candle.exe (may take time)..."
              try {
                $hit = Get-ChildItem -Path 'C:\' -Filter 'candle.exe' -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($hit) {
                  Write-Host "Deep search found candle.exe at $($hit.FullName)."
                  return $hit.FullName
                } else {
                  Write-Host "Deep search did not find candle.exe on C:\."
                }
              } catch {
                Write-Warning "Deep search failed: $($_.Exception.Message)"
              }
            }

            return $null
          }

          # 1. Try PATH directly
          $candleCmd = Get-Command candle.exe -ErrorAction SilentlyContinue
          $candlePath = $null
          if ($candleCmd) {
            $candlePath = $candleCmd.Source
            Write-Host "candle.exe found on PATH at $candlePath"
          } else {
            # 2. Try common locations
            $candlePath = Find-Candle
          }

          # 3. If still not found, try installing via Chocolatey (best effort)
          if (-not $candlePath) {
            Write-Host "candle.exe still not found. Trying to install WiX Toolset via Chocolatey (latest 3.x)..."

            if (-not (Get-Command choco.exe -ErrorAction SilentlyContinue)) {
              Write-Host "Chocolatey not found, installing Chocolatey..."
              Set-ExecutionPolicy Bypass -Scope Process -Force
              [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
              Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
            }

            try {
              choco install wixtoolset -y --no-progress
            } catch {
              Write-Warning "Chocolatey install failed: $($_.Exception.Message)"
            }

            # 4. After choco, re-check (including deep search)
            $candleCmd = Get-Command candle.exe -ErrorAction SilentlyContinue
            if ($candleCmd) {
              $candlePath = $candleCmd.Source
              Write-Host "After Chocolatey, candle.exe found on PATH at $candlePath"
            } else {
              $candlePath = Find-Candle -DeepSearch
            }
          }

          if (-not $candlePath -or -not (Test-Path $candlePath)) {
            throw "candle.exe still not found after all attempts. Please install WiX Toolset 3.x on this runner and ensure candle.exe exists (e.g., via Chocolatey or MSI)."
          }

          # Resolve light.exe in same directory (or via PATH as fallback)
          $wixDir = Split-Path $candlePath -Parent
          $lightPath = Join-Path $wixDir "light.exe"
          if (-not (Test-Path $lightPath)) {
            $lightCmd = Get-Command light.exe -ErrorAction SilentlyContinue
            if ($lightCmd) {
              $lightPath = $lightCmd.Source
            }
          }

          if (-not (Test-Path $lightPath)) {
            throw "Found candle.exe at '$candlePath' but could not find light.exe in the same directory or on PATH. Please ensure a full WiX Toolset 3.x install (candle.exe and light.exe)."
          }

          Write-Host "Resolved WiX tools:"
          Write-Host "  candle.exe = $candlePath"
          Write-Host "  light.exe  = $lightPath"

          # Export for subsequent steps
          Write-Env "CANDLE_EXE" $candlePath
          Write-Env "LIGHT_EXE"  $lightPath

      ###########################################################################
      # BUILD MSI USING main.wxs
      ###########################################################################

      - name: Build MSI
        run: |
          $ErrorActionPreference = "Stop"

          if (-not $env:CANDLE_EXE -or -not (Test-Path $env:CANDLE_EXE)) {
            throw "CANDLE_EXE env var is not set or does not point to a valid file. Ensure 'Ensure WiX Toolset' step ran successfully."
          }
          if (-not $env:LIGHT_EXE -or -not (Test-Path $env:LIGHT_EXE)) {
            throw "LIGHT_EXE env var is not set or does not point to a valid file. Ensure 'Ensure WiX Toolset' step ran successfully."
          }

          $candle = $env:CANDLE_EXE
          $light  = $env:LIGHT_EXE

          Write-Host "Using candle.exe at: $candle"
          Write-Host "Using light.exe  at: $light"

          $Root = "C:\wix\mirrord"
          New-Item -ItemType Directory -Force -Path $Root | Out-Null

          # COPY ARTIFACTS + ASSETS
          Copy-Item $env:MIRRORD_EXE "$Root\mirrord.exe" -Force
          Copy-Item $env:MIRRORD_LAYER_FILE "$Root\mirrord_layer_win.dll" -Force
          Copy-Item "$env:GITHUB_WORKSPACE\mirrord\cli\wix\mirrord.ico" "$Root\mirrord.ico" -Force
          Copy-Item "$env:GITHUB_WORKSPACE\mirrord\cli\wix\License.rtf" "$Root\License.rtf" -Force
          Copy-Item "$env:GITHUB_WORKSPACE\mirrord\cli\wix\main.wxs" "$Root\main.wxs" -Force

          $Obj = "$Root\main.wixobj"
          $Msi = "$Root\mirrord.msi"

          if (Test-Path $Msi) { Remove-Item $Msi -Force }

          & $candle -nologo -v "$Root\main.wxs" -out $Obj
          & $light  -nologo -v $Obj -out $Msi -ext WixUIExtension -sval

          if (-not (Test-Path $Msi)) { throw "MSI not produced" }

          "MSI_PATH=$Msi" | Out-File -Append -FilePath $env:GITHUB_ENV

      ###########################################################################
      # UPLOAD TO GCS
      ###########################################################################

      - name: Upload MSI to GCS
        run: |
          $ErrorActionPreference = "Stop"
          $msi = $env:MSI_PATH
          if (-not (Test-Path $msi)) {
            throw "MSI_PATH '$msi' does not exist."
          }

          # Build a unique folder per run:
          # gs://mirrord-windows-msi/<ref-name>/run-<run-id>/mirrord.msi
          $runId = $env:GITHUB_RUN_ID
          $refName = $env:GITHUB_REF_NAME
          if (-not $refName) {
            $refName = "unknown"
          }

          # Sanitize ref name for use in path
          $refSafe = $refName -replace '[^A-Za-z0-9\.\-]', '_'

          $bucketBase = $env:MSI_BUCKET_URI.TrimEnd('/')
          $destFolder = "$bucketBase/$refSafe/run-$runId"
          $destUri = "$destFolder/mirrord.msi"

          Write-Host "Uploading MSI to $destUri"
          gcloud --quiet storage cp $msi $destUri

          # Export for later (summary, logs)
          "MSI_GCS_URI=$destUri" | Out-File -Append -FilePath $env:GITHUB_ENV

      ###########################################################################
      # UNIT TESTS
      ###########################################################################

      - name: Run Rust unit tests
        run: |
          $ErrorActionPreference = "Stop"
          cargo test --all-features

      ###########################################################################
      # RELEASE PUBLISH
      ###########################################################################

      - name: Compute release tag
        id: tag
        if: ${{ github.event_name != 'pull_request' && (startsWith(github.ref, 'refs/tags/') || env.PUBLISH_MODE != 'no') }}
        run: |
          $ErrorActionPreference = "Stop"
          if ("$env:GITHUB_REF".StartsWith("refs/tags/")) {
            $tag = "$env:GITHUB_REF".Substring(10)
          } elseif ($env:RELEASE_TAG_INPUT) {
            $tag = $env:RELEASE_TAG_INPUT
          } else {
            $tag = "v$env:MIRRORD_VERSION"
          }
          "RELEASE_TAG=$tag" | Out-File -Append -FilePath $env:GITHUB_ENV

      - name: Upload artifacts to GitHub Release (custom)
        if: ${{ github.event_name != 'pull_request' && (startsWith(github.ref, 'refs/tags/') || env.PUBLISH_MODE != 'no') }}
        uses: actions/github-script@v7
        env:
          MSI_PATH: ${{ env.MSI_PATH }}
          MIRRORD_EXE: ${{ env.MIRRORD_EXE }}
          MIRRORD_LAYER_FILE: ${{ env.MIRRORD_LAYER_FILE }}
          RELEASE_TAG: ${{ env.RELEASE_TAG }}
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const { owner, repo } = context.repo;

            const tag = process.env.RELEASE_TAG;

            // Ensure release exists
            let rel;
            try {
              const r = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              rel = r.data;
            } catch (e) {
              const r = await github.rest.repos.createRelease({
                owner, repo,
                tag_name: tag,
                name: `Windows build ${tag}`,
                draft: false,
                prerelease: false
              });
              rel = r.data;
            }

            async function upload(filePath) {
              if (!fs.existsSync(filePath)) return;

              const name = path.basename(filePath);
              const data = fs.readFileSync(filePath);

              await github.rest.repos.uploadReleaseAsset({
                owner, repo,
                release_id: rel.id,
                name,
                data,
                headers: {
                  "content-type": "application/octet-stream",
                  "content-length": data.length
                }
              });
            }

            await upload(process.env.MIRRORD_EXE);
            await upload(process.env.MIRRORD_LAYER_FILE);
            await upload(process.env.MSI_PATH);

      ###########################################################################
      # SUMMARY
      ###########################################################################

      - name: Summary
        if: always()
        run: |
          Write-Host "MSI (local): $env:MSI_PATH"
          Write-Host "MSI (GCS):   $env:MSI_GCS_URI"
          Write-Host "EXE:         $env:MIRRORD_EXE"
          Write-Host "DLL:         $env:MIRRORD_LAYER_FILE"
