name: Windows tests (reuse prebuilt, parallel)

on:
  workflow_dispatch:
  push:
  pull_request:
    branches: [main, "*staging*"]
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read

env:
  BUCKET_URI: gs://mirrord-windows-builds
  ARTIFACT_SUBPATH: windows/mirrord-3.163.0-run70-0932953
  RUST_BACKTRACE: "1"
  CARGO_NET_GIT_FETCH_WITH_CLI: "true"
  MIRRORD_TELEMETRY: "false"
  LIBCLANG_PATH: "C:\\Program Files\\LLVM\\bin"

jobs:
  windows_tests_reuse_artifact:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout repo (tests need sources)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Toolchain info
        run: |
          whoami
          rustc -V
          cargo -V
          rustup show

      - name: Install nightly (keep aligned with Linux CI)
        run: rustup toolchain install nightly-2025-08-01 --profile minimal

      - name: Install cargo-nextest (parallel test runner)
        uses: taiki-e/install-action@v2
        with:
          tool: nextest

      - name: Pick Windows artifacts from GCS (robust)
        run: |
          $ErrorActionPreference = 'Stop'

          $dest = Join-Path $env:RUNNER_TEMP 'picked'
          New-Item -ItemType Directory -Path $dest -Force | Out-Null

          Write-Host "Downloading from: $env:BUCKET_URI/$env:ARTIFACT_SUBPATH/*"
          gcloud --quiet storage cp "$($env:BUCKET_URI)/$($env:ARTIFACT_SUBPATH)/*" "$dest/"
          if ($LASTEXITCODE -ne 0) { throw "gcloud cp failed (check path or perms)" }

          Write-Host "Downloaded files:"; Get-ChildItem $dest | Format-Table Name,Length

          $wild = Join-Path $dest '*'
          $exe = (Get-ChildItem -Path $wild -Filter 'mirrord.exe' -File | Select-Object -First 1).FullName
          $dll = (Get-ChildItem -Path $wild -Filter 'mirrord_layer_win.dll' -File | Select-Object -First 1).FullName
          if (-not $dll) { $dll = (Get-ChildItem -Path $wild -Filter 'mirrord-layer-win.dll' -File | Select-Object -First 1).FullName }
          if (-not $dll) { $dll = (Get-ChildItem -Path $wild -Filter '*layer*.dll' -File | Select-Object -First 1).FullName }

          Write-Host "Found exe: $exe"
          Write-Host "Found dll: $dll"

          if (-not $exe -or -not $dll) {
            Write-Host "Files present:"; Get-ChildItem -Path $wild -File | Select Name,FullName | Format-Table
            throw "Did not find mirrord.exe or layer DLL under $dest"
          }

          "MIRRORD_DOWNLOADED_EXE=$exe"        | Out-File -FilePath $env:GITHUB_ENV -Append
          "MIRRORD_LAYER_FILE=$dll"            | Out-File -FilePath $env:GITHUB_ENV -Append
          "MIRRORD_TEST_USE_EXISTING_LIB=$dll" | Out-File -FilePath $env:GITHUB_ENV -Append

      # ---------- Smoke (hash/signing/DLL load/CLI) ----------

      - name: Publish Windows smoke results
        if: always()
        run: |
          $ErrorActionPreference = 'Stop'

          $exe = $env:MIRRORD_DOWNLOADED_EXE
          $dll = $env:MIRRORD_LAYER_FILE
          if (-not (Test-Path $exe)) { throw "Missing exe at $exe" }
          if (-not (Test-Path $dll)) { throw "Missing dll at $dll" }
          $base = Split-Path $exe -Parent

          function Get-ExpectedSha256([string]$shaFile) {
            if (-not (Test-Path $shaFile)) { return $null }
            $raw = Get-Content $shaFile -Raw
            $raw.Split(" ",[System.StringSplitOptions]::RemoveEmptyEntries)[0].Trim().ToLower()
          }

          $exeShaFile = Join-Path $base 'mirrord.exe.sha256'
          $dllShaFile = Join-Path $base ((Split-Path $dll -Leaf) + '.sha256')
          if (-not (Test-Path $dllShaFile)) { $dllShaFile = Join-Path $base 'mirrord_layer_win.dll.sha256' }

          $exeHash   = (Get-FileHash -Algorithm SHA256 $exe).Hash.ToLower()
          $dllHash   = (Get-FileHash -Algorithm SHA256 $dll).Hash.ToLower()
          $exeExpect = Get-ExpectedSha256 $exeShaFile
          $dllExpect = Get-ExpectedSha256 $dllShaFile
          $shaExeOk  = ($exeExpect -and $exeHash -eq $exeExpect)
          $shaDllOk  = ($dllExpect -and $dllHash -eq $dllExpect)

          $sigExe = $null; $sigDll = $null
          if (Get-Command signtool.exe -ErrorAction SilentlyContinue) {
            & signtool.exe verify /pa $exe | Out-Null; $sigExe = ($LASTEXITCODE -eq 0)
            & signtool.exe verify /pa $dll | Out-Null; $sigDll = ($LASTEXITCODE -eq 0)
          }

          $dllLoadOk = $false
          $dllCrash = $false
          $loader = @"
          try {
            Add-Type -TypeDefinition @'
          using System;
          using System.Runtime.InteropServices;
          public static class L {
            [DllImport("kernel32.dll", SetLastError=true, CharSet=CharSet.Unicode)]
            public static extern IntPtr LoadLibrary(string lpFileName);
            [DllImport("kernel32.dll", SetLastError=true)]
            public static extern bool FreeLibrary(IntPtr hModule);
          }
          '@;
            var ptr = L.LoadLibrary(@"{($dll -replace '"','""')}");
            if (ptr == IntPtr.Zero) Environment.Exit(2);
            L.FreeLibrary(ptr);
            Environment.Exit(0);
          } catch { Environment.Exit(3); }
          "@

          $loaderPath = Join-Path $env:RUNNER_TEMP 'dll_load_test.ps1'
          Set-Content -Path $loaderPath -Value $loader -Encoding UTF8

          $p = Start-Process pwsh -ArgumentList '-NoProfile','-NonInteractive','-File', $loaderPath -Wait -PassThru
          $childExit = $p.ExitCode
          if ($childExit -eq 0) { $dllLoadOk = $true }
          if ($childExit -eq 3221225477 -or $childExit -eq -1073741819) { $dllCrash = $true }

          $verRc = $null; $verText = ""
          try { $verText = & $exe --version 2>&1; $verRc = $LASTEXITCODE } catch { $verRc = -1; $verText = $_.ToString() }
          $helpRc = $null; $helpText = ""
          try { $helpText = & $exe --help 2>&1;    $helpRc = $LASTEXITCODE } catch { $helpRc = -1; $helpText = $_.ToString() }

          $exeSize = (Get-Item $exe).Length
          $dllSize = (Get-Item $dll).Length

          $rows = @()
          $rows += [pscustomobject]@{ Check='SHA256 (exe)';  Result=($(if($shaExeOk){'✅ OK'}else{'❌ Mismatch/None'})); Notes= "hash=$exeHash expected=$exeExpect" }
          $rows += [pscustomobject]@{ Check='SHA256 (dll)';  Result=($(if($shaDllOk){'✅ OK'}else{'❌ Mismatch/None'})); Notes= "hash=$dllHash expected=$dllExpect" }
          $rows += [pscustomobject]@{ Check='Signing (exe)'; Result=($(if($sigExe -eq $true){'✅ Verified'}elseif($sigExe -eq $false){'❌ Failed'}else{'⚠️ Skipped'})); Notes= 'signtool verify /pa' }
          $rows += [pscustomobject]@{ Check='Signing (dll)'; Result=($(if($sigDll -eq $true){'✅ Verified'}elseif($sigDll -eq $false){'❌ Failed'}else{'⚠️ Skipped'})); Notes= 'signtool verify /pa' }
          $rows += [pscustomobject]@{ Check='DLL load/unload'; Result=($(if($dllLoadOk){'✅ OK'}elseif($dllCrash){'❌ Crash'}else{'❌ Failed'})); Notes= "child-exit=$childExit" }
          $rows += [pscustomobject]@{ Check='CLI --version';  Result="exit $verRc"; Notes= ($verText -split "`n")[0] }
          $rows += [pscustomobject]@{ Check='CLI --help';     Result="exit $helpRc"; Notes= ($helpText -split "`n")[0] }
          $rows += [pscustomobject]@{ Check='File sizes';     Result=''; Notes= "exe=$exeSize bytes; dll=$dllSize bytes" }

          $md = @()
          $md += '### Windows smoke results'
          $md += ''
          $md += ('**Artifact dir:** `{0}`  ' -f $env:ARTIFACT_SUBPATH)
          $md += ('**EXE:** `{0}`  ' -f $exe)
          $md += ('**DLL:** `{0}`' -f $dll)
          $md += ''
          $md += '| Check | Result | Notes |'
          $md += '|------:|:------:|-------|'
          foreach ($r in $rows) {
            $c = ($r.Check  -replace '\|','\|')
            $res = ($r.Result -replace '\|','\|')
            $n = ($r.Notes  -replace '\r',' ' -replace '\n',' ' -replace '\|','\|')
            $md += "| $c | $res | $n |"
          }
          $md += ''
          $md += '<sub>DLL load runs in a child process to avoid crashing the job. See step logs for full outputs.</sub>'

          $md -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append

      # ---------- Parallel Rust tests with nextest ----------

      - name: Build tests (no-run) for all crates
        run: |
          $ErrorActionPreference = 'Stop'
          $toolchain = '+nightly-2025-08-01'
          $target    = 'x86_64-pc-windows-msvc'

          $todo = @(
            'cargo {0} test --target {1} -p mirrord-layer-win --no-run'      -f $toolchain,$target
            'cargo {0} test --target {1} -p mirrord-protocol --no-run'       -f $toolchain,$target
            'cargo {0} test --target {1} -p mirrord-config --no-run'         -f $toolchain,$target
            'cargo {0} test --target {1} -p mirrord-kube --all-features --no-run' -f $toolchain,$target
            'cargo {0} test --target {1} -p mirrord-intproxy --no-run'       -f $toolchain,$target
            'cargo {0} test --target {1} -p mirrord-auth --no-run'           -f $toolchain,$target
            'cargo {0} test --target {1} -p mirrord-operator --features "crd, client" --no-run' -f $toolchain,$target
            'cargo {0} test --target {1} -p mirrord --no-run'                -f $toolchain,$target
          )

          foreach ($cmd in $todo) {
            Write-Host ">>> $cmd"
            cmd /c $cmd
            if ($LASTEXITCODE -ne 0) { throw "Build failed: $cmd" }
          }

      - name: Run crates in parallel (nextest) + publish table
        run: |
          $ErrorActionPreference = 'Stop'
          $toolchain = '+nightly-2025-08-01'
          $target    = 'x86_64-pc-windows-msvc'
          $logDir    = Join-Path $env:RUNNER_TEMP 'nextest-logs'
          New-Item -ItemType Directory -Force -Path $logDir | Out-Null

          $crates = @(
            @{ name='mirrord-layer-win' ; args='-p mirrord-layer-win' }
            @{ name='mirrord-protocol'  ; args='-p mirrord-protocol' }
            @{ name='mirrord-config'    ; args='-p mirrord-config' }
            @{ name='mirrord-kube'      ; args='-p mirrord-kube --all-features' }
            @{ name='mirrord-intproxy'  ; args='-p mirrord-intproxy' }
            @{ name='mirrord-auth'      ; args='-p mirrord-auth' }
            @{ name='mirrord-operator'  ; args='-p mirrord-operator --features "crd, client"' }
            @{ name='mirrord (CLI)'     ; args='-p mirrord' }
          )

          $procs = @()

          foreach ($c in $crates) {
            $safe = ($c.name -replace '[^A-Za-z0-9_.-]','_')
            $junit = Join-Path $logDir "$safe.junit.xml"
            $log   = Join-Path $logDir "$safe.nextest.log"
            $cmd   = "cargo $toolchain nextest run --target $target $($c.args) --no-fail-fast --status-level pass --retries 0 --report-time --no-build --junit-xml `"$junit`""
            Write-Host ">>> $cmd"

            $args = @(
              '-NoProfile','-NonInteractive','-Command',
              "$cmd 2>&1 | Tee-Object -FilePath `"$log`" ; exit `$LASTEXITCODE`"
            )
            $p = Start-Process pwsh -ArgumentList $args -PassThru
            $procs += [pscustomobject]@{ Name=$c.name; Safe=$safe; Junit=$junit; Log=$log; Proc=$p }
          }

          # Wait for all processes to finish
          Wait-Process -Id ($procs | ForEach-Object { $_.Proc.Id })

          # Helper: parse JUnit into a summary object
          function Parse-JUnit([string]$path) {
            if (-not (Test-Path $path)) { return @{tests=0;fail=1;skip=0;time=0.0;failed=@('NO-REPORT')} }
            [xml]$xml = Get-Content $path
            $tests=0; $fail=0; $skip=0; $time=0.0; $failed = New-Object System.Collections.Generic.List[string]

            if ($xml.testsuites) {
              foreach ($ts in $xml.testsuites.testsuite) {
                $tests += [int]$ts.tests
                $fail  += ([int]$ts.failures + [int]$ts.errors)
                $skip  += [int]($ts.skipped ?? 0)
                $time  += [double]$ts.time
                foreach ($tc in $ts.testcase) {
                  if ($tc.failure -or $tc.error) { $failed.Add([string]$tc.name) }
                }
              }
            } elseif ($xml.testsuite) {
              $ts = $xml.testsuite
              $tests = [int]$ts.tests
              $fail  = ([int]$ts.failures + [int]$ts.errors)
              $skip  = [int]($ts.skipped ?? 0)
              $time  = [double]$ts.time
              foreach ($tc in $ts.testcase) {
                if ($tc.failure -or $tc.error) { $failed.Add([string]$tc.name) }
              }
            }
            return @{tests=$tests; fail=$fail; skip=$skip; time=$time; failed=$failed}
          }

          $rows = @()
          $totPassed=0; $totFailed=0; $totSkipped=0; $totTime=0.0
          $anyFail = $false

          foreach ($x in $procs) {
            $exit = $x.Proc.ExitCode
            $r = Parse-JUnit $x.Junit
            $passed = [int]($r.tests - $r.fail - $r.skip)
            $totPassed += $passed
            $totFailed += [int]$r.fail
            $totSkipped += [int]$r.skip
            $totTime += [double]$r.time
            $status = if ($r.fail -gt 0 -or $exit -ne 0) { $anyFail = $true; '❌' } else { '✅' }
            $rows += [pscustomobject]@{
              Crate   = $x.Name
              Passed  = $passed
              Failed  = [int]$r.fail
              Skipped = [int]$r.skip
              Time    = ('{0:F2}s' -f $r.time)
              Status  = $status
              FailedList = ($r.failed -join ', ')
              ExitCode = $exit
              LogPath  = $x.Log
            }
          }

          # Markdown table
          $md = @()
          $md += '## Windows Rust tests (parallel via nextest)'
          $md += ''
          $md += '| Crate | Passed | Failed | Skipped | Time | Status |'
          $md += '|:------|------:|------:|-------:|-----:|:------:|'
          foreach ($r in $rows) {
            $md += ('| {0} | {1} | {2} | {3} | {4} | {5} |' -f $r.Crate, $r.Passed, $r.Failed, $r.Skipped, $r.Time, $r.Status)
          }
          $md += ('| **Total** | **{0}** | **{1}** | **{2}** | **{3:F2}s** |  |' -f $totPassed, $totFailed, $totSkipped, $totTime)
          $md += ''

          foreach ($r in $rows | Where-Object { $_.Failed -gt 0 -and $_.FailedList }) {
            $md += "<details><summary>Failed tests: <strong>$($r.Crate)</strong></summary>"
            $md += ''
            $md += '```'
            ($r.FailedList -split ', ') | ForEach-Object { if ($_ -ne '') { $md += $_ } }
            $md += '```'
            $md += ''
            $md += '</details>'
            $md += ''
          }

          $md += '<sub>Each crate ran with <code>cargo nextest</code> using multiple processes/threads. Per-crate logs are attached as an artifact.</sub>'
          $md -join "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8 -Append

          # Save a machine-readable summary
          $rows | ConvertTo-Json -Depth 4 | Out-File -FilePath (Join-Path $logDir 'summary.json') -Encoding UTF8

          if ($anyFail) { exit 1 }

      - name: Upload test logs (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: windows-nextest-logs
          path: ${{ runner.temp }}/nextest-logs





### THIS PART WORKS ###
# name: Windows mirrord build and cert signing

# on:
#   workflow_dispatch:

# permissions:
#   contents: read

# jobs:
#   build:
#     runs-on: [self-hosted, Windows]
#     defaults:
#       run:
#         shell: pwsh
#     env:
#       BUCKET_URI: gs://mirrord-windows-builds

#     steps:
#       - name: Checkout windows branch
#         uses: actions/checkout@v4
#         with:
#           ref: windows-builds-gh
#           fetch-depth: 0
#           submodules: recursive

#       - name: Identity & DigiCert healthcheck
#         run: |
#           $ErrorActionPreference = 'Stop'
#           whoami
#           Write-Host "SM_HOST=$env:SM_HOST"
#           Write-Host "SM_CLIENT_CERT_FILE=$env:SM_CLIENT_CERT_FILE"
#           smctl --version
#           smctl healthcheck

#       - name: Ensure Rust MSVC target
#         run: rustup target add x86_64-pc-windows-msvc

#       # --- Build the layer FIRST so include_bytes! can find it ---
#       - name: Build mirrord-layer-win (DLL)
#         run: cargo build -p mirrord-layer-win --target x86_64-pc-windows-msvc

#       - name: Locate package for bin "mirrord" + set envs (package, version, layer path)
#         run: |
#           $ErrorActionPreference = 'Stop'

#           # Which package contains bin "mirrord"?
#           $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
#           $pkg = $meta.packages | Where-Object {
#             $_.targets | Where-Object { ($_."kind" -contains 'bin') -and ($_.name -eq 'mirrord') }
#           } | Select-Object -First 1
#           if (-not $pkg) {
#             $names = ($meta.packages | ForEach-Object name) -join ', '
#             throw "No bin target named 'mirrord' found. Workspace packages: $names"
#           }

#           "MIRRORD_PKG=$($pkg.name)"           | Out-File -FilePath $env:GITHUB_ENV -Append
#           "MIRRORD_VERSION=$($pkg.version)"    | Out-File -FilePath $env:GITHUB_ENV -Append

#           # IMPORTANT: underscores in the produced DLL name
#           $dllDbg = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug\mirrord_layer_win.dll'
#           $dllRel = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\release\mirrord_layer_win.dll'
#           if     (Test-Path $dllDbg) { $dll = $dllDbg }
#           elseif (Test-Path $dllRel) { $dll = $dllRel }
#           else   { throw "Layer DLL not found. Expected at:`n  $dllDbg`n  $dllRel" }

#           "MIRRORD_LAYER_FILE=$dll"            | Out-File -FilePath $env:GITHUB_ENV -Append
#           Write-Host "Will embed layer DLL from: $dll"
#           Write-Host "Will build bin 'mirrord' from package: $($pkg.name) v$($pkg.version)"

#           # Print size for sanity
#           Get-Item $dll | Format-List FullName,Length,LastWriteTime

#       # --- Build the CLI AFTER the layer exists & env var is set ---
#       - name: Build mirrord (bin)
#         run: cargo build -p "$env:MIRRORD_PKG" --bin mirrord --target x86_64-pc-windows-msvc

#       - name: Code sign mirrord.exe + layer DLL (thumbprint) + verify
#         run: |
#           $ErrorActionPreference = 'Stop'

#           $dbgDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug'
#           $relDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\release'

#           # Resolve exe (prefer Debug, fallback Release)
#           $exe = Join-Path $dbgDir 'mirrord.exe'
#           if (!(Test-Path $exe)) {
#             $exeRel = Join-Path $relDir 'mirrord.exe'
#             if (Test-Path $exeRel) { $exe = $exeRel } else { throw "Expected mirrord.exe not found at $exe or $exeRel" }
#           }

#           # Resolve dll (prefer env, else common locations)
#           $dllCandidates = @()
#           if ($env:MIRRORD_LAYER_FILE) { $dllCandidates += $env:MIRRORD_LAYER_FILE }
#           $dllCandidates += @(
#             (Join-Path $dbgDir 'mirrord_layer_win.dll'),
#             (Join-Path $relDir 'mirrord_layer_win.dll')
#           )
#           $dll = $dllCandidates | Where-Object { $_ -and (Test-Path $_) } | Select-Object -First 1
#           if (-not $dll) {
#             $list = ($dllCandidates | ForEach-Object { $_ }) -join [Environment]::NewLine
#             throw ("Layer DLL not found. Looked for:{0}{1}" -f [Environment]::NewLine, $list)
#           }

#           foreach ($f in @($exe, $dll)) {
#             Write-Host "Signing $f"
#             & signtool.exe sign `
#               /sha1 bfa0bea8d22265cb382d2d5dec55a6ffcff70bcb `
#               /tr http://timestamp.digicert.com `
#               /td SHA256 `
#               /fd SHA256 `
#               "$f"
#             if ($LASTEXITCODE -ne 0) { throw "signtool sign failed for $f (exit $LASTEXITCODE)" }

#             Write-Host "Verifying $f"
#             & signtool.exe verify /pa "$f"
#             if ($LASTEXITCODE -ne 0) { throw "signtool verify failed for $f (exit $LASTEXITCODE)" }
#           }

#       - name: Stage and upload signed artifacts to GCS
#         run: |
#           $ErrorActionPreference = 'Stop'
#           if (-not $env:BUCKET_URI) { throw "BUCKET_URI env is empty. Set gs://<bucket> at job.env." }

#           $dbgDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\debug'
#           $relDir = Join-Path $env:GITHUB_WORKSPACE 'target\x86_64-pc-windows-msvc\release'

#           # Resolve exe and dll like above
#           $exe = (Get-Item -EA SilentlyContinue (Join-Path $dbgDir 'mirrord.exe'))
#           if (-not $exe) { $exe = Get-Item -EA Stop (Join-Path $relDir 'mirrord.exe') }

#           $dll = $env:MIRRORD_LAYER_FILE
#           if (-not $dll -or !(Test-Path $dll)) {
#             $dll = (Get-ChildItem -Path $dbgDir -Filter 'mirrord_layer_win.dll' -EA SilentlyContinue | Select-Object -First 1).FullName
#             if (-not $dll) {
#               $dll = (Get-ChildItem -Path $relDir -Filter 'mirrord_layer_win.dll' -EA SilentlyContinue | Select-Object -First 1).FullName
#             }
#             if (-not $dll) { throw "Layer DLL not found in debug or release directories." }
#           }

#           $staging = Join-Path $env:RUNNER_TEMP 'artifacts'
#           New-Item -ItemType Directory -Path $staging -Force | Out-Null
#           Copy-Item $exe.FullName -Destination $staging -Force
#           Copy-Item $dll        -Destination (Join-Path $staging (Split-Path $dll -Leaf)) -Force

#           # Show what we staged (helps debugging)
#           Write-Host "Staged files:"; Get-ChildItem $staging | Format-Table Name,Length

#           # Make checksums
#           Get-ChildItem -Path (Join-Path $staging '*') -Include *.exe,*.dll | ForEach-Object {
#             $h = Get-FileHash -Algorithm SHA256 $_.FullName
#             "$($h.Hash)  $($_.Name)" | Out-File (Join-Path $staging "$($_.Name).sha256") -Encoding ascii
#           }

#           # Collect files (NOTE the wildcard so -Include works)
#           $files = Get-ChildItem -Path (Join-Path $staging '*') -Include *.exe,*.dll,*.sha256 -File
#           if (-not $files) { throw "No artifacts found in $staging" }

#           $version = if ($env:MIRRORD_VERSION) { $env:MIRRORD_VERSION } else { 'unknown' }
#           $sha7 = $env:GITHUB_SHA.Substring(0,7)
#           $artifactDir = "windows/mirrord-$version-run$($env:GITHUB_RUN_NUMBER)-$sha7"
#           $dest = "$($env:BUCKET_URI)/$artifactDir/"
#           Write-Host "Uploading to $dest"

#           foreach ($f in $files) {
#             gcloud --quiet storage cp $($f.FullName) $dest
#             if ($LASTEXITCODE -ne 0) { throw "gcloud cp failed for $($f.Name) (exit $LASTEXITCODE)" }
#           }

#           gcloud --quiet storage ls $dest
