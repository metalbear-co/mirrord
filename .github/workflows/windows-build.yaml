name: Windows Build

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Pick artifacts from GCS (reuse) or build & sign now"
        type: choice
        options: [build_sign, reuse]
        default: build_sign
      release:
        description: "Publish a GitHub Release? (controls upload to existing release)"
        type: choice
        options: [no, draft, prerelease, release]
        default: no
      release_tag:
        description: "Release tag (defaults to pushed tag or <MIRRORD_VERSION>)"
        required: false
        type: string
      sign_artifacts:
        description: "Code-sign EXE & DLL & MSI"
        type: choice
        options: ["false", "true"]
        default: false
      choco_publish:
        description: "Publish a Chocolatey package?"
        type: choice
        options: ["false", "true"]
        default: "false"
      winget:
        description: "Update WinGet manifest (wingetcreate)?"
        type: choice
        options: ["false", "true"]
        default: "false"

  # Uncomment if you ever want this to run on push:
  # push:
  #   paths-ignore:
  #     - "*.md"
  #     - "**/*.md"

  pull_request:
    branches: ["main", "*staging*", "windows-support"]
    types: [opened, synchronize, reopened, ready_for_review]
    paths-ignore:
      - "*.md"
      - "**/*.md"

permissions:
  contents: write

env:
  BUCKET_URI: gs://mirrord-windows-builds
  # Public bucket for MSI for WinGet:
  MSI_BUCKET_URI: gs://mirrord-windows-builds-public
  ARTIFACT_SUBPATH: windows/mirrord-latest
  RUST_BACKTRACE: "1"
  CARGO_NET_GIT_FETCH_WITH_CLI: "true"
  MIRRORD_TELEMETRY: "false"
  LIBCLANG_PATH: "C:\\Program Files\\LLVM\\bin"
  # HTTP base for public MSI download (WinGet)
  MSI_HTTP_BASE: "https://storage.googleapis.com/mirrord-windows-builds-public"
  WINGET_PACKAGE_ID: "MetalBear.mirrord"

jobs:
  windows_tests:
    runs-on: [self-hosted, Windows]
    defaults:
      run:
        shell: pwsh
    env:
      MODE: ${{ github.event.inputs.mode || 'build_sign' }}
      PUBLISH_MODE: ${{ github.event.inputs.release || 'no' }}
      RELEASE_TAG_INPUT: ${{ github.event.inputs.release_tag || '' }}
      SIGN_ARTIFACTS: ${{ github.event.inputs.sign_artifacts || 'false' }}
      PUBLISH_CHOCO: ${{ github.event.inputs.choco_publish || 'false' }}
      PUBLISH_WINGET: ${{ github.event.inputs.winget || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Toolchain info
        run: |
          $ErrorActionPreference = "Stop"
          whoami
          rustc -V
          cargo -V
          rustup show

      ###########################################################################
      # PREPARE ARTIFACTS (either reuse from GCS OR build+sign)
      ###########################################################################

      - name: Prepare artifacts
        id: prep
        run: |
          $ErrorActionPreference = "Stop"
          function Set-Env([string]$k,[string]$v){ "$k=$v" | Out-File -Append -FilePath $env:GITHUB_ENV }

          $Target = "x86_64-pc-windows-msvc"
          $DbgDir = Join-Path $env:GITHUB_WORKSPACE "target\$Target\debug"
          $RelDir = Join-Path $env:GITHUB_WORKSPACE "target\$Target\release"

          $Tmp = Join-Path $env:RUNNER_TEMP "prep"
          New-Item -ItemType Directory -Force -Path $Tmp | Out-Null

          $shouldSign = [System.String]::Equals($env:SIGN_ARTIFACTS, "true", "InvariantCultureIgnoreCase")

          if ($env:MODE -eq "reuse") {
            # DOWNLOAD FROM GCS
            if (-not (Get-Command gcloud -ErrorAction SilentlyContinue)) {
              throw "gcloud not found"
            }
            $dest = Join-Path $Tmp "picked"
            New-Item -ItemType Directory -Force -Path $dest | Out-Null

            gcloud --quiet storage cp "$($env:BUCKET_URI)/$($env:ARTIFACT_SUBPATH)/*" "$dest/"

            $exe = (Get-ChildItem $dest -Filter "mirrord.exe" -Recurse -File | Select-Object -First 1).FullName
            $dll = (Get-ChildItem $dest -Filter "mirrord_layer_win.dll" -Recurse -File | Select-Object -First 1).FullName

            if (-not $exe -or -not $dll) { throw "Failed to find EXE or DLL" }

            # SIGN IF NEEDED
            if ($shouldSign) {
              & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                  /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$dll"
              & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                  /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$exe"
            }

            Set-Env "MIRRORD_EXE" $exe
            Set-Env "MIRRORD_LAYER_FILE" $dll
            Set-Env "MIRRORD_VERSION" "unknown"

            exit 0
          }

          ####################################################################
          # BUILD + SIGN ARTIFACTS
          ####################################################################

          rustup target add $Target

          # BUILD DLL
          cargo build -p mirrord-layer-win --target $Target
          $dll = Join-Path $DbgDir "mirrord_layer_win.dll"
          if (-not (Test-Path $dll)) {
            $dll = Join-Path $RelDir "mirrord_layer_win.dll"
          }
          if (-not (Test-Path $dll)) { throw "DLL not found" }

          if ($shouldSign) {
            & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$dll"
          }

          # BUILD CLI
          $env:MIRRORD_LAYER_FILE = $dll
          cargo build -p mirrord --bin mirrord --target $Target
          $exe = Join-Path $DbgDir "mirrord.exe"
          if (-not (Test-Path $exe)) {
            $exe = Join-Path $RelDir "mirrord.exe"
          }
          if (-not (Test-Path $exe)) { throw "EXE not found" }

          if ($shouldSign) {
            & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
                /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$exe"
          }

          # EXPORT ENV
          Set-Env "MIRRORD_EXE" $exe
          Set-Env "MIRRORD_LAYER_FILE" $dll

          $meta = cargo metadata --format-version 1 --no-deps | ConvertFrom-Json
          $pkg = $meta.packages | Where-Object { $_.name -eq "mirrord" } | Select-Object -First 1
          Set-Env "MIRRORD_VERSION" $pkg.version

      ###########################################################################
      # ENSURE WIX TOOLSET IS INSTALLED
      ###########################################################################

      - name: Ensure WiX Toolset
        run: |
          $ErrorActionPreference = "Stop"

          function Write-Env([string]$k,[string]$v) {
            "$k=$v" | Out-File -Append -FilePath $env:GITHUB_ENV
          }

          function Find-Candle {
            param(
              [switch]$DeepSearch
            )

            Write-Host "Searching for WiX candle.exe in known locations..."

            $candidateDirs = @()

            if ($Env:ChocolateyInstall -and (Test-Path $Env:ChocolateyInstall)) {
              $candidateDirs += @(
                (Join-Path $Env:ChocolateyInstall "lib\wixtoolset\tools\bin"),
                (Join-Path $Env:ChocolateyInstall "tools"),
                (Join-Path $Env:ChocolateyInstall "bin")
              )
            }

            $candidateDirs += @(
              "$Env:ProgramFiles(x86)\WiX Toolset v3.14\bin",
              "$Env:ProgramFiles(x86)\WiX Toolset v3.13\bin",
              "$Env:ProgramFiles(x86)\WiX Toolset v3.12\bin",
              "$Env:ProgramFiles(x86)\WiX Toolset v3.11\bin",
              "$Env:ProgramFiles\WiX Toolset v3.14\bin",
              "$Env:ProgramFiles\WiX Toolset v3.13\bin",
              "$Env:ProgramFiles\WiX Toolset v3.12\bin",
              "$Env:ProgramFiles\WiX Toolset v3.11\bin",
              "$Env:ProgramData\chocolatey\lib\wixtoolset\tools\bin",
              "$Env:ProgramData\chocolatey\bin"
            )

            $candidateDirs = $candidateDirs | Where-Object { $_ -and (Test-Path $_) }

            foreach ($dir in $candidateDirs) {
              $candlePath = Join-Path $dir "candle.exe"
              if (Test-Path $candlePath) {
                Write-Host "Found candle.exe at $candlePath."
                return $candlePath
              }
            }

            if ($DeepSearch) {
              Write-Host "No candle.exe in known dirs. Deep searching C:\ for candle.exe (may take time)..."
              try {
                $hit = Get-ChildItem -Path 'C:\' -Filter 'candle.exe' -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($hit) {
                  Write-Host "Deep search found candle.exe at $($hit.FullName)."
                  return $hit.FullName
                } else {
                  Write-Host "Deep search did not find candle.exe on C:\."
                }
              } catch {
                Write-Warning "Deep search failed: $($_.Exception.Message)"
              }
            }

            return $null
          }

          # 1. Try PATH directly
          $candleCmd = Get-Command candle.exe -ErrorAction SilentlyContinue
          $candlePath = $null
          if ($candleCmd) {
            $candlePath = $candleCmd.Source
            Write-Host "candle.exe found on PATH at $candlePath"
          } else {
            # 2. Try common locations
            $candlePath = Find-Candle
          }

          # 3. If still not found, try installing via Chocolatey (best effort)
          if (-not $candlePath) {
            Write-Host "candle.exe still not found. Trying to install WiX Toolset via Chocolatey (latest 3.x)..."

            if (-not (Get-Command choco.exe -ErrorAction SilentlyContinue)) {
              Write-Host "Chocolatey not found, installing Chocolatey..."
              Set-ExecutionPolicy Bypass -Scope Process -Force
              [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
              Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
            }

            try {
              choco install wixtoolset -y --no-progress
            } catch {
              Write-Warning "Chocolatey install failed: $($_.Exception.Message)"
            }

            # 4. After choco, re-check (including deep search)
            $candleCmd = Get-Command candle.exe -ErrorAction SilentlyContinue
            if ($candleCmd) {
              $candlePath = $candleCmd.Source
              Write-Host "After Chocolatey, candle.exe found on PATH at $candlePath"
            } else {
              $candlePath = Find-Candle -DeepSearch
            }
          }

          if (-not $candlePath -or -not (Test-Path $candlePath)) {
            throw "candle.exe still not found after all attempts. Please install WiX Toolset 3.x on this runner and ensure candle.exe exists (e.g., via Chocolatey or MSI)."
          }

          # Resolve light.exe in same directory (or via PATH as fallback)
          $wixDir = Split-Path $candlePath -Parent
          $lightPath = Join-Path $wixDir "light.exe"
          if (-not (Test-Path $lightPath)) {
            $lightCmd = Get-Command light.exe -ErrorAction SilentlyContinue
            if ($lightCmd) {
              $lightPath = $lightCmd.Source
            }
          }

          if (-not (Test-Path $lightPath)) {
            throw "Found candle.exe at '$candlePath' but could not find light.exe in the same directory or on PATH. Please ensure a full WiX Toolset 3.x install (candle.exe and light.exe)."
          }

          Write-Host "Resolved WiX tools:"
          Write-Host "  candle.exe = $candlePath"
          Write-Host "  light.exe  = $lightPath"

          # Export for subsequent steps
          Write-Env "CANDLE_EXE" $candlePath
          Write-Env "LIGHT_EXE"  $lightPath

      ###########################################################################
      # BUILD MSI USING main.wxs
      ###########################################################################

      - name: Build MSI
        run: |
          $ErrorActionPreference = "Stop"

          if (-not $env:CANDLE_EXE -or -not (Test-Path $env:CANDLE_EXE)) {
            throw "CANDLE_EXE env var is not set or does not point to a valid file. Ensure 'Ensure WiX Toolset' step ran successfully."
          }
          if (-not $env:LIGHT_EXE -or -not (Test-Path $env:LIGHT_EXE)) {
            throw "LIGHT_EXE env var is not set or does not point to a valid file. Ensure 'Ensure WiX Toolset' step ran successfully."
          }

          $candle = $env:CANDLE_EXE
          $light  = $env:LIGHT_EXE

          Write-Host "Using candle.exe at: $candle"
          Write-Host "Using light.exe  at: $light"

          $Root = "C:\wix\mirrord"
          New-Item -ItemType Directory -Force -Path $Root | Out-Null

          # COPY ARTIFACTS + ASSETS
          Copy-Item $env:MIRRORD_EXE "$Root\mirrord.exe" -Force
          Copy-Item $env:MIRRORD_LAYER_FILE "$Root\mirrord_layer_win.dll" -Force
          Copy-Item "$env:GITHUB_WORKSPACE\mirrord\cli\wix\mirrord.ico" "$Root\mirrord.ico" -Force
          Copy-Item "$env:GITHUB_WORKSPACE\mirrord\cli\wix\License.rtf" "$Root\License.rtf" -Force
          Copy-Item "$env:GITHUB_WORKSPACE\mirrord\cli\wix\main.wxs" "$Root\main.wxs" -Force

          $Obj = "$Root\main.wixobj"
          $Msi = "$Root\mirrord.msi"

          if (Test-Path $Msi) { Remove-Item $Msi -Force }

          & $candle -nologo -v "$Root\main.wxs" -out $Obj
          & $light  -nologo -v $Obj -out $Msi -ext WixUIExtension -sval

          if (-not (Test-Path $Msi)) { throw "MSI not produced" }

          "MSI_PATH=$Msi" | Out-File -Append -FilePath $env:GITHUB_ENV

      ###########################################################################
      # SIGN MSI (optional, same cert as EXE/DLL)
      ###########################################################################

      - name: Sign MSI
        if: env.SIGN_ARTIFACTS == 'true'
        run: |
          $ErrorActionPreference = "Stop"
          $msi = $env:MSI_PATH
          if (-not (Test-Path $msi)) {
            throw "MSI_PATH '$msi' does not exist."
          }
          & signtool.exe sign /sha1 BFA0BEA8D22265CB382D2D5DEC55A6FFCFF70BCB `
              /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 "$msi"

      ###########################################################################
      # UPLOAD MSI TO PUBLIC GCS BUCKET
      ###########################################################################

      - name: Upload MSI to GCS
        run: |
          $ErrorActionPreference = "Stop"
          $msi = $env:MSI_PATH
          if (-not (Test-Path $msi)) {
            throw "MSI_PATH '$msi' does not exist."
          }

          # Build a unique folder per run:
          # gs://mirrord-windows-builds-public/<ref-name>/run-<run-id>/mirrord.msi
          $runId = $env:GITHUB_RUN_ID
          $refName = $env:GITHUB_REF_NAME
          if (-not $refName) {
            $refName = "unknown"
          }

          # Sanitize ref name for use in path
          $refSafe = $refName -replace '[^A-Za-z0-9\.\-]', '_'

          $bucketBase = $env:MSI_BUCKET_URI.TrimEnd('/')
          $destFolder = "$bucketBase/$refSafe/run-$runId"
          $destUri = "$destFolder/mirrord.msi"

          Write-Host "Uploading MSI to $destUri"
          gcloud --quiet storage cp $msi $destUri

          # Export for later (summary, logs, HTTP URL computation)
          "MSI_GCS_REF_SAFE=$refSafe" | Out-File -Append -FilePath $env:GITHUB_ENV
          "MSI_GCS_RUN_ID=$runId" | Out-File -Append -FilePath $env:GITHUB_ENV
          "MSI_GCS_URI=$destUri" | Out-File -Append -FilePath $env:GITHUB_ENV

      ###########################################################################
      # UNIT TESTS (Windows-only crates)
      ###########################################################################

      - name: Run Rust unit tests (Windows crates)
        run: |
          $ErrorActionPreference = "Stop"
          cargo test --target=x86_64-pc-windows-msvc -p mirrord -p mirrord-layer-win

      ###########################################################################
      # RELEASE TAG (for GitHub Release + Chocolatey + WinGet)
      ###########################################################################

      - name: Compute release tag
        id: tag
        if: ${{ github.event_name != 'pull_request' && (startsWith(github.ref, 'refs/tags/') || env.PUBLISH_MODE != 'no' || env.PUBLISH_CHOCO == 'true' || env.PUBLISH_WINGET == 'true') }}
        run: |
          $ErrorActionPreference = "Stop"

          if ("$env:GITHUB_REF".StartsWith("refs/tags/")) {
            # From tag ref, e.g. refs/tags/v3.174.0 or refs/tags/3.174.0
            $tag = "$env:GITHUB_REF".Substring(10)
          } elseif ($env:RELEASE_TAG_INPUT) {
            # From manual input
            $tag = $env:RELEASE_TAG_INPUT
          } else {
            # Fall back to MIRRORD_VERSION (no v prefix)
            $tag = $env:MIRRORD_VERSION
          }

          # Remove leading 'v' prefix if present (normalize to e.g. 3.174.0)
          if ($tag.StartsWith("v")) {
            $tag = $tag.Substring(1)
          }

          "RELEASE_TAG=$tag" | Out-File -Append -FilePath $env:GITHUB_ENV
          Write-Host "Using RELEASE_TAG: $tag"

      ###########################################################################
      # UPLOAD ARTIFACTS TO EXISTING GITHUB RELEASE (optional)
      ###########################################################################

      - name: Upload artifacts to GitHub Release (custom)
        if: ${{ github.event_name != 'pull_request' && (startsWith(github.ref, 'refs/tags/') || env.PUBLISH_MODE != 'no') }}
        uses: actions/github-script@v7
        env:
          MSI_PATH: ${{ env.MSI_PATH }}
          MIRRORD_EXE: ${{ env.MIRRORD_EXE }}
          MIRRORD_LAYER_FILE: ${{ env.MIRRORD_LAYER_FILE }}
          RELEASE_TAG: ${{ env.RELEASE_TAG }}
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const { owner, repo } = context.repo;

            const tag = process.env.RELEASE_TAG;

            // Look up existing release — DO NOT create one here
            let rel;
            try {
              const r = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              rel = r.data;
            } catch (e) {
              core.setFailed(
                `Release with tag '${tag}' was not found. ` +
                `Ensure the main Release workflow created it before running Windows Build.`
              );
              return;
            }

            async function upload(filePath) {
              if (!filePath) return;
              if (!fs.existsSync(filePath)) {
                core.warning(`File not found, skipping upload: ${filePath}`);
                return;
              }

              const name = path.basename(filePath);

              // If asset exists, DO NOT delete or re-upload – just log and skip
              const existing = rel.assets?.find(a => a.name === name);
              if (existing) {
                core.info(`Asset '${name}' already exists (id=${existing.id}), skipping upload.`);
                return;
              }

              const data = fs.readFileSync(filePath);

              await github.rest.repos.uploadReleaseAsset({
                owner,
                repo,
                release_id: rel.id,
                name,
                data,
                headers: {
                  "content-type": "application/octet-stream",
                  "content-length": data.length
                }
              });

              core.info(`Uploaded asset '${name}' (${data.length} bytes)`);
            }

            await upload(process.env.MIRRORD_EXE);
            await upload(process.env.MIRRORD_LAYER_FILE);
            await upload(process.env.MSI_PATH);

      ###########################################################################
      # COMPUTE MSI DOWNLOAD URL (GitHub Release OR PUBLIC GCS)
      ###########################################################################

      - name: Compute MSI download URL for WinGet
        if: ${{ github.event_name != 'pull_request' && (env.PUBLISH_MODE != 'no' || env.PUBLISH_WINGET == 'true') }}
        run: |
          $ErrorActionPreference = "Stop"

          $repoFull = $env:GITHUB_REPOSITORY
          if (-not $repoFull) {
            throw "GITHUB_REPOSITORY is not set."
          }

          $tag = $env:RELEASE_TAG
          if (-not $tag) {
            throw "RELEASE_TAG is not set; ensure 'Compute release tag' step ran."
          }

          $publishMode = $env:PUBLISH_MODE

          if ($publishMode -ne "no") {
            # Real release mode -> GitHub Releases URL
            $url = "https://github.com/$repoFull/releases/download/$tag/mirrord.msi"
            Write-Host "Computed MSI download URL from GitHub Releases: $url"
          } else {
            # Test / WinGet-only mode -> Public GCS URL
            $httpBase = $env:MSI_HTTP_BASE.TrimEnd('/')
            if (-not $httpBase) {
              throw "MSI_HTTP_BASE must be set for WinGet without GitHub Releases."
            }

            $refSafe = $env:MSI_GCS_REF_SAFE
            $runId = $env:MSI_GCS_RUN_ID
            if (-not $refSafe -or -not $runId) {
              throw "MSI_GCS_REF_SAFE/MSI_GCS_RUN_ID not set; ensure 'Upload MSI to GCS' ran."
            }

            $url = "$httpBase/$refSafe/run-$runId/mirrord.msi"
            Write-Host "Computed MSI download URL from GCS HTTP: $url"
          }

          "MSI_DOWNLOAD_URL=$url" | Out-File -Append -FilePath $env:GITHUB_ENV

      ###########################################################################
      # CHOCOLATEY PACKAGE BUILD & PUBLISH
      ###########################################################################

      - name: Build Chocolatey package
        if: ${{ env.PUBLISH_CHOCO == 'true' && github.event_name != 'pull_request' }}
        run: |
          $ErrorActionPreference = "Stop"

          if (-not $env:MSI_PATH -or -not (Test-Path $env:MSI_PATH)) {
            throw "MSI_PATH is not set or file does not exist. Cannot build Chocolatey package."
          }

          if (-not $env:RELEASE_TAG) {
            throw "RELEASE_TAG is not set. Ensure 'Compute release tag' ran successfully."
          }

          $pkgRoot  = Join-Path $env:RUNNER_TEMP "choco"
          $toolsDir = Join-Path $pkgRoot "tools"

          if (Test-Path $pkgRoot) {
            Remove-Item $pkgRoot -Recurse -Force
          }
          New-Item -ItemType Directory -Force -Path $toolsDir | Out-Null

          # Copy MSI into tools directory
          Copy-Item $env:MSI_PATH (Join-Path $toolsDir "mirrord.msi") -Force

          $nuspecPath = Join-Path $pkgRoot "mirrord.nuspec"
          $version    = $env:RELEASE_TAG

          $nuspecLines = @()
          $nuspecLines += '<?xml version="1.0"?>'
          $nuspecLines += '<package xmlns="http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd">'
          $nuspecLines += '  <metadata>'
          $nuspecLines += '    <id>mirrord</id>'
          $nuspecLines += "    <version>$version</version>"
          $nuspecLines += '    <title>mirrord</title>'
          $nuspecLines += '    <authors>MetalBear</authors>'
          $nuspecLines += '    <owners>MetalBear</owners>'
          $nuspecLines += '    <licenseUrl>https://github.com/metalbear-co/mirrord/blob/main/LICENSE</licenseUrl>'
          $nuspecLines += '    <projectUrl>https://github.com/metalbear-co/mirrord</projectUrl>'
          $nuspecLines += '    <iconUrl>https://raw.githubusercontent.com/metalbear-co/mirrord/main/assets/icon.png</iconUrl>'
          $nuspecLines += '    <requireLicenseAcceptance>false</requireLicenseAcceptance>'
          $nuspecLines += '    <description>mirrord lets you run local code in the context of your cloud environment (Kubernetes).</description>'
          $nuspecLines += '    <tags>mirrord kubernetes debugging cloud</tags>'
          $nuspecLines += '  </metadata>'
          $nuspecLines += '  <files>'
          $nuspecLines += '    <file src="tools\**" target="tools" />'
          $nuspecLines += '  </files>'
          $nuspecLines += '</package>'

          $nuspecLines | Set-Content -Encoding UTF8 -Path $nuspecPath

          $installScript = Join-Path $toolsDir "chocolateyinstall.ps1"

          # Use single-quoted strings so $packageName / $msiPath stay literal in script
          $installLines = @()
          $installLines += '$ErrorActionPreference = ''Stop'''
          $installLines += ''
          $installLines += '$packageName = ''mirrord'''
          $installLines += '$toolsDir    = Split-Path -Parent $MyInvocation.MyCommand.Definition'
          $installLines += '$msiPath     = Join-Path $toolsDir ''mirrord.msi'''
          $installLines += ''
          $installLines += 'Install-ChocolateyInstallPackage -PackageName $packageName -FileType ''msi'' -SilentArgs ''/qn /norestart'' -ValidExitCodes @(0, 3010) -File $msiPath'

          $installLines | Set-Content -Encoding UTF8 -Path $installScript

          # Ensure choco is available
          if (-not (Get-Command choco.exe -ErrorAction SilentlyContinue)) {
            throw "choco.exe not found on PATH. Ensure Chocolatey is installed on this runner."
          }

          choco pack $nuspecPath --outputdirectory $pkgRoot

          $nupkg = Get-ChildItem $pkgRoot -Filter "mirrord.$version.nupkg" -File -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $nupkg) {
            $nupkg = Get-ChildItem $pkgRoot -Filter "mirrord*.nupkg" -File | Select-Object -First 1
          }

          if (-not $nupkg) {
            throw "Failed to find generated mirrord nupkg in $pkgRoot"
          }

          "CHOCO_NUPKG_PATH=$($nupkg.FullName)" | Out-File -Append -FilePath $env:GITHUB_ENV
          Write-Host "Built Chocolatey package: $($nupkg.FullName)"

      - name: Push Chocolatey package
        if: ${{ env.PUBLISH_CHOCO == 'true' && github.event_name != 'pull_request' }}
        env:
          CHOCO_API_KEY: ${{ secrets.CHOCO_API_KEY }}
        run: |
          $ErrorActionPreference = "Stop"

          if (-not $env:CHOCO_NUPKG_PATH -or -not (Test-Path $env:CHOCO_NUPKG_PATH)) {
            throw "CHOCO_NUPKG_PATH is not set or file does not exist. Cannot push package."
          }

          if (-not $env:CHOCO_API_KEY) {
            throw "CHOCO_API_KEY is not set. Configure the repository secret 'CHOCO_API_KEY' with your Chocolatey API key."
          }

          Write-Host "Pushing Chocolatey package $env:CHOCO_NUPKG_PATH to Chocolatey.org..."
          choco push $env:CHOCO_NUPKG_PATH --api-key $env:CHOCO_API_KEY --source "https://push.chocolatey.org/"

      ###########################################################################
      # INSTALL .NET RUNTIME FOR WINGETCREATE (non-admin-friendly)
      ###########################################################################

      - name: Install .NET runtime for wingetcreate
        if: ${{ github.event_name != 'pull_request' && env.PUBLISH_WINGET == 'true' }}
        uses: actions/setup-dotnet@v4
        env:
          DOTNET_INSTALL_DIR: ${{ runner.temp }}\dotnet
        with:
          dotnet-version: '8.0.x'

      ###########################################################################
      # UPDATE WinGet MANIFEST (optional, best-effort)
      ###########################################################################

      - name: Update WinGet manifest (wingetcreate)
        if: ${{ github.event_name != 'pull_request' && env.PUBLISH_WINGET == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"

          $packageId = $env:WINGET_PACKAGE_ID
          if (-not $packageId) {
            throw "WINGET_PACKAGE_ID env var is not set."
          }

          $version = $env:RELEASE_TAG
          if (-not $version) {
            throw "RELEASE_TAG env var is not set."
          }

          $installerUrl = $env:MSI_DOWNLOAD_URL
          if (-not $installerUrl) {
            throw "MSI_DOWNLOAD_URL env var is not set."
          }

          $gitToken = "${{ secrets.WINGET_TOKEN }}"
          if (-not $gitToken) {
            throw "secrets.WINGET_TOKEN is not configured in this repo."
          }

          Write-Host "Updating WinGet manifest for package '$packageId' version '$version'"
          Write-Host "Installer URL: $installerUrl"

          # Download latest single-file wingetcreate.exe
          Invoke-WebRequest https://aka.ms/wingetcreate/latest -OutFile wingetcreate.exe

          # Run wingetcreate update and capture output
          $args = @(
            "update", $packageId,
            "--version", $version,
            "--urls", $installerUrl,
            "--submit",
            "--token", $gitToken
          )

          Write-Host "Running: wingetcreate.exe $($args -join ' ')"
          $output = & .\wingetcreate.exe @args 2>&1
          $exitCode = $LASTEXITCODE

          $output | ForEach-Object { Write-Host $_ }

          if ($exitCode -ne 0) {
            if ($output -match "was not found") {
              Write-Warning "WinGet package '$packageId' was not found in microsoft/winget-pkgs. Skipping update (non-fatal)."
              Write-Warning "To create the initial package, run 'wingetcreate new' manually and submit the first PR."
              exit 0
            } else {
              throw "wingetcreate update failed with exit code $exitCode"
            }
          }

      ###########################################################################
      # SUMMARY
      ###########################################################################

      - name: Summary
        if: always()
        run: |
          Write-Host "MSI (local):       $env:MSI_PATH"
          Write-Host "MSI (GCS URI):     $env:MSI_GCS_URI"
          Write-Host "EXE:               $env:MIRRORD_EXE"
          Write-Host "DLL:               $env:MIRRORD_LAYER_FILE"
          Write-Host "MSI HTTP URL:      $env:MSI_DOWNLOAD_URL"
          Write-Host "Choco package:     $env:CHOCO_NUPKG_PATH"
          Write-Host "Publish mode:      $env:PUBLISH_MODE"
          Write-Host "Publish WinGet:    $env:PUBLISH_WINGET"
          Write-Host "Publish Chocolatey:$env.PUBLISH_CHOCO"
